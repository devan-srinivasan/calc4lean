{
    "tactics": [
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 0,
            "pos": {
                "line": 5,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) (Icc 0 4)",
            "endPos": {
                "line": 5,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 1,
            "pos": {
                "line": 6,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 4\ny : \u211d\nhy : y \u2208 Icc 0 4\nhxy : x \u2264 y\n\u22a2 (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) x \u2264\n    (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) y",
            "endPos": {
                "line": 6,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x - y + x + y), sq_nonneg (x - y - (x + y))]",
            "proofState": 2,
            "pos": {
                "line": 7,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 4\nhy : 0 \u2264 y \u2227 y \u2264 4\n\u22a2 (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) x \u2264\n    (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) y",
            "endPos": {
                "line": 8,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 3,
            "pos": {
                "line": 11,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 6 * x ^ 4 + 4 * x ^ 3) (Icc 0 9)",
            "endPos": {
                "line": 11,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "Lean.Name",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "exact fun x hx y hy hxy => by\n  simp only [mul_assoc, mul_comm, mul_left_comm, mul_pow]\n  nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2)]",
            "proofState": 4,
            "pos": {
                "line": 12,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 6 * x ^ 4 + 4 * x ^ 3) ?s\ncase h'\n\u22a2 Icc 0 9 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 14,
                "column": 68
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm, mul_pow]",
            "proofState": 5,
            "pos": {
                "line": 13,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 15 * x ^ 6 + 6 * x ^ 4 + 4 * x ^ 3 \u2264 15 * y ^ 6 + 6 * y ^ 4 + 4 * y ^ 3",
            "endPos": {
                "line": 13,
                "column": 59
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2)]",
            "proofState": 6,
            "pos": {
                "line": 14,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 x ^ 6 * 15 + x ^ 4 * 6 + x ^ 3 * 4 \u2264 y ^ 6 * 15 + y ^ 4 * 6 + y ^ 3 * 4",
            "endPos": {
                "line": 14,
                "column": 68
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Set.Icc",
                "Zero.toOfNat0",
                "OfNat.ofNat",
                "Real.instPreorder"
            ],
            "tactic": "exact Set.Icc_subset_Icc_right (by norm_num)",
            "proofState": 7,
            "pos": {
                "line": 15,
                "column": 2
            },
            "goals": "case h'\n\u22a2 Icc 0 9 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 15,
                "column": 46
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 8,
            "pos": {
                "line": 15,
                "column": 37
            },
            "goals": "\u22a2 9 \u2264 ?m.24796",
            "endPos": {
                "line": 15,
                "column": 45
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 9,
            "pos": {
                "line": 18,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 16 * x ^ 3 + 17 * x ^ 2 + 7 * x + 6) (Icc 0 4)",
            "endPos": {
                "line": 18,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 10,
            "pos": {
                "line": 19,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 16 * x ^ 3 + 17 * x ^ 2 + 7 * x + 6) (Ici 0)",
            "endPos": {
                "line": 19,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm] at hx hy \u22a2",
            "proofState": 11,
            "pos": {
                "line": 20,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 3 + 17 * x ^ 2 + 7 * x + 6) x \u2264 (fun x => 16 * x ^ 3 + 17 * x ^ 2 + 7 * x + 6) y",
            "endPos": {
                "line": 20,
                "column": 59
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x + y), sq_nonneg (x - y), hxy, hx, hy]",
            "proofState": 12,
            "pos": {
                "line": 21,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 x ^ 3 * 16 + x ^ 2 * 17 + x * 7 + 6 \u2264 y ^ 3 * 16 + y ^ 2 * 17 + y * 7 + 6",
            "endPos": {
                "line": 21,
                "column": 63
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ Icc_subset_Ici_self",
            "proofState": 13,
            "pos": {
                "line": 24,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 18 * x ^ 6 + 7 * x ^ 4 + 17 * x ^ 3 + 4) (Icc 0 9)",
            "endPos": {
                "line": 24,
                "column": 45
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 14,
            "pos": {
                "line": 25,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 18 * x ^ 6 + 7 * x ^ 4 + 17 * x ^ 3 + 4) (Ici 0)",
            "endPos": {
                "line": 25,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 15,
            "pos": {
                "line": 26,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 18 * x ^ 6 + 7 * x ^ 4 + 17 * x ^ 3 + 4) x \u2264 (fun x => 18 * x ^ 6 + 7 * x ^ 4 + 17 * x ^ 3 + 4) y",
            "endPos": {
                "line": 26,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 16,
            "pos": {
                "line": 31,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 3 * x ^ 2) (Icc 0 3)",
            "endPos": {
                "line": 31,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hx' : 0 \u2264 x := by\n  cases' hx with hx\u2081 hx\u2082\n  nlinarith",
            "proofState": 17,
            "pos": {
                "line": 32,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nhxy : x \u2264 y\n\u22a2 (fun x => 17 * x ^ 7 + 3 * x ^ 2) x \u2264 (fun x => 17 * x ^ 7 + 3 * x ^ 2) y",
            "endPos": {
                "line": 34,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Membership.mem",
                "instOfNatNat",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "Eq.refl",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "cases' hx with hx\u2081 hx\u2082",
            "proofState": 18,
            "pos": {
                "line": 33,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nhxy : x \u2264 y\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 33,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith",
            "proofState": 19,
            "pos": {
                "line": 34,
                "column": 4
            },
            "goals": "case intro\nx y : \u211d\nhy : y \u2208 Icc 0 3\nhxy : x \u2264 y\nhx\u2081 : 0 \u2264 x\nhx\u2082 : x \u2264 3\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 34,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hy' : y \u2264 3 := by\n  cases' hy with hy\u2081 hy\u2082\n  nlinarith",
            "proofState": 20,
            "pos": {
                "line": 35,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 (fun x => 17 * x ^ 7 + 3 * x ^ 2) x \u2264 (fun x => 17 * x ^ 7 + 3 * x ^ 2) y",
            "endPos": {
                "line": 37,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Membership.mem",
                "instOfNatNat",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "Eq.refl",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "cases' hy with hy\u2081 hy\u2082",
            "proofState": 21,
            "pos": {
                "line": 36,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 y \u2264 3",
            "endPos": {
                "line": 36,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith",
            "proofState": 22,
            "pos": {
                "line": 37,
                "column": 4
            },
            "goals": "case intro\nx : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy\u2081 : 0 \u2264 y\nhy\u2082 : y \u2264 3\n\u22a2 y \u2264 3",
            "endPos": {
                "line": 37,
                "column": 13
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x + y), sq_nonneg (x - y)]",
            "proofState": 23,
            "pos": {
                "line": 38,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : y \u2264 3\n\u22a2 (fun x => 17 * x ^ 7 + 3 * x ^ 2) x \u2264 (fun x => 17 * x ^ 7 + 3 * x ^ 2) y",
            "endPos": {
                "line": 38,
                "column": 50
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 24,
            "pos": {
                "line": 41,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 13 * x ^ 6 + 8 * x ^ 5 + 19 * x ^ 4 + 15 * x ^ 3 + 8 * x ^ 2 + 19 * x + 5) (Icc 0 1)",
            "endPos": {
                "line": 41,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "Real.partialOrder",
                "Real",
                "Preorder.toLT",
                "HMul.hMul",
                "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
                "covariant_swap_add_of_covariant_add",
                "PartialOrder.toPreorder",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "contravariant_lt_of_covariant_le",
                "LE.le",
                "Real.instAddCommSemigroup",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_4",
                "Nat",
                "Real.instMul",
                "LT.lt",
                "Real.instAddCommMonoid",
                "contravariant_swap_add_of_contravariant_add",
                "AddCommSemigroup.toAddCommMagma",
                "instHPow",
                "Real.instIsOrderedAddMonoid",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "IsOrderedCancelAddMonoid.toIsCancelAdd",
                "IsCancelAdd.toIsRightCancelAdd",
                "Real.instPreorder",
                "Real.linearOrder",
                "AddCommMagma.toAdd",
                "IsOrderedAddMonoid.toAddLeftMono",
                "instHMul",
                "Real.instNatCast",
                "Real.instIsOrderedCancelAddMonoid"
            ],
            "tactic": "norm_num",
            "proofState": 25,
            "pos": {
                "line": 42,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 13 * x ^ 6 + 8 * x ^ 5 + 19 * x ^ 4 + 15 * x ^ 3 + 8 * x ^ 2 + 19 * x + 5) x \u2264\n    (fun x => 5 * x ^ 7 + 13 * x ^ 6 + 8 * x ^ 5 + 19 * x ^ 4 + 15 * x ^ 3 + 8 * x ^ 2 + 19 * x + 5) y",
            "endPos": {
                "line": 42,
                "column": 10
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "Real",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Real.instAddMonoid",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "AddGroupWithOne.toAddMonoidWithOne",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "Real.instRing",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "Real.instAdd",
                "AddMonoidWithOne.toOne",
                "Real.instMonoid",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Real.instMul",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Real.instCommSemiring",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "ring_nf",
            "proofState": 26,
            "pos": {
                "line": 43,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\n\u22a2 5 * x ^ 7 + 13 * x ^ 6 + 8 * x ^ 5 + 19 * x ^ 4 + 15 * x ^ 3 + 8 * x ^ 2 + 19 * x \u2264\n    5 * y ^ 7 + 13 * y ^ 6 + 8 * y ^ 5 + 19 * y ^ 4 + 15 * y ^ 3 + 8 * y ^ 2 + 19 * y",
            "endPos": {
                "line": 43,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x - 1 / 2), sq_nonneg (x + 1 / 2), sq_nonneg (y - 1 / 2),\n  sq_nonneg (y + 1 / 2)]",
            "proofState": 27,
            "pos": {
                "line": 44,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\n\u22a2 x * 19 + x ^ 2 * 8 + x ^ 3 * 15 + x ^ 4 * 19 + x ^ 5 * 8 + x ^ 6 * 13 + x ^ 7 * 5 \u2264\n    y * 19 + y ^ 2 * 8 + y ^ 3 * 15 + y ^ 4 * 19 + y ^ 5 * 8 + y ^ 6 * 13 + y ^ 7 * 5",
            "endPos": {
                "line": 45,
                "column": 49
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 28,
            "pos": {
                "line": 48,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) (Icc 0 8)",
            "endPos": {
                "line": 48,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have h\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20 := by nlinarith",
            "proofState": 29,
            "pos": {
                "line": 49,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x \u2264\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y",
            "endPos": {
                "line": 49,
                "column": 97
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith",
            "proofState": 30,
            "pos": {
                "line": 49,
                "column": 88
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\n\u22a2 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20",
            "endPos": {
                "line": 49,
                "column": 97
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have h\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20 := by nlinarith",
            "proofState": 31,
            "pos": {
                "line": 50,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\n\u22a2 (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x \u2264\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y",
            "endPos": {
                "line": 50,
                "column": 97
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith",
            "proofState": 32,
            "pos": {
                "line": 50,
                "column": 88
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\n\u22a2 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20",
            "endPos": {
                "line": 50,
                "column": 97
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Real.instSub",
                "HSub.hSub",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instHSub",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have h\u2083 : 0 \u2264 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20 := by\n  nlinarith [sq_nonneg (y - x), sq_nonneg (y + x), sq_nonneg (2 * y - x), sq_nonneg (y + 2 * x), sq_nonneg (y - 2 * x),\n    sq_nonneg (2 * y + x), sq_nonneg (2 * y - 3 * x), sq_nonneg (3 * y - 2 * x)]",
            "proofState": 33,
            "pos": {
                "line": 51,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\n\u22a2 (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x \u2264\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y",
            "endPos": {
                "line": 53,
                "column": 105
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (y - x), sq_nonneg (y + x), sq_nonneg (2 * y - x), sq_nonneg (y + 2 * x), sq_nonneg (y - 2 * x),\n  sq_nonneg (2 * y + x), sq_nonneg (2 * y - 3 * x), sq_nonneg (3 * y - 2 * x)]",
            "proofState": 34,
            "pos": {
                "line": 52,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\n\u22a2 0 \u2264 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20",
            "endPos": {
                "line": 53,
                "column": 105
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (y - x), sq_nonneg (y + x), sq_nonneg (2 * y - x), sq_nonneg (y + 2 * x), sq_nonneg (y - 2 * x),\n  sq_nonneg (2 * y + x), sq_nonneg (2 * y - 3 * x), sq_nonneg (3 * y - 2 * x)]",
            "proofState": 35,
            "pos": {
                "line": 54,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\nh\u2083 : 0 \u2264 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20\n\u22a2 (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x \u2264\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y",
            "endPos": {
                "line": 55,
                "column": 103
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 36,
            "pos": {
                "line": 58,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 10 * x ^ 5 + 9 * x ^ 3 + 12 * x ^ 2 + 2 * x + 12) (Icc 0 5)",
            "endPos": {
                "line": 58,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Icc_subset_Icc_iff] at hx hy",
            "proofState": 37,
            "pos": {
                "line": 59,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 5\ny : \u211d\nhy : y \u2208 Icc 0 5\nhxy : x \u2264 y\n\u22a2 (fun x => 10 * x ^ 5 + 9 * x ^ 3 + 12 * x ^ 2 + 2 * x + 12) x \u2264\n    (fun x => 10 * x ^ 5 + 9 * x ^ 3 + 12 * x ^ 2 + 2 * x + 12) y",
            "endPos": {
                "line": 59,
                "column": 41
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 38,
            "pos": {
                "line": 64,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2) (Icc 0 8)",
            "endPos": {
                "line": 64,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp_all only [Icc_def, le_refl, le_of_lt, true_and, and_true, le_of_eq]",
            "proofState": 39,
            "pos": {
                "line": 65,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2) x \u2264\n    (fun x => 12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2) y",
            "endPos": {
                "line": 65,
                "column": 74
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + 2 * x ^ 2), sq_nonneg (y ^ 3 + 2 * y ^ 2)]",
            "proofState": 40,
            "pos": {
                "line": 66,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nhxy : x \u2264 y\n\u22a2 12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2 \u2264\n    12 * y ^ 7 + 4 * y ^ 6 + 5 * y ^ 5 + 20 * y ^ 4 + 19 * y ^ 3 + 4 * y ^ 2",
            "endPos": {
                "line": 66,
                "column": 74
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.of_deriv (fun x hx => _)",
            "proofState": 41,
            "pos": {
                "line": 69,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 2 * x ^ 4 + 7 * x ^ 3 + 8 * x ^ 2 + 19 * x + 12) (Icc 0 7)",
            "endPos": {
                "line": 69,
                "column": 43
            }
        },
        {
            "usedConstants": [],
            "tactic": "intro x hx",
            "proofState": 42,
            "pos": {
                "line": 70,
                "column": 2
            },
            "goals": "no goals",
            "endPos": {
                "line": 70,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ <| Icc_subset_Ici_self",
            "proofState": 43,
            "pos": {
                "line": 83,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 18 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 2) (Icc 0 10)",
            "endPos": {
                "line": 83,
                "column": 48
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 44,
            "pos": {
                "line": 84,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 18 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 2) (Ici 0)",
            "endPos": {
                "line": 84,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 45,
            "pos": {
                "line": 85,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 7 + 18 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 2) x \u2264\n    (fun x => 12 * x ^ 7 + 18 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 2) y",
            "endPos": {
                "line": 85,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 46,
            "pos": {
                "line": 89,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 18 * x ^ 6 + 2 * x ^ 5 + 17 * x ^ 3 + 7 * x) (Icc 0 4)",
            "endPos": {
                "line": 89,
                "column": 23
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact\n  (monotone_iff_forall_lt.2 fun x _ y _ h => by\n    nlinarith [sq_nonneg (x + y), sq_nonneg (x - y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2),\n      sq_nonneg (x ^ 4 - y ^ 4), sq_nonneg (x ^ 5 - y ^ 5), sq_nonneg (x ^ 6 - y ^ 6), sq_nonneg (x ^ 7 - y ^ 7)])",
            "proofState": 47,
            "pos": {
                "line": 90,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 18 * x ^ 6 + 2 * x ^ 5 + 17 * x ^ 3 + 7 * x) ?s\ncase h'\n\u22a2 Icc 0 4 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 93,
                "column": 3
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x + y), sq_nonneg (x - y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2),\n  sq_nonneg (x ^ 4 - y ^ 4), sq_nonneg (x ^ 5 - y ^ 5), sq_nonneg (x ^ 6 - y ^ 6), sq_nonneg (x ^ 7 - y ^ 7)]",
            "proofState": 48,
            "pos": {
                "line": 91,
                "column": 4
            },
            "goals": "x x\u271d\u00b9 : ?m.161687\ny : x < x\u271d\u00b9\nx\u271d : ?m.162004 x x\u271d\u00b9 y\nh : ?m.162005 x x\u271d\u00b9 y x\u271d\n\u22a2 ?m.162006 x x\u271d\u00b9 y x\u271d h",
            "endPos": {
                "line": 92,
                "column": 113
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 49,
            "pos": {
                "line": 102,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 10 * x ^ 7 + 18 * x ^ 6 + 11 * x ^ 5 + 14 * x ^ 4 + 20 * x ^ 3 + 13 * x ^ 2 + 5 * x + 8)\n    (Icc 0 10)",
            "endPos": {
                "line": 102,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx",
            "proofState": 50,
            "pos": {
                "line": 103,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 10 * x ^ 7 + 18 * x ^ 6 + 11 * x ^ 5 + 14 * x ^ 4 + 20 * x ^ 3 + 13 * x ^ 2 + 5 * x + 8) (Ici 0)",
            "endPos": {
                "line": 103,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro y hy",
            "proofState": 51,
            "pos": {
                "line": 104,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 Ici 0 \u2192\n      x \u2264 b \u2192\n        (fun x => 10 * x ^ 7 + 18 * x ^ 6 + 11 * x ^ 5 + 14 * x ^ 4 + 20 * x ^ 3 + 13 * x ^ 2 + 5 * x + 8) x \u2264\n          (fun x => 10 * x ^ 7 + 18 * x ^ 6 + 11 * x ^ 5 + 14 * x ^ 4 + 20 * x ^ 3 + 13 * x ^ 2 + 5 * x + 8) b",
            "endPos": {
                "line": 104,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "Real",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Real.instAddMonoid",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "AddGroupWithOne.toAddMonoidWithOne",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "Real.instRing",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "Real.instAdd",
                "AddMonoidWithOne.toOne",
                "Real.instMonoid",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "implies_congr",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Real.instMul",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Real.instCommSemiring",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "ring_nf",
            "proofState": 52,
            "pos": {
                "line": 105,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\n\u22a2 x \u2264 y \u2192\n    (fun x => 10 * x ^ 7 + 18 * x ^ 6 + 11 * x ^ 5 + 14 * x ^ 4 + 20 * x ^ 3 + 13 * x ^ 2 + 5 * x + 8) x \u2264\n      (fun x => 10 * x ^ 7 + 18 * x ^ 6 + 11 * x ^ 5 + 14 * x ^ 4 + 20 * x ^ 3 + 13 * x ^ 2 + 5 * x + 8) y",
            "endPos": {
                "line": 105,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x + y - 2), sq_nonneg (x + y + 2)]",
            "proofState": 53,
            "pos": {
                "line": 106,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\n\u22a2 x \u2264 y \u2192\n    8 + x * 5 + x ^ 2 * 13 + x ^ 3 * 20 + x ^ 4 * 14 + x ^ 5 * 11 + x ^ 6 * 18 + x ^ 7 * 10 \u2264\n      8 + y * 5 + y ^ 2 * 13 + y ^ 3 * 20 + y ^ 4 * 14 + y ^ 5 * 11 + y ^ 6 * 18 + y ^ 7 * 10",
            "endPos": {
                "line": 106,
                "column": 96
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 54,
            "pos": {
                "line": 109,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x) (Icc 0 8)",
            "endPos": {
                "line": 109,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [MonotoneOn, Set.mem_Icc] at hx hy h \u22a2",
            "proofState": 55,
            "pos": {
                "line": 110,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x) x \u2264\n    (fun x => 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x) y",
            "endPos": {
                "line": 110,
                "column": 50
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 56,
            "pos": {
                "line": 111,
                "column": 2
            },
            "goals": "x y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 8\nhy : 0 \u2264 y \u2227 y \u2264 8\n\u22a2 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x \u2264 16 * y ^ 6 + 12 * y ^ 5 + 6 * y ^ 3 + 15 * y ^ 2 + 8 * y",
            "endPos": {
                "line": 112,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 57,
            "pos": {
                "line": 115,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) (Icc 0 10)",
            "endPos": {
                "line": 115,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 58,
            "pos": {
                "line": 116,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 10\ny : \u211d\nhy : y \u2208 Icc 0 10\nhxy : x \u2264 y\n\u22a2 (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) x \u2264\n    (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) y",
            "endPos": {
                "line": 116,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (x ^ 2 + x), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (y ^ 2 + y),\n  sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 59,
            "pos": {
                "line": 117,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\n\u22a2 (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) x \u2264\n    (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) y",
            "endPos": {
                "line": 119,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 60,
            "pos": {
                "line": 122,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 8 * x ^ 5 + 15 * x ^ 2) (Icc 0 6)",
            "endPos": {
                "line": 122,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 61,
            "pos": {
                "line": 123,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 8 * x ^ 5 + 15 * x ^ 2) (Ici 0)",
            "endPos": {
                "line": 123,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [Function.comp_apply, mul_assoc, mul_comm, mul_left_comm, mul_right_comm] at hx hy \u22a2",
            "proofState": 62,
            "pos": {
                "line": 124,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 8 * x ^ 6 + 8 * x ^ 5 + 15 * x ^ 2) x \u2264 (fun x => 8 * x ^ 6 + 8 * x ^ 5 + 15 * x ^ 2) y",
            "endPos": {
                "line": 125,
                "column": 30
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 63,
            "pos": {
                "line": 126,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 x ^ 6 * 8 + x ^ 5 * 8 + x ^ 2 * 15 \u2264 y ^ 6 * 8 + y ^ 5 * 8 + y ^ 2 * 15",
            "endPos": {
                "line": 127,
                "column": 57
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 64,
            "pos": {
                "line": 130,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) (Icc 0 10)",
            "endPos": {
                "line": 130,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x - y + x + y), sq_nonneg (x - y - x - y)]",
            "proofState": 65,
            "pos": {
                "line": 131,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 10\ny : \u211d\nhy : y \u2208 Icc 0 10\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) x \u2264 (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) y",
            "endPos": {
                "line": 132,
                "column": 30
            }
        },
        {
            "usedConstants": [],
            "tactic": "refine' monotoneOn_of_deriv_nonneg _ _",
            "proofState": 66,
            "pos": {
                "line": 135,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 16 * x ^ 7 + 11 * x ^ 6 + 2 * x ^ 4 + 19 * x ^ 2) (Icc 0 7)",
            "endPos": {
                "line": 135,
                "column": 40
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 67,
            "pos": {
                "line": 144,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) (Icc 0 2)",
            "endPos": {
                "line": 144,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 68,
            "pos": {
                "line": 145,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 2\ny : \u211d\nhy : y \u2208 Icc 0 2\nh : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) x \u2264\n    (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) y",
            "endPos": {
                "line": 145,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 69,
            "pos": {
                "line": 146,
                "column": 2
            },
            "goals": "x y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 2\nhy : 0 \u2264 y \u2227 y \u2264 2\n\u22a2 (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) x \u2264\n    (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) y",
            "endPos": {
                "line": 146,
                "column": 120
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 70,
            "pos": {
                "line": 149,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 3 * x ^ 6 + 17 * x ^ 4 + 13 * x ^ 3 + 2 * x ^ 2 + 18 * x + 13) (Icc 0 2)",
            "endPos": {
                "line": 149,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 71,
            "pos": {
                "line": 150,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 3 * x ^ 6 + 17 * x ^ 4 + 13 * x ^ 3 + 2 * x ^ 2 + 18 * x + 13) (Ici 0)",
            "endPos": {
                "line": 150,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 72,
            "pos": {
                "line": 151,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 6 * x ^ 7 + 3 * x ^ 6 + 17 * x ^ 4 + 13 * x ^ 3 + 2 * x ^ 2 + 18 * x + 13) x \u2264\n    (fun x => 6 * x ^ 7 + 3 * x ^ 6 + 17 * x ^ 4 + 13 * x ^ 3 + 2 * x ^ 2 + 18 * x + 13) y",
            "endPos": {
                "line": 151,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 73,
            "pos": {
                "line": 155,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 2 * x ^ 3 + 11 * x + 4) (Icc 0 6)",
            "endPos": {
                "line": 155,
                "column": 49
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 74,
            "pos": {
                "line": 156,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 2 * x ^ 3 + 11 * x + 4) (Ici 0)",
            "endPos": {
                "line": 156,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "exact fun x hx y hy hxy => by nlinarith [sq_nonneg (x - y)]",
            "proofState": 75,
            "pos": {
                "line": 157,
                "column": 4
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 2 * x ^ 3 + 11 * x) (Ici 0)",
            "endPos": {
                "line": 157,
                "column": 63
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y)]",
            "proofState": 76,
            "pos": {
                "line": 157,
                "column": 34
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 2 * x ^ 3 + 11 * x \u2264 2 * y ^ 3 + 11 * y",
            "endPos": {
                "line": 157,
                "column": 63
            }
        },
        {
            "usedConstants": [
                "Real.instIsOrderedRing",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Real.partialOrder",
                "Real",
                "Preorder.toLT",
                "HMul.hMul",
                "Set.Ici",
                "Nat.rawCast",
                "Ring.toNonAssocRing",
                "Real.instZero",
                "AddGroupWithOne.toAddGroup",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.neg_zero",
                "Int.rawCast",
                "PartialOrder.toPreorder",
                "AddGroupWithOne.toAddMonoidWithOne",
                "HSub.hSub",
                "Linarith.sub_neg_of_lt",
                "Mathlib.Meta.NormNum.IsNat.of_raw",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Membership.mem",
                "le_of_not_gt",
                "Mathlib.Tactic.Ring.cast_zero",
                "Eq.mp",
                "Mathlib.Tactic.Ring.sub_pf",
                "Mathlib.Tactic.Ring.neg_add",
                "Distrib.toAdd",
                "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
                "AddMonoidWithOne.toNatCast",
                "Int.ofNat",
                "Real.instRing",
                "instOfNatNat",
                "Int",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Tactic.Ring.sub_congr",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "Mathlib.Meta.NormNum.isInt_mul",
                "LE.le",
                "Mathlib.Tactic.Ring.of_eq",
                "Mathlib.Tactic.Ring.add_pf_zero_add",
                "NonAssocRing.toNonUnitalNonAssocRing",
                "SubNegMonoid.toSub",
                "GT.gt",
                "instHAdd",
                "instHSub",
                "instNatAtLeastTwo",
                "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
                "AddGroup.toSubNegMonoid",
                "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
                "Distrib.toMul",
                "HAdd.hAdd",
                "Mathlib.Meta.NormNum.IsInt.to_isNat",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Nat",
                "LT.lt",
                "NonUnitalNonAssocSemiring.toDistrib",
                "Zero.toOfNat0",
                "Mathlib.Meta.NormNum.isInt_add",
                "Eq.refl",
                "Mathlib.Meta.NormNum.IsInt.of_raw",
                "Nat.cast_zero",
                "Mathlib.Tactic.Ring.cast_pos",
                "OfNat.ofNat",
                "LinearOrder.toPartialOrder",
                "Linarith.lt_irrefl",
                "Semiring.toNonAssocSemiring",
                "Set.instMembership",
                "Mathlib.Tactic.Ring.neg_one_mul",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.linearOrder",
                "Int.negOfNat",
                "MulZeroClass.toZero",
                "Real.instCommSemiring",
                "Mathlib.Meta.NormNum.IsNat.to_isInt",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "exact fun x hx y hy hxy => by nlinarith [sq_nonneg (x - y)]",
            "proofState": 77,
            "pos": {
                "line": 158,
                "column": 4
            },
            "goals": "case hg\n\u22a2 MonotoneOn (fun x => 4) (Ici 0)",
            "endPos": {
                "line": 158,
                "column": 63
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith [sq_nonneg (x - y)]",
            "proofState": 78,
            "pos": {
                "line": 158,
                "column": 34
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 4 \u2264 4",
            "endPos": {
                "line": 158,
                "column": 63
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 79,
            "pos": {
                "line": 161,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 14 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 14 * x ^ 3 + 2 * x ^ 2 + 18 * x + 19) (Icc 0 10)",
            "endPos": {
                "line": 161,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx",
            "proofState": 80,
            "pos": {
                "line": 162,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 14 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 14 * x ^ 3 + 2 * x ^ 2 + 18 * x + 19) (Ici 0)",
            "endPos": {
                "line": 162,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro y hy",
            "proofState": 81,
            "pos": {
                "line": 163,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 Ici 0 \u2192\n      x \u2264 b \u2192\n        (fun x => 14 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 14 * x ^ 3 + 2 * x ^ 2 + 18 * x + 19) x \u2264\n          (fun x => 14 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 14 * x ^ 3 + 2 * x ^ 2 + 18 * x + 19) b",
            "endPos": {
                "line": 163,
                "column": 12
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 82,
            "pos": {
                "line": 164,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\n\u22a2 x \u2264 y \u2192\n    (fun x => 14 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 14 * x ^ 3 + 2 * x ^ 2 + 18 * x + 19) x \u2264\n      (fun x => 14 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 14 * x ^ 3 + 2 * x ^ 2 + 18 * x + 19) y",
            "endPos": {
                "line": 164,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 83,
            "pos": {
                "line": 169,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) (Icc 0 5)",
            "endPos": {
                "line": 169,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx",
            "proofState": 84,
            "pos": {
                "line": 170,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) ?s\ncase h'\n\u22a2 Icc 0 5 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 170,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro y hy",
            "proofState": 85,
            "pos": {
                "line": 171,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?s \u2192 x \u2264 b \u2192 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) x \u2264 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) b\ncase h'\n\u22a2 Icc 0 5 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 171,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real",
                "Preorder.toLE",
                "LE.le",
                "Real.instPreorder"
            ],
            "tactic": "intro h",
            "proofState": 86,
            "pos": {
                "line": 172,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) x \u2264 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) y\ncase h'\n\u22a2 Icc 0 5 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 172,
                "column": 9
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "Real",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Real.instAddMonoid",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "AddGroupWithOne.toAddMonoidWithOne",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "Real.instRing",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "Real.instAdd",
                "AddMonoidWithOne.toOne",
                "Real.instMonoid",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Real.instMul",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Real.instCommSemiring",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "ring_nf",
            "proofState": 87,
            "pos": {
                "line": 173,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nh : x \u2264 y\n\u22a2 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) x \u2264 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) y\ncase h'\n\u22a2 Icc 0 5 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 173,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y)]",
            "proofState": 88,
            "pos": {
                "line": 174,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nh : x \u2264 y\n\u22a2 12 + x * 19 + x ^ 2 * 3 + x ^ 4 * 9 \u2264 12 + y * 19 + y ^ 2 * 3 + y ^ 4 * 9\ncase h'\n\u22a2 Icc 0 5 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 174,
                "column": 50
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 89,
            "pos": {
                "line": 177,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 2 * x ^ 7 + 14 * x ^ 6 + 3 * x ^ 3 + 20 * x ^ 2 + 13 * x) (Icc 0 5)",
            "endPos": {
                "line": 177,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm] at *",
            "proofState": 90,
            "pos": {
                "line": 178,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 5\ny : \u211d\nhy : y \u2208 Icc 0 5\nhxy : x \u2264 y\n\u22a2 (fun x => 2 * x ^ 7 + 14 * x ^ 6 + 3 * x ^ 3 + 20 * x ^ 2 + 13 * x) x \u2264\n    (fun x => 2 * x ^ 7 + 14 * x ^ 6 + 3 * x ^ 3 + 20 * x ^ 2 + 13 * x) y",
            "endPos": {
                "line": 178,
                "column": 53
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 91,
            "pos": {
                "line": 179,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 5\ny : \u211d\nhy : y \u2208 Icc 0 5\nhxy : x \u2264 y\n\u22a2 x ^ 7 * 2 + x ^ 6 * 14 + x ^ 3 * 3 + x ^ 2 * 20 + x * 13 \u2264 y ^ 7 * 2 + y ^ 6 * 14 + y ^ 3 * 3 + y ^ 2 * 20 + y * 13",
            "endPos": {
                "line": 179,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Set.Icc_subset_Ici_self)",
            "proofState": 92,
            "pos": {
                "line": 182,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 2 + 6) (Icc 0 4)",
            "endPos": {
                "line": 182,
                "column": 51
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 93,
            "pos": {
                "line": 183,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 2 + 6) (Ici 0)",
            "endPos": {
                "line": 183,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 94,
            "pos": {
                "line": 184,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 2 + 6) x \u2264 (fun x => 15 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 2 + 6) y",
            "endPos": {
                "line": 184,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 95,
            "pos": {
                "line": 188,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) (Icc 0 7)",
            "endPos": {
                "line": 188,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x + y), sq_nonneg (x - y), sq_nonneg (x + y - 2)]",
            "proofState": 96,
            "pos": {
                "line": 189,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) x \u2264 (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) y",
            "endPos": {
                "line": 189,
                "column": 73
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 97,
            "pos": {
                "line": 192,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) (Icc 0 6)",
            "endPos": {
                "line": 192,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hx' : 0 \u2264 x := by\n  cases' hx with hx\u2081 hx\u2082\n  linarith",
            "proofState": 98,
            "pos": {
                "line": 193,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\n\u22a2 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) x \u2264 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) y",
            "endPos": {
                "line": 195,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Membership.mem",
                "instOfNatNat",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "Eq.refl",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "cases' hx with hx\u2081 hx\u2082",
            "proofState": 99,
            "pos": {
                "line": 194,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 194,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "linarith",
            "proofState": 100,
            "pos": {
                "line": 195,
                "column": 4
            },
            "goals": "case intro\nx y : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\nhx\u2081 : 0 \u2264 x\nhx\u2082 : x \u2264 6\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 195,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hy' : 0 \u2264 y := by\n  cases' hy with hy\u2081 hy\u2082\n  linarith",
            "proofState": 101,
            "pos": {
                "line": 196,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) x \u2264 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) y",
            "endPos": {
                "line": 198,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Membership.mem",
                "instOfNatNat",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "Eq.refl",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "cases' hy with hy\u2081 hy\u2082",
            "proofState": 102,
            "pos": {
                "line": 197,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 0 \u2264 y",
            "endPos": {
                "line": 197,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "linarith",
            "proofState": 103,
            "pos": {
                "line": 198,
                "column": 4
            },
            "goals": "case intro\nx : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy\u2081 : 0 \u2264 y\nhy\u2082 : y \u2264 6\n\u22a2 0 \u2264 y",
            "endPos": {
                "line": 198,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Real.instSub",
                "HSub.hSub",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instHSub",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hxy' : 0 \u2264 y - x := by linarith",
            "proofState": 104,
            "pos": {
                "line": 199,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) x \u2264 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) y",
            "endPos": {
                "line": 199,
                "column": 38
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "linarith",
            "proofState": 105,
            "pos": {
                "line": 199,
                "column": 30
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 0 \u2264 y - x",
            "endPos": {
                "line": 199,
                "column": 38
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_assoc, mul_one, mul_add, mul_comm, mul_left_comm]",
            "proofState": 106,
            "pos": {
                "line": 200,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : 0 \u2264 y - x\n\u22a2 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) x \u2264 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) y",
            "endPos": {
                "line": 200,
                "column": 66
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3), sq_nonneg (x ^ 2), sq_nonneg x, sq_nonneg (y ^ 3), sq_nonneg (y ^ 2), sq_nonneg y,\n  sq_nonneg (x - y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 107,
            "pos": {
                "line": 201,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : 0 \u2264 y - x\n\u22a2 x ^ 6 * 8 + x ^ 5 * 11 + x * 19 + 10 \u2264 y ^ 6 * 8 + y ^ 5 * 11 + y * 19 + 10",
            "endPos": {
                "line": 201,
                "column": 187
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 108,
            "pos": {
                "line": 204,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) (Icc 0 8)",
            "endPos": {
                "line": 204,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have hx' := hx",
            "proofState": 109,
            "pos": {
                "line": 205,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nhxy : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) x \u2264\n    (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) y",
            "endPos": {
                "line": 205,
                "column": 16
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have hy' := hy",
            "proofState": 110,
            "pos": {
                "line": 206,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nhxy : x \u2264 y\nhx' : x \u2208 Icc 0 8\n\u22a2 (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) x \u2264\n    (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) y",
            "endPos": {
                "line": 206,
                "column": 16
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp_all only [Set.mem_Icc, Set.mem_Icc]",
            "proofState": 111,
            "pos": {
                "line": 207,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nhxy : x \u2264 y\nhx' : x \u2208 Icc 0 8\nhy' : y \u2208 Icc 0 8\n\u22a2 (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) x \u2264\n    (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) y",
            "endPos": {
                "line": 207,
                "column": 42
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 112,
            "pos": {
                "line": 208,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx' : 0 \u2264 x \u2227 x \u2264 8\nhy' : 0 \u2264 y \u2227 y \u2264 8\n\u22a2 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x \u2264 15 * y ^ 6 + 18 * y ^ 5 + 9 * y ^ 3 + 4 * y ^ 2 + 3 * y",
            "endPos": {
                "line": 208,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Set.Icc_subset_Icc_right",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_right (by norm_num))",
            "proofState": 113,
            "pos": {
                "line": 211,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 19 * x ^ 6 + 7 * x ^ 5 + 12 * x ^ 4 + 18) (Icc 0 5)",
            "endPos": {
                "line": 211,
                "column": 62
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 114,
            "pos": {
                "line": 211,
                "column": 52
            },
            "goals": "\u22a2 5 \u2264 ?m.357800",
            "endPos": {
                "line": 211,
                "column": 60
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact\n  MonotoneOn.add\n    (MonotoneOn.add\n      (MonotoneOn.add\n        (MonotoneOn.add (by exact (monotone_id.const_mul (by norm_num)).monotoneOn)\n          (by exact (monotone_id.const_mul (by norm_num)).monotoneOn))\n        (by exact (monotone_id.const_mul (by norm_num)).monotoneOn))\n      (by exact (monotone_id.const_mul (by norm_num)).monotoneOn))\n    (by exact (monotone_id.const_mul (by norm_num)).monotoneOn)",
            "proofState": 115,
            "pos": {
                "line": 212,
                "column": 2
            },
            "goals": "\u22a2 \u211d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 19 * x ^ 6 + 7 * x ^ 5 + 12 * x ^ 4 + 18) (Icc 0 ?m.357800)",
            "endPos": {
                "line": 219,
                "column": 65
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 116,
            "pos": {
                "line": 215,
                "column": 44
            },
            "goals": "\u22a2 MonotoneOn ?m.360885 ?m.360887",
            "endPos": {
                "line": 215,
                "column": 98
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 117,
            "pos": {
                "line": 215,
                "column": 77
            },
            "goals": "\u22a2 0 \u2264 ?m.372914",
            "endPos": {
                "line": 215,
                "column": 85
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 118,
            "pos": {
                "line": 216,
                "column": 14
            },
            "goals": "\u22a2 MonotoneOn ?m.360886 ?m.360887",
            "endPos": {
                "line": 216,
                "column": 68
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 119,
            "pos": {
                "line": 216,
                "column": 47
            },
            "goals": "\u22a2 0 \u2264 ?m.388017",
            "endPos": {
                "line": 216,
                "column": 55
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 120,
            "pos": {
                "line": 217,
                "column": 14
            },
            "goals": "\u22a2 MonotoneOn ?m.360305 ?m.360887",
            "endPos": {
                "line": 217,
                "column": 68
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 121,
            "pos": {
                "line": 217,
                "column": 47
            },
            "goals": "\u22a2 0 \u2264 ?m.403660",
            "endPos": {
                "line": 217,
                "column": 55
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 122,
            "pos": {
                "line": 218,
                "column": 12
            },
            "goals": "\u22a2 MonotoneOn ?m.359724 ?m.360887",
            "endPos": {
                "line": 218,
                "column": 66
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 123,
            "pos": {
                "line": 218,
                "column": 45
            },
            "goals": "\u22a2 0 \u2264 ?m.419303",
            "endPos": {
                "line": 218,
                "column": 53
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 124,
            "pos": {
                "line": 219,
                "column": 10
            },
            "goals": "\u22a2 MonotoneOn ?m.359156 ?m.360887",
            "endPos": {
                "line": 219,
                "column": 64
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 125,
            "pos": {
                "line": 219,
                "column": 43
            },
            "goals": "\u22a2 0 \u2264 ?m.434946",
            "endPos": {
                "line": 219,
                "column": 51
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instOne",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "One.toOfNat1",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ Icc_subset_Icc_right",
            "proofState": 126,
            "pos": {
                "line": 222,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 6 + 11 * x ^ 5 + 17 * x ^ 4 + 5 * x ^ 3 + 18 * x ^ 2 + 13 * x) (Icc 0 1)",
            "endPos": {
                "line": 222,
                "column": 46
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact fun x hx y hy h => by\n  simp only [Set.mem_Icc] at hx hy\n  nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 127,
            "pos": {
                "line": 223,
                "column": 2
            },
            "goals": "\u22a2 Set \u211d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 6 + 11 * x ^ 5 + 17 * x ^ 4 + 5 * x ^ 3 + 18 * x ^ 2 + 13 * x) ?m.467659",
            "endPos": {
                "line": 225,
                "column": 87
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 128,
            "pos": {
                "line": 224,
                "column": 4
            },
            "goals": "x : \u211d\nhx : ?m.469104 x\ny : ?m.469105 x hx\nhy : ?m.469106 x hx y\nh : ?m.469107 x hx y hy\n\u22a2 ?m.469108 x hx y hy h",
            "endPos": {
                "line": 224,
                "column": 36
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 129,
            "pos": {
                "line": 228,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) (Icc 0 4)",
            "endPos": {
                "line": 228,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 130,
            "pos": {
                "line": 229,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 4\ny : \u211d\nhy : y \u2208 Icc 0 4\nh : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) x \u2264\n    (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) y",
            "endPos": {
                "line": 230,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 131,
            "pos": {
                "line": 233,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 18 * x ^ 6 + 4 * x ^ 5 + 20 * x ^ 4 + 11 * x ^ 3 + 2 * x ^ 2 + 9 * x + 7) (Icc 0 3)",
            "endPos": {
                "line": 233,
                "column": 49
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "exact fun x hx y hy h => by\n  simp only [mul_comm, mul_left_comm, mul_assoc] at h\n  nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 + y ^ 2),\n    sq_nonneg (x ^ 2 - 3 * y ^ 2), sq_nonneg (x ^ 2 + 3 * y ^ 2), sq_nonneg (2 * x ^ 2 - y ^ 2),\n    sq_nonneg (2 * x ^ 2 + y ^ 2)]",
            "proofState": 132,
            "pos": {
                "line": 234,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 18 * x ^ 6 + 4 * x ^ 5 + 20 * x ^ 4 + 11 * x ^ 3 + 2 * x ^ 2 + 9 * x + 7) (Ici 0)",
            "endPos": {
                "line": 238,
                "column": 67
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mul_comm, mul_left_comm, mul_assoc] at h",
            "proofState": 133,
            "pos": {
                "line": 235,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nh : x \u2264 y\n\u22a2 18 * x ^ 6 + 4 * x ^ 5 + 20 * x ^ 4 + 11 * x ^ 3 + 2 * x ^ 2 + 9 * x + 7 \u2264\n    18 * y ^ 6 + 4 * y ^ 5 + 20 * y ^ 4 + 11 * y ^ 3 + 2 * y ^ 2 + 9 * y + 7",
            "endPos": {
                "line": 235,
                "column": 55
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "sorryAx",
                "Monoid.toNatPow",
                "Set.Icc_subset_Icc_left",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 134,
            "pos": {
                "line": 241,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 10 * x ^ 6 + 20 * x ^ 5 + 8 * x ^ 3 + 15 * x ^ 2 + 19 * x) (Icc 0 3)",
            "endPos": {
                "line": 241,
                "column": 63
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 135,
            "pos": {
                "line": 241,
                "column": 53
            },
            "goals": "\u22a2 ?m.502342 \u2264 0",
            "endPos": {
                "line": 241,
                "column": 61
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 136,
            "pos": {
                "line": 242,
                "column": 2
            },
            "goals": "case refine'_1\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 10 * x ^ 6 + 20 * x ^ 5 + 8 * x ^ 3 + 15 * x ^ 2 + 19 * x) (Icc ?refine'_2 3)\ncase refine'_2\n\u22a2 \u211d",
            "endPos": {
                "line": 242,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "Real",
                "HMul.hMul",
                "add_left_comm",
                "congrArg",
                "add_assoc",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAddCommSemigroup",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "AddSemigroup.toAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "congr",
                "AddCommSemigroup.toAddCommMagma",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Eq.trans",
                "AddCommMagma.toAdd",
                "instHMul",
                "Real.instAddSemigroup",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_assoc, mul_one, mul_zero, add_assoc, add_zero, add_left_comm] at hxy \u22a2",
            "proofState": 137,
            "pos": {
                "line": 243,
                "column": 2
            },
            "goals": "case refine'_1\nx : \u211d\nhx : x \u2208 Icc ?refine'_2 3\ny : \u211d\nhy : y \u2208 Icc ?refine'_2 3\nhxy : x \u2264 y\n\u22a2 (fun x => 4 * x ^ 7 + 10 * x ^ 6 + 20 * x ^ 5 + 8 * x ^ 3 + 15 * x ^ 2 + 19 * x) x \u2264\n    (fun x => 4 * x ^ 7 + 10 * x ^ 6 + 20 * x ^ 5 + 8 * x ^ 3 + 15 * x ^ 2 + 19 * x) y\ncase refine'_2\n\u22a2 \u211d",
            "endPos": {
                "line": 243,
                "column": 87
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x + y),\n  sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (x ^ 3 - x ^ 2), sq_nonneg (y ^ 3 - y ^ 2)]",
            "proofState": 138,
            "pos": {
                "line": 244,
                "column": 2
            },
            "goals": "case refine'_1\nx : \u211d\nhx : x \u2208 Icc ?refine'_2 3\ny : \u211d\nhy : y \u2208 Icc ?refine'_2 3\nhxy : x \u2264 y\n\u22a2 4 * x ^ 7 + (8 * x ^ 3 + (10 * x ^ 6 + (15 * x ^ 2 + (20 * x ^ 5 + 19 * x)))) \u2264\n    4 * y ^ 7 + (8 * y ^ 3 + (10 * y ^ 6 + (15 * y ^ 2 + (20 * y ^ 5 + 19 * y))))\ncase refine'_2\n\u22a2 \u211d",
            "endPos": {
                "line": 251,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 139,
            "pos": {
                "line": 254,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x + 13) (Icc 0 3)",
            "endPos": {
                "line": 254,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "Real.partialOrder",
                "Real",
                "Preorder.toLT",
                "HMul.hMul",
                "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
                "covariant_swap_add_of_covariant_add",
                "PartialOrder.toPreorder",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "contravariant_lt_of_covariant_le",
                "LE.le",
                "Real.instAddCommSemigroup",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_4",
                "Nat",
                "Real.instMul",
                "LT.lt",
                "Real.instAddCommMonoid",
                "contravariant_swap_add_of_contravariant_add",
                "AddCommSemigroup.toAddCommMagma",
                "instHPow",
                "Real.instIsOrderedAddMonoid",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "IsOrderedCancelAddMonoid.toIsCancelAdd",
                "IsCancelAdd.toIsRightCancelAdd",
                "Real.instPreorder",
                "Real.linearOrder",
                "AddCommMagma.toAdd",
                "IsOrderedAddMonoid.toAddLeftMono",
                "instHMul",
                "Real.instNatCast",
                "Real.instIsOrderedCancelAddMonoid"
            ],
            "tactic": "norm_num",
            "proofState": 140,
            "pos": {
                "line": 255,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nh : x \u2264 y\n\u22a2 (fun x => 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x + 13) x \u2264\n    (fun x => 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x + 13) y",
            "endPos": {
                "line": 255,
                "column": 10
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + 13 * x ^ 2), sq_nonneg (y ^ 3 + 13 * y ^ 2)]",
            "proofState": 141,
            "pos": {
                "line": 256,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nh : x \u2264 y\n\u22a2 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x \u2264 8 * y ^ 7 + 17 * y ^ 6 + 10 * y ^ 2 + 12 * y",
            "endPos": {
                "line": 256,
                "column": 76
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 142,
            "pos": {
                "line": 259,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 8 * x + 14) (Icc 0 7)",
            "endPos": {
                "line": 259,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp_all only [Icc_subset_Icc_iff, le_of_lt]",
            "proofState": 143,
            "pos": {
                "line": 260,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\n\u22a2 (fun x => 11 * x ^ 7 + 8 * x + 14) x \u2264 (fun x => 11 * x ^ 7 + 8 * x + 14) y",
            "endPos": {
                "line": 260,
                "column": 46
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "Real",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Real.instAddMonoid",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "AddGroupWithOne.toAddMonoidWithOne",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "Real.instRing",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "Real.instAdd",
                "AddMonoidWithOne.toOne",
                "Real.instMonoid",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Real.instMul",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Real.instCommSemiring",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "ring_nf",
            "proofState": 144,
            "pos": {
                "line": 261,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\n\u22a2 11 * x ^ 7 + 8 * x + 14 \u2264 11 * y ^ 7 + 8 * y + 14",
            "endPos": {
                "line": 261,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), hx.1, hx.2, hy.1, hy.2]",
            "proofState": 145,
            "pos": {
                "line": 262,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\n\u22a2 14 + x * 8 + x ^ 7 * 11 \u2264 14 + y * 8 + y ^ 7 * 11",
            "endPos": {
                "line": 262,
                "column": 74
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 146,
            "pos": {
                "line": 265,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 6 * x ^ 4 + 20 * x ^ 3 + 5 * x ^ 2 + 19 * x) (Icc 0 3)",
            "endPos": {
                "line": 265,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 147,
            "pos": {
                "line": 266,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 6 * x ^ 4 + 20 * x ^ 3 + 5 * x ^ 2 + 19 * x) (Ici 0)",
            "endPos": {
                "line": 266,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 2 + 5 * x), sq_nonneg (y ^ 2 + 5 * y), sq_nonneg (x + y), sq_nonneg (x ^ 2 + y ^ 2), hxy]",
            "proofState": 148,
            "pos": {
                "line": 267,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 6 * x ^ 4 + 20 * x ^ 3 + 5 * x ^ 2 + 19 * x) x \u2264 (fun x => 6 * x ^ 4 + 20 * x ^ 3 + 5 * x ^ 2 + 19 * x) y",
            "endPos": {
                "line": 268,
                "column": 54
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _",
            "proofState": 149,
            "pos": {
                "line": 271,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 15 * x ^ 6 + 8 * x ^ 5 + 2 * x ^ 4 + 7 * x ^ 2 + 18 * x + 13) (Icc 0 4)",
            "endPos": {
                "line": 271,
                "column": 25
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx",
            "proofState": 150,
            "pos": {
                "line": 272,
                "column": 4
            },
            "goals": "\u22a2 Icc 0 4 \u2286 ?m.565091",
            "endPos": {
                "line": 272,
                "column": 14
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp_all only [Set.mem_Icc, le_refl, true_and_iff, zero_le_four]",
            "proofState": 151,
            "pos": {
                "line": 273,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 4\n\u22a2 x \u2208 ?m.565091",
            "endPos": {
                "line": 273,
                "column": 68
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 152,
            "pos": {
                "line": 274,
                "column": 4
            },
            "goals": "x : \u211d\nhx : 0 \u2264 x \u2227 x \u2264 4\n\u22a2 x \u2208 ?m.565091",
            "endPos": {
                "line": 274,
                "column": 12
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg x, sq_nonneg (x ^ 2), sq_nonneg (x ^ 3), sq_nonneg (x ^ 4), sq_nonneg (x ^ 5), sq_nonneg (x ^ 6),\n  sq_nonneg (x ^ 7)]",
            "proofState": 153,
            "pos": {
                "line": 275,
                "column": 4
            },
            "goals": "x : \u211d\nhx : 0 \u2264 x \u2227 x \u2264 4\n\u22a2 x \u2208 ?m.565091",
            "endPos": {
                "line": 275,
                "column": 141
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.add",
            "proofState": 154,
            "pos": {
                "line": 276,
                "column": 2
            },
            "goals": "\u22a2 Set \u211d\n\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 15 * x ^ 6 + 8 * x ^ 5 + 2 * x ^ 4 + 7 * x ^ 2 + 18 * x + 13) ?m.565091",
            "endPos": {
                "line": 276,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Membership.mem",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono (fun x hx => ?_)",
            "proofState": 155,
            "pos": {
                "line": 306,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x) (Icc 0 5)",
            "endPos": {
                "line": 306,
                "column": 40
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "Real.instZero",
                "sorryAx",
                "HasSubset.Subset",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "Set.instHasSubset",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have h\u2080 : 0 \u2264 x := by linarith [hx.1]",
            "proofState": 156,
            "pos": {
                "line": 307,
                "column": 2
            },
            "goals": "\u22a2 Icc 0 5 \u2286 ?m.577886\n\u22a2 Set \u211d\nx : \u211d\nhx : x \u2208 ?m.577886\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?m.577886 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 307,
                "column": 39
            }
        },
        {
            "usedConstants": [],
            "tactic": "linarith [hx.1]",
            "proofState": 157,
            "pos": {
                "line": 307,
                "column": 24
            },
            "goals": "\u22a2 0 \u2264 sorry",
            "endPos": {
                "line": 307,
                "column": 39
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "HasSubset.Subset",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "Set.instHasSubset",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have h\u2081 : 0 \u2264 5 := by linarith [hx.2]",
            "proofState": 158,
            "pos": {
                "line": 308,
                "column": 2
            },
            "goals": "h\u2080 : 0 \u2264 sorry\n\u22a2 Icc 0 5 \u2286 ?m.577886\n\u22a2 Set \u211d\nx : \u211d\nhx : x \u2208 ?m.577886\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?m.577886 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 308,
                "column": 39
            }
        },
        {
            "usedConstants": [],
            "tactic": "linarith [hx.2]",
            "proofState": 159,
            "pos": {
                "line": 308,
                "column": 24
            },
            "goals": "h\u2080 : 0 \u2264 sorry\n\u22a2 0 \u2264 5",
            "endPos": {
                "line": 308,
                "column": 39
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "Set.instHasSubset",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have h\u2082 : 0 \u2264 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x := by\n  nlinarith [sq_nonneg (3 * x ^ 3 + x), sq_nonneg (3 * x ^ 2), sq_nonneg x, sq_nonneg 1]",
            "proofState": 160,
            "pos": {
                "line": 309,
                "column": 2
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\n\u22a2 Icc 0 5 \u2286 ?m.577886\n\u22a2 Set \u211d\nx : \u211d\nhx : x \u2208 ?m.577886\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?m.577886 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 310,
                "column": 90
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (3 * x ^ 3 + x), sq_nonneg (3 * x ^ 2), sq_nonneg x, sq_nonneg 1]",
            "proofState": 161,
            "pos": {
                "line": 310,
                "column": 4
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\n\u22a2 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry",
            "endPos": {
                "line": 310,
                "column": 90
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Nat.instMonoid",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "instAddNat",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "Set.instHasSubset",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have h\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5 := by\n  nlinarith [sq_nonneg (3 * 5 ^ 3 + 5), sq_nonneg (3 * 5 ^ 2), sq_nonneg 5, sq_nonneg 1]",
            "proofState": 162,
            "pos": {
                "line": 311,
                "column": 2
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\n\u22a2 Icc 0 5 \u2286 ?m.577886\n\u22a2 Set \u211d\nx : \u211d\nhx : x \u2208 ?m.577886\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?m.577886 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 312,
                "column": 90
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith [sq_nonneg (3 * 5 ^ 3 + 5), sq_nonneg (3 * 5 ^ 2), sq_nonneg 5, sq_nonneg 1]",
            "proofState": 163,
            "pos": {
                "line": 312,
                "column": 4
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\n\u22a2 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5",
            "endPos": {
                "line": 312,
                "column": 90
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "instHDiv",
                "HMul.hMul",
                "Real.instZero",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HDiv.hDiv",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Nat.instDiv",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "Set.instHasSubset",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have h\u2084 : 0 \u2264 (9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x) / 7 := by positivity",
            "proofState": 164,
            "pos": {
                "line": 313,
                "column": 2
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\n\u22a2 Icc 0 5 \u2286 ?m.577886\n\u22a2 Set \u211d\nx : \u211d\nhx : x \u2208 ?m.577886\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?m.577886 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 313,
                "column": 81
            }
        },
        {
            "usedConstants": [
                "zero_le",
                "Unit.unit",
                "Nat.instCanonicallyOrderedAdd",
                "instHDiv",
                "HMul.hMul",
                "Nat.instMonoid",
                "AddMonoid.toAddZeroClass",
                "PartialOrder.toPreorder",
                "Preorder.toLE",
                "Nat.instAddMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HDiv.hDiv",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Nat.instDiv",
                "Nat.instPartialOrder",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "positivity",
            "proofState": 165,
            "pos": {
                "line": 313,
                "column": 71
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\n\u22a2 0 \u2264 (9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry) / 7",
            "endPos": {
                "line": 313,
                "column": 81
            }
        },
        {
            "usedConstants": [
                "Real",
                "instHDiv",
                "HMul.hMul",
                "Real.instZero",
                "Nat.instMonoid",
                "Monoid.toNatPow",
                "HDiv.hDiv",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Nat.instDiv",
                "instAddNat",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "Set.instHasSubset",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have h\u2085 : 0 \u2264 (9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5) / 7 := by positivity",
            "proofState": 166,
            "pos": {
                "line": 314,
                "column": 2
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\nh\u2084 : 0 \u2264 (9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry) / 7\n\u22a2 Icc 0 5 \u2286 ?m.577886\n\u22a2 Set \u211d\nx : \u211d\nhx : x \u2208 ?m.577886\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?m.577886 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 314,
                "column": 81
            }
        },
        {
            "usedConstants": [
                "Nat.instMulZeroClass",
                "Mathlib.Meta.NormNum.isNat_add",
                "instHDiv",
                "HMul.hMul",
                "Nat.ble",
                "Nat.instNontrivial",
                "Mathlib.Meta.NormNum.IsNatPowT.run",
                "Nat.instMonoid",
                "PartialOrder.toPreorder",
                "le_of_lt",
                "Monoid.toNatPow",
                "HDiv.hDiv",
                "Nat.instStarOrderedRing",
                "Mathlib.Meta.NormNum.IsNatPowT.bit1",
                "Nat.instStarRing",
                "Mathlib.Meta.NormNum.IsNatPowT.bit0",
                "instMulNat",
                "instOfNatNat",
                "Mathlib.Meta.NormNum.IsNatPowT.trans",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "Nat.instAddMonoidWithOne",
                "instHAdd",
                "HPow.hPow",
                "Mathlib.Meta.Positivity.pos_of_isNat",
                "HAdd.hAdd",
                "Nat",
                "Mathlib.Meta.NormNum.isNat_natDiv",
                "Nat.instCommSemiring",
                "Nat.instDiv",
                "Nat.pow",
                "Nat.instPartialOrder",
                "StarOrderedRing.toIsOrderedRing",
                "Bool",
                "Mathlib.Meta.NormNum.isNat_mul",
                "instAddNat",
                "Nat.instSemiring",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Mathlib.Meta.NormNum.isNat_pow",
                "MulZeroClass.toZero",
                "instHMul"
            ],
            "tactic": "positivity",
            "proofState": 167,
            "pos": {
                "line": 314,
                "column": 71
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\nh\u2084 : 0 \u2264 (9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry) / 7\n\u22a2 0 \u2264 (9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5) / 7",
            "endPos": {
                "line": 314,
                "column": 81
            }
        },
        {
            "usedConstants": [],
            "tactic": "linarith [sq_nonneg (3 * x ^ 3 + x), sq_nonneg (3 * x ^ 2), sq_nonneg x, sq_nonneg 1]",
            "proofState": 168,
            "pos": {
                "line": 315,
                "column": 2
            },
            "goals": "h\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\nh\u2084 : 0 \u2264 (9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry) / 7\nh\u2085 : 0 \u2264 (9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5) / 7\n\u22a2 Icc 0 5 \u2286 ?m.577886\n\u22a2 Set \u211d\nx : \u211d\nhx : x \u2208 ?m.577886\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?m.577886 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 315,
                "column": 87
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 169,
            "pos": {
                "line": 318,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) (Icc 0 5)",
            "endPos": {
                "line": 318,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 170,
            "pos": {
                "line": 319,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) (Ici 0)",
            "endPos": {
                "line": 319,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hx' : 0 \u2264 x := by exact hx.1",
            "proofState": 171,
            "pos": {
                "line": 320,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) x \u2264 (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) y",
            "endPos": {
                "line": 320,
                "column": 35
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real.instLE",
                "Real",
                "Real.instZero",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "OfNat.ofNat"
            ],
            "tactic": "exact hx.1",
            "proofState": 172,
            "pos": {
                "line": 320,
                "column": 25
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 320,
                "column": 35
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hy' : 0 \u2264 y := by exact hy.1",
            "proofState": 173,
            "pos": {
                "line": 321,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) x \u2264 (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) y",
            "endPos": {
                "line": 321,
                "column": 35
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real.instLE",
                "Real",
                "Real.instZero",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "OfNat.ofNat"
            ],
            "tactic": "exact hy.1",
            "proofState": 174,
            "pos": {
                "line": 321,
                "column": 25
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 0 \u2264 y",
            "endPos": {
                "line": 321,
                "column": 35
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 2 + y ^ 2), sq_nonneg (x + y), sq_nonneg (x - y), sq_nonneg (x ^ 2 - y ^ 2),\n  sq_nonneg (2 * x), sq_nonneg (2 * y)]",
            "proofState": 175,
            "pos": {
                "line": 322,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) x \u2264 (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) y",
            "endPos": {
                "line": 323,
                "column": 68
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 176,
            "pos": {
                "line": 326,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 3 * x ^ 6 + 14 * x ^ 5 + 14 * x ^ 4) (Icc 0 5)",
            "endPos": {
                "line": 326,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 177,
            "pos": {
                "line": 327,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 3 * x ^ 6 + 14 * x ^ 5 + 14 * x ^ 4) (Ici 0)",
            "endPos": {
                "line": 327,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 178,
            "pos": {
                "line": 328,
                "column": 2
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 3 * x ^ 6 + 14 * x ^ 5) (Ici 0)\ncase hg\n\u22a2 MonotoneOn (fun x => 14 * x ^ 4) (Ici 0)",
            "endPos": {
                "line": 328,
                "column": 28
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "Unit",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "MonotoneOn",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.pow",
            "proofState": 179,
            "pos": {
                "line": 329,
                "column": 2
            },
            "goals": "case hg\n\u22a2 MonotoneOn (fun x => 14 * x ^ 4) (Ici 0)",
            "endPos": {
                "line": 329,
                "column": 22
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact monotoneOn_id",
            "proofState": 180,
            "pos": {
                "line": 330,
                "column": 2
            },
            "goals": "no goals",
            "endPos": {
                "line": 330,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _",
            "proofState": 181,
            "pos": {
                "line": 339,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 6 * x ^ 5 + 3 * x ^ 4 + 6 * x ^ 3 + 16 * x + 14) (Icc 0 4)",
            "endPos": {
                "line": 339,
                "column": 25
            }
        },
        {
            "usedConstants": [
                "Real",
                "instOfNatNat",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast"
            ],
            "tactic": "exact Icc_subset_Icc_left (by norm_num)",
            "proofState": 182,
            "pos": {
                "line": 340,
                "column": 2
            },
            "goals": "\u22a2 Icc 0 4 \u2286 ?m.689531\n\u22a2 Set \u211d\n\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 6 * x ^ 5 + 3 * x ^ 4 + 6 * x ^ 3 + 16 * x + 14) ?m.689531",
            "endPos": {
                "line": 340,
                "column": 41
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 183,
            "pos": {
                "line": 340,
                "column": 32
            },
            "goals": "\u22a2 ?m.689882 \u2264 0",
            "endPos": {
                "line": 340,
                "column": 40
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 184,
            "pos": {
                "line": 346,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 15 * x ^ 6 + 20 * x ^ 5 + 17 * x ^ 4 + 4 * x ^ 2) (Icc 0 8)",
            "endPos": {
                "line": 346,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 185,
            "pos": {
                "line": 347,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 15 * x ^ 6 + 20 * x ^ 5 + 17 * x ^ 4 + 4 * x ^ 2) (Ici 0)",
            "endPos": {
                "line": 347,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2 * y + y ^ 2 * x + y ^ 3)]",
            "proofState": 186,
            "pos": {
                "line": 348,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nh : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 7 + 15 * x ^ 6 + 20 * x ^ 5 + 17 * x ^ 4 + 4 * x ^ 2) x \u2264\n    (fun x => 12 * x ^ 7 + 15 * x ^ 6 + 20 * x ^ 5 + 17 * x ^ 4 + 4 * x ^ 2) y",
            "endPos": {
                "line": 348,
                "column": 63
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 187,
            "pos": {
                "line": 355,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 10 * x ^ 5 + 3 * x ^ 3 + 6 * x ^ 2 + 17 * x + 6) (Icc 0 1)",
            "endPos": {
                "line": 355,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "LE.le",
                "Real.instOne",
                "And",
                "Set.Icc",
                "One.toOfNat1",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "Real.instPreorder",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 188,
            "pos": {
                "line": 356,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nhxy : x \u2264 y\n\u22a2 (fun x => 10 * x ^ 5 + 3 * x ^ 3 + 6 * x ^ 2 + 17 * x + 6) x \u2264\n    (fun x => 10 * x ^ 5 + 3 * x ^ 3 + 6 * x ^ 2 + 17 * x + 6) y",
            "endPos": {
                "line": 356,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hxy",
            "proofState": 189,
            "pos": {
                "line": 357,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 1\nhy : 0 \u2264 y \u2227 y \u2264 1\n\u22a2 (fun x => 10 * x ^ 5 + 3 * x ^ 3 + 6 * x ^ 2 + 17 * x + 6) x \u2264\n    (fun x => 10 * x ^ 5 + 3 * x ^ 3 + 6 * x ^ 2 + 17 * x + 6) y",
            "endPos": {
                "line": 357,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "Set.Icc_subset_Icc_left",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono (fun x hx y hy hxy => ?_) (Set.Icc_subset_Icc_left (by norm_num))",
            "proofState": 190,
            "pos": {
                "line": 361,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 11 * x ^ 5 + 17 * x ^ 4 + 9 * x ^ 3 + 12 * x + 18) (Icc 0 5)",
            "endPos": {
                "line": 361,
                "column": 89
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 191,
            "pos": {
                "line": 361,
                "column": 79
            },
            "goals": "\u22a2 ?m.715333 \u2264 0",
            "endPos": {
                "line": 361,
                "column": 87
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x ^ 3 - x ^ 2 * y),\n  sq_nonneg (x ^ 2 * y - x * y ^ 2), sq_nonneg (x * y ^ 2 - y ^ 3)]",
            "proofState": 192,
            "pos": {
                "line": 362,
                "column": 2
            },
            "goals": "\u22a2 \u211d\nx : \u211d\nhx : x \u2208 Icc ?m.715333 5\ny : \u211d\nhy : y \u2208 Icc ?m.715333 5\nhxy : x \u2264 y\n\u22a2 20 * x ^ 7 + 11 * x ^ 5 + 17 * x ^ 4 + 9 * x ^ 3 + 12 * x + 18 \u2264\n    20 * y ^ 7 + 11 * y ^ 5 + 17 * y ^ 4 + 9 * y ^ 3 + 12 * y + 18",
            "endPos": {
                "line": 363,
                "column": 100
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ Icc_subset_Icc_left",
            "proofState": 193,
            "pos": {
                "line": 366,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 9 * x ^ 6 + 3 * x ^ 4 + 8 * x ^ 3 + 12 * x ^ 2 + 18 * x) (Icc 0 6)",
            "endPos": {
                "line": 366,
                "column": 45
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 194,
            "pos": {
                "line": 367,
                "column": 2
            },
            "goals": "\u22a2 Set \u211d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 9 * x ^ 6 + 3 * x ^ 4 + 8 * x ^ 3 + 12 * x ^ 2 + 18 * x) ?m.725384",
            "endPos": {
                "line": 367,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 195,
            "pos": {
                "line": 378,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 12 * x ^ 6 + 14 * x ^ 5 + 13 * x ^ 4 + 18 * x ^ 3 + 5 * x ^ 2 + 18 * x) (Icc 0 5)",
            "endPos": {
                "line": 378,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 196,
            "pos": {
                "line": 379,
                "column": 6
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 12 * x ^ 6 + 14 * x ^ 5 + 13 * x ^ 4 + 18 * x ^ 3 + 5 * x ^ 2) (Icc 0 5)",
            "endPos": {
                "line": 379,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "MonotoneOn",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 197,
            "pos": {
                "line": 379,
                "column": 6
            },
            "goals": "case hg\n\u22a2 MonotoneOn (HMul.hMul 18) (Icc 0 5)",
            "endPos": {
                "line": 379,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 198,
            "pos": {
                "line": 386,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) (Icc 0 10)",
            "endPos": {
                "line": 386,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 199,
            "pos": {
                "line": 387,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 10\ny : \u211d\nhy : y \u2208 Icc 0 10\nhxy : x \u2264 y\n\u22a2 (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x \u2264\n    (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y",
            "endPos": {
                "line": 387,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "le_of_not_lt"
            ],
            "tactic": "apply le_of_not_lt",
            "proofState": 200,
            "pos": {
                "line": 388,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\n\u22a2 (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x \u2264\n    (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y",
            "endPos": {
                "line": 388,
                "column": 20
            }
        },
        {
            "usedConstants": [
                "Real",
                "Preorder.toLT",
                "HMul.hMul",
                "PartialOrder.toPreorder",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "LT.lt",
                "instHPow",
                "OfNat.ofNat",
                "LinearOrder.toPartialOrder",
                "instOfNatAtLeastTwo",
                "Real.linearOrder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "intro h",
            "proofState": 201,
            "pos": {
                "line": 389,
                "column": 2
            },
            "goals": "case h\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\n\u22a2 \u00ac(fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y <\n      (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x",
            "endPos": {
                "line": 389,
                "column": 9
            }
        },
        {
            "usedConstants": [
                "False",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Real.instLT",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "LT.lt",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have h\u2081 : 0 < 7 * x ^ 6 + 4 * x ^ 5 + 19 * x ^ 4 + 10 * x ^ 3 + 10 * x ^ 2 + 4 * x := by\n  nlinarith [pow_pos hx.1 6, pow_pos hx.1 5, pow_pos hx.1 4, pow_pos hx.1 3, pow_pos hx.1 2, h]",
            "proofState": 202,
            "pos": {
                "line": 390,
                "column": 2
            },
            "goals": "case h\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\nh :\n  (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y <\n    (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x\n\u22a2 False",
            "endPos": {
                "line": 391,
                "column": 97
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [pow_pos hx.1 6, pow_pos hx.1 5, pow_pos hx.1 4, pow_pos hx.1 3, pow_pos hx.1 2, h]",
            "proofState": 203,
            "pos": {
                "line": 391,
                "column": 4
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\nh :\n  (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y <\n    (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x\n\u22a2 0 < 7 * x ^ 6 + 4 * x ^ 5 + 19 * x ^ 4 + 10 * x ^ 3 + 10 * x ^ 2 + 4 * x",
            "endPos": {
                "line": 391,
                "column": 97
            }
        },
        {
            "usedConstants": [
                "False",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Real.instLT",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "LT.lt",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have h\u2082 : 0 < 7 * y ^ 6 + 4 * y ^ 5 + 19 * y ^ 4 + 10 * y ^ 3 + 10 * y ^ 2 + 4 * y := by\n  nlinarith [pow_pos hy.1 6, pow_pos hy.1 5, pow_pos hy.1 4, pow_pos hy.1 3, pow_pos hy.1 2, h]",
            "proofState": 204,
            "pos": {
                "line": 392,
                "column": 2
            },
            "goals": "case h\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\nh :\n  (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y <\n    (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x\nh\u2081 : 0 < 7 * x ^ 6 + 4 * x ^ 5 + 19 * x ^ 4 + 10 * x ^ 3 + 10 * x ^ 2 + 4 * x\n\u22a2 False",
            "endPos": {
                "line": 393,
                "column": 97
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [pow_pos hy.1 6, pow_pos hy.1 5, pow_pos hy.1 4, pow_pos hy.1 3, pow_pos hy.1 2, h]",
            "proofState": 205,
            "pos": {
                "line": 393,
                "column": 4
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\nh :\n  (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y <\n    (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x\nh\u2081 : 0 < 7 * x ^ 6 + 4 * x ^ 5 + 19 * x ^ 4 + 10 * x ^ 3 + 10 * x ^ 2 + 4 * x\n\u22a2 0 < 7 * y ^ 6 + 4 * y ^ 5 + 19 * y ^ 4 + 10 * y ^ 3 + 10 * y ^ 2 + 4 * y",
            "endPos": {
                "line": 393,
                "column": 97
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [mul_pos h\u2081 h\u2082, pow_pos hxy 6, pow_pos hxy 5, pow_pos hxy 4, pow_pos hxy 3, pow_pos hxy 2, h]",
            "proofState": 206,
            "pos": {
                "line": 394,
                "column": 2
            },
            "goals": "case h\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\nh :\n  (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y <\n    (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x\nh\u2081 : 0 < 7 * x ^ 6 + 4 * x ^ 5 + 19 * x ^ 4 + 10 * x ^ 3 + 10 * x ^ 2 + 4 * x\nh\u2082 : 0 < 7 * y ^ 6 + 4 * y ^ 5 + 19 * y ^ 4 + 10 * y ^ 3 + 10 * y ^ 2 + 4 * y\n\u22a2 False",
            "endPos": {
                "line": 394,
                "column": 105
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 207,
            "pos": {
                "line": 397,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 13 * x ^ 7 + 13 * x ^ 6 + 9 * x ^ 5 + 16 * x ^ 4 + 15 * x ^ 3 + 5 * x ^ 2) (Icc 0 3)",
            "endPos": {
                "line": 397,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 208,
            "pos": {
                "line": 398,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nhxy : x \u2264 y\n\u22a2 (fun x => 13 * x ^ 7 + 13 * x ^ 6 + 9 * x ^ 5 + 16 * x ^ 4 + 15 * x ^ 3 + 5 * x ^ 2) x \u2264\n    (fun x => 13 * x ^ 7 + 13 * x ^ 6 + 9 * x ^ 5 + 16 * x ^ 4 + 15 * x ^ 3 + 5 * x ^ 2) y",
            "endPos": {
                "line": 398,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_comm, mul_add, mul_one, mul_assoc, mul_left_comm]",
            "proofState": 209,
            "pos": {
                "line": 399,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 3\nhy : 0 \u2264 y \u2227 y \u2264 3\n\u22a2 (fun x => 13 * x ^ 7 + 13 * x ^ 6 + 9 * x ^ 5 + 16 * x ^ 4 + 15 * x ^ 3 + 5 * x ^ 2) x \u2264\n    (fun x => 13 * x ^ 7 + 13 * x ^ 6 + 9 * x ^ 5 + 16 * x ^ 4 + 15 * x ^ 3 + 5 * x ^ 2) y",
            "endPos": {
                "line": 399,
                "column": 66
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Real.instAddMonoid",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "AddGroupWithOne.toAddMonoidWithOne",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "Real.instRing",
                "CommMagma.toMul",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "Real.instAdd",
                "Real.instMonoid",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "Distrib.toMul",
                "HAdd.hAdd",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "NonUnitalNonAssocSemiring.toDistrib",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Real.instCommSemiring",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "ring_nf",
            "proofState": 210,
            "pos": {
                "line": 400,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 3\nhy : 0 \u2264 y \u2227 y \u2264 3\n\u22a2 x ^ 7 * 13 + x ^ 6 * 13 + x ^ 5 * 9 + x ^ 4 * 16 + x ^ 3 * 15 + x ^ 2 * 5 \u2264\n    y ^ 7 * 13 + y ^ 6 * 13 + y ^ 5 * 9 + y ^ 4 * 16 + y ^ 3 * 15 + y ^ 2 * 5",
            "endPos": {
                "line": 400,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 2 + x), sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (x ^ 2 + 1), sq_nonneg (x ^ 3 + x),\n  sq_nonneg (x ^ 2 + x), sq_nonneg (x ^ 3 + x), sq_nonneg (x ^ 2 + 1), sq_nonneg (x ^ 3 + x), sq_nonneg (x ^ 2 + x),\n  sq_nonneg (x ^ 3 + x), sq_nonneg (x ^ 2 + 1), sq_nonneg (x ^ 3 + x)]",
            "proofState": 211,
            "pos": {
                "line": 401,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 3\nhy : 0 \u2264 y \u2227 y \u2264 3\n\u22a2 x ^ 2 * 5 + x ^ 3 * 15 + x ^ 4 * 16 + x ^ 5 * 9 + x ^ 6 * 13 + x ^ 7 * 13 \u2264\n    y ^ 2 * 5 + y ^ 3 * 15 + y ^ 4 * 16 + y ^ 5 * 9 + y ^ 6 * 13 + y ^ 7 * 13",
            "endPos": {
                "line": 404,
                "column": 72
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 212,
            "pos": {
                "line": 407,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 5 + 15 * x ^ 3 + 20 * x ^ 2) (Icc 0 1)",
            "endPos": {
                "line": 407,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "add_assoc",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "AddSemigroup.toAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Eq.trans",
                "instHMul",
                "Real.instAddSemigroup",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_assoc, mul_one, mul_zero, add_assoc, add_right_comm, add_zero, mul_add, mul_comm, mul_left_comm] at h \u22a2",
            "proofState": 213,
            "pos": {
                "line": 408,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 5 + 15 * x ^ 3 + 20 * x ^ 2) x \u2264 (fun x => 5 * x ^ 5 + 15 * x ^ 3 + 20 * x ^ 2) y",
            "endPos": {
                "line": 408,
                "column": 120
            }
        },
        {
            "usedConstants": [],
            "tactic": "ring_nf at h \u22a2",
            "proofState": 214,
            "pos": {
                "line": 409,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\n\u22a2 x ^ 5 * 5 + (x ^ 3 * 15 + x ^ 2 * 20) \u2264 y ^ 5 * 5 + (y ^ 3 * 15 + y ^ 2 * 20)",
            "endPos": {
                "line": 409,
                "column": 16
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 215,
            "pos": {
                "line": 413,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 12 * x ^ 5 + 15 * x ^ 4 + 4 * x ^ 2 + 11 * x + 4) (Icc 0 5)",
            "endPos": {
                "line": 413,
                "column": 49
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 216,
            "pos": {
                "line": 414,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 12 * x ^ 5 + 15 * x ^ 4 + 4 * x ^ 2 + 11 * x + 4) (Ici 0)",
            "endPos": {
                "line": 414,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "all_goals apply MonotoneOn.const_mul",
            "proofState": 217,
            "pos": {
                "line": 415,
                "column": 2
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 12 * x ^ 5 + 15 * x ^ 4 + 4 * x ^ 2 + 11 * x) (Ici 0)\ncase hg\n\u22a2 MonotoneOn (fun x => 4) (Ici 0)",
            "endPos": {
                "line": 415,
                "column": 38
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 218,
            "pos": {
                "line": 415,
                "column": 12
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 12 * x ^ 5 + 15 * x ^ 4 + 4 * x ^ 2 + 11 * x) (Ici 0)",
            "endPos": {
                "line": 415,
                "column": 38
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "Set.Ici",
                "Real.instZero",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "instNatAtLeastTwo",
                "MonotoneOn",
                "Nat",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 219,
            "pos": {
                "line": 415,
                "column": 12
            },
            "goals": "case hg\n\u22a2 MonotoneOn (fun x => 4) (Ici 0)",
            "endPos": {
                "line": 415,
                "column": 38
            }
        },
        {
            "usedConstants": [],
            "tactic": "all_goals exact MonotoneOn.pow (fun _ _ \u21a6 by rfl) <;> norm_num <;> norm_num <;> norm_num <;> norm_num <;> norm_num",
            "proofState": 220,
            "pos": {
                "line": 416,
                "column": 2
            },
            "goals": "no goals",
            "endPos": {
                "line": 421,
                "column": 14
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 221,
            "pos": {
                "line": 424,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) (Icc 0 5)",
            "endPos": {
                "line": 424,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 2 + 7 / 10), sq_nonneg (y ^ 2 + 7 / 10), sq_nonneg (x - y), sq_nonneg (x + y),\n  sq_nonneg (x + y - 1), sq_nonneg (x + y + 1)]",
            "proofState": 222,
            "pos": {
                "line": 425,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 5\ny : \u211d\nhy : y \u2208 Icc 0 5\nh : x \u2264 y\n\u22a2 (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) x \u2264 (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 426,
                "column": 68
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 223,
            "pos": {
                "line": 429,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) (Icc 0 9)",
            "endPos": {
                "line": 429,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx",
            "proofState": 224,
            "pos": {
                "line": 430,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) ?s\ncase h'\n\u22a2 Icc 0 9 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 430,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro y hy",
            "proofState": 225,
            "pos": {
                "line": 431,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) x \u2264\n          (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) b\ncase h'\n\u22a2 Icc 0 9 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 431,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp_all only [Set.mem_Icc, and_imp]",
            "proofState": 226,
            "pos": {
                "line": 432,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) x \u2264\n      (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) y\ncase h'\n\u22a2 Icc 0 9 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 432,
                "column": 38
            }
        },
        {
            "usedConstants": [
                "Real",
                "Preorder.toLE",
                "LE.le",
                "Real.instPreorder"
            ],
            "tactic": "intro hx0 hx1 hy0 hy1",
            "proofState": 227,
            "pos": {
                "line": 433,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x \u2264 18 * y ^ 7 + 10 * y ^ 5 + 13 * y ^ 4 + 3 * y\ncase h'\n\u22a2 Icc 0 9 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 433,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 228,
            "pos": {
                "line": 437,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) (Icc 0 6)",
            "endPos": {
                "line": 437,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 229,
            "pos": {
                "line": 438,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) ?s\ncase h'\n\u22a2 Icc 0 6 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 438,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x + y), sq_nonneg (x - y)]",
            "proofState": 230,
            "pos": {
                "line": 439,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) x \u2264\n    (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 439,
                "column": 104
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 231,
            "pos": {
                "line": 443,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 12 * x ^ 4 + 18 * x ^ 3 + 8) (Icc 0 6)",
            "endPos": {
                "line": 443,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "exact fun _ hx _ _ h => by\n  nlinarith [sq_nonneg (x - 1), sq_nonneg (x - 2), sq_nonneg (x - 3), sq_nonneg (x + 1), sq_nonneg (x + 2),\n    sq_nonneg (x + 3)]",
            "proofState": 232,
            "pos": {
                "line": 444,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 12 * x ^ 4 + 18 * x ^ 3 + 8) ?s\ncase h'\n\u22a2 Icc 0 6 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 446,
                "column": 62
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - 1), sq_nonneg (x - 2), sq_nonneg (x - 3), sq_nonneg (x + 1), sq_nonneg (x + 2),\n  sq_nonneg (x + 3)]",
            "proofState": 233,
            "pos": {
                "line": 445,
                "column": 4
            },
            "goals": "x\u271d\u00b2 : \u211d\nhx : x\u271d\u00b2 \u2208 ?s\nx\u271d\u00b9 : \u211d\nx\u271d : x\u271d\u00b9 \u2208 ?s\nh : x\u271d\u00b2 \u2264 x\u271d\u00b9\n\u22a2 6 * x\u271d\u00b2 ^ 7 + 12 * x\u271d\u00b2 ^ 4 + 18 * x\u271d\u00b2 ^ 3 + 8 \u2264 6 * x\u271d\u00b9 ^ 7 + 12 * x\u271d\u00b9 ^ 4 + 18 * x\u271d\u00b9 ^ 3 + 8",
            "endPos": {
                "line": 446,
                "column": 62
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 234,
            "pos": {
                "line": 449,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 9 * x ^ 5 + 5 * x ^ 3) (Icc 0 3)",
            "endPos": {
                "line": 449,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 235,
            "pos": {
                "line": 450,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 9 * x ^ 5 + 5 * x ^ 3) (Ici 0)",
            "endPos": {
                "line": 450,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "MonotoneOn",
                "Nat",
                "Lean.Name",
                "OfNat.ofNat"
            ],
            "tactic": "all_goals nlinarith [sq_nonneg x, sq_nonneg (x ^ 3), sq_nonneg (x ^ 5), sq_nonneg (x ^ 7)]",
            "proofState": 236,
            "pos": {
                "line": 451,
                "column": 2
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 9 * x ^ 5) (Ici 0)\ncase hg\n\u22a2 MonotoneOn (fun x => 5 * x ^ 3) (Ici 0)",
            "endPos": {
                "line": 451,
                "column": 92
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg x, sq_nonneg (x ^ 3), sq_nonneg (x ^ 5), sq_nonneg (x ^ 7)]",
            "proofState": 237,
            "pos": {
                "line": 451,
                "column": 12
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 9 * x ^ 5) (Ici 0)",
            "endPos": {
                "line": 451,
                "column": 92
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg x, sq_nonneg (x ^ 3), sq_nonneg (x ^ 5), sq_nonneg (x ^ 7)]",
            "proofState": 238,
            "pos": {
                "line": 451,
                "column": 12
            },
            "goals": "case hg\n\u22a2 MonotoneOn (fun x => 5 * x ^ 3) (Ici 0)",
            "endPos": {
                "line": 451,
                "column": 92
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 239,
            "pos": {
                "line": 454,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3) (Icc 0 10)",
            "endPos": {
                "line": 454,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 240,
            "pos": {
                "line": 455,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3) ?s\ncase h'\n\u22a2 Icc 0 10 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 455,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [Function.comp_apply, Icc_subset_Icc_iff] at hx hy \u22a2",
            "proofState": 241,
            "pos": {
                "line": 456,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 (fun x => 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3) x \u2264\n    (fun x => 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3) y\ncase h'\n\u22a2 Icc 0 10 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 456,
                "column": 64
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "Real.partialOrder",
                "Real",
                "Preorder.toLT",
                "HMul.hMul",
                "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
                "covariant_swap_add_of_covariant_add",
                "PartialOrder.toPreorder",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "contravariant_lt_of_covariant_le",
                "LE.le",
                "Real.instAddCommSemigroup",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_4",
                "Nat",
                "Real.instMul",
                "LT.lt",
                "Real.instAddCommMonoid",
                "contravariant_swap_add_of_contravariant_add",
                "AddCommSemigroup.toAddCommMagma",
                "instHPow",
                "Real.instIsOrderedAddMonoid",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "IsOrderedCancelAddMonoid.toIsCancelAdd",
                "IsCancelAdd.toIsRightCancelAdd",
                "Real.instPreorder",
                "Real.linearOrder",
                "AddCommMagma.toAdd",
                "IsOrderedAddMonoid.toAddLeftMono",
                "instHMul",
                "Real.instNatCast",
                "Real.instIsOrderedCancelAddMonoid"
            ],
            "tactic": "norm_num",
            "proofState": 242,
            "pos": {
                "line": 457,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3 \u2264\n    19 * y ^ 7 + 15 * y ^ 5 + 15 * y ^ 3 + 15 * y ^ 2 + 7 * y + 3\ncase h'\n\u22a2 Icc 0 10 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 457,
                "column": 10
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 243,
            "pos": {
                "line": 458,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x \u2264 19 * y ^ 7 + 15 * y ^ 5 + 15 * y ^ 3 + 15 * y ^ 2 + 7 * y\ncase h'\n\u22a2 Icc 0 10 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 458,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 244,
            "pos": {
                "line": 461,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) (Icc 0 2)",
            "endPos": {
                "line": 461,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 245,
            "pos": {
                "line": 462,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 2\ny : \u211d\nhy : y \u2208 Icc 0 2\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) x \u2264\n    (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 462,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "apply le_of_not_gt",
            "proofState": 246,
            "pos": {
                "line": 463,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 2\nhy : 0 \u2264 y \u2227 y \u2264 2\n\u22a2 (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) x \u2264\n    (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 463,
                "column": 20
            }
        },
        {
            "usedConstants": [
                "Real",
                "Preorder.toLT",
                "HMul.hMul",
                "PartialOrder.toPreorder",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "GT.gt",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "LinearOrder.toPartialOrder",
                "instOfNatAtLeastTwo",
                "Real.linearOrder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "intro h",
            "proofState": 247,
            "pos": {
                "line": 464,
                "column": 2
            },
            "goals": "case a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 2\nhy : 0 \u2264 y \u2227 y \u2264 2\n\u22a2 \u00ac(fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) x >\n      (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 464,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "have h' := MVT x y (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) hxy",
            "proofState": 248,
            "pos": {
                "line": 465,
                "column": 2
            },
            "goals": "case a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 2\nhy : 0 \u2264 y \u2227 y \u2264 2\nh :\n  (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) x >\n    (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) y\n\u22a2 False",
            "endPos": {
                "line": 466,
                "column": 107
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Monoid.toNatPow",
                "Set.Icc_subset_Icc_left",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instOne",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "One.toOfNat1",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 249,
            "pos": {
                "line": 473,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 7 * x ^ 5 + 12 * x ^ 4 + 9 * x ^ 3 + 18 * x ^ 2 + 12 * x + 16) (Icc 0 1)",
            "endPos": {
                "line": 473,
                "column": 61
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 250,
            "pos": {
                "line": 473,
                "column": 51
            },
            "goals": "\u22a2 ?m.899887 \u2264 0",
            "endPos": {
                "line": 473,
                "column": 59
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.add",
            "proofState": 251,
            "pos": {
                "line": 474,
                "column": 2
            },
            "goals": "\u22a2 \u211d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 7 * x ^ 5 + 12 * x ^ 4 + 9 * x ^ 3 + 18 * x ^ 2 + 12 * x + 16) (Icc ?m.899887 1)",
            "endPos": {
                "line": 474,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 252,
            "pos": {
                "line": 483,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 7 + 6 * x ^ 6 + 17 * x ^ 3 + 12 * x ^ 2 + 9 * x) (Icc 0 6)",
            "endPos": {
                "line": 483,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Icc_def, le_iff_exists_add] at hx hy",
            "proofState": 253,
            "pos": {
                "line": 484,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 7 + 6 * x ^ 6 + 17 * x ^ 3 + 12 * x ^ 2 + 9 * x) x \u2264\n    (fun x => 15 * x ^ 7 + 6 * x ^ 6 + 17 * x ^ 3 + 12 * x ^ 2 + 9 * x) y",
            "endPos": {
                "line": 484,
                "column": 49
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Monoid.toNatPow",
                "Set.Icc_subset_Icc_left",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 254,
            "pos": {
                "line": 491,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 12 * x ^ 6 + 12 * x ^ 5 + 3 * x ^ 4 + 7 * x) (Icc 0 8)",
            "endPos": {
                "line": 491,
                "column": 61
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 255,
            "pos": {
                "line": 491,
                "column": 51
            },
            "goals": "\u22a2 ?m.914333 \u2264 0",
            "endPos": {
                "line": 491,
                "column": 59
            }
        },
        {
            "usedConstants": [],
            "tactic": "intro x hx y hy h",
            "proofState": 256,
            "pos": {
                "line": 492,
                "column": 2
            },
            "goals": "\u22a2 \u211d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 12 * x ^ 6 + 12 * x ^ 5 + 3 * x ^ 4 + 7 * x) (Icc ?m.914333 8)",
            "endPos": {
                "line": 492,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 257,
            "pos": {
                "line": 496,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7) (Icc 0 10)",
            "endPos": {
                "line": 496,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp_all only [Icc_subset_Icc_iff, le_refl, true_and_iff, le_of_eq, zero_le_one, zero_le_two, zero_le_three,\n  zero_le_four, zero_le_five, zero_le_six, zero_le_seven, zero_le_eight, zero_le_nine, zero_le_ten]",
            "proofState": 258,
            "pos": {
                "line": 497,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 10\ny : \u211d\nhy : y \u2208 Icc 0 10\nh : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7) x \u2264 (fun x => 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7) y",
            "endPos": {
                "line": 499,
                "column": 60
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y)]",
            "proofState": 259,
            "pos": {
                "line": 500,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 10\ny : \u211d\nhy : y \u2208 Icc 0 10\nh : x \u2264 y\n\u22a2 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7 \u2264 15 * y ^ 6 + 5 * y ^ 3 + 16 * y ^ 2 + 7",
            "endPos": {
                "line": 500,
                "column": 31
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.const_add",
            "proofState": 260,
            "pos": {
                "line": 503,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 16 * x ^ 7 + 20 * x ^ 4 + 4 * x ^ 2 + 18 * x + 15) (Icc 0 5)",
            "endPos": {
                "line": 503,
                "column": 28
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "Real.instZero",
                "congrArg",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "exact fun x hx y hy hxy \u21a6\n  by\n  simp only [two_mul, mul_add, mul_one, mul_assoc, mul_comm, mul_left_comm]\n  nlinarith [sq_nonneg (x ^ 2), sq_nonneg (y ^ 2), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 261,
            "pos": {
                "line": 515,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 2 * x ^ 7 + 19 * x ^ 5 + 4 * x ^ 3 + 20 * x) (Icc 0 7)",
            "endPos": {
                "line": 517,
                "column": 98
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [two_mul, mul_add, mul_one, mul_assoc, mul_comm, mul_left_comm]",
            "proofState": 262,
            "pos": {
                "line": 516,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nhxy : x \u2264 y\n\u22a2 (fun x => 2 * x ^ 7 + 19 * x ^ 5 + 4 * x ^ 3 + 20 * x) x \u2264 (fun x => 2 * x ^ 7 + 19 * x ^ 5 + 4 * x ^ 3 + 20 * x) y",
            "endPos": {
                "line": 516,
                "column": 77
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 2), sq_nonneg (y ^ 2), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 263,
            "pos": {
                "line": 517,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nhxy : x \u2264 y\n\u22a2 x ^ 7 * 2 + x ^ 5 * 19 + x ^ 3 * 4 + x * 20 \u2264 y ^ 7 * 2 + y ^ 5 * 19 + y ^ 3 * 4 + y * 20",
            "endPos": {
                "line": 517,
                "column": 98
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 264,
            "pos": {
                "line": 520,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) (Icc 0 6)",
            "endPos": {
                "line": 520,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 265,
            "pos": {
                "line": 521,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) ?s\ncase h'\n\u22a2 Icc 0 6 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 521,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 266,
            "pos": {
                "line": 522,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) x \u2264\n    (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) y",
            "endPos": {
                "line": 522,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 267,
            "pos": {
                "line": 527,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) (Icc 0 7)",
            "endPos": {
                "line": 527,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 268,
            "pos": {
                "line": 528,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nhxy : x \u2264 y\n\u22a2 (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) x \u2264\n    (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) y",
            "endPos": {
                "line": 528,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 - 1), sq_nonneg (y ^ 2 - 1), sq_nonneg (x - y),\n  sq_nonneg (x - 1), sq_nonneg (y - 1)]",
            "proofState": 269,
            "pos": {
                "line": 529,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 7\nhy : 0 \u2264 y \u2227 y \u2264 7\n\u22a2 (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) x \u2264\n    (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) y",
            "endPos": {
                "line": 534,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _",
            "proofState": 270,
            "pos": {
                "line": 537,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 9 * x ^ 5 + 11 * x ^ 4 + 8 * x ^ 2 + 20 * x) (Icc 0 5)",
            "endPos": {
                "line": 537,
                "column": 25
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 271,
            "pos": {
                "line": 538,
                "column": 2
            },
            "goals": "\u22a2 Icc 0 5 \u2286 ?m.978610\n\u22a2 Set \u211d\n\u22a2 MonotoneOn (fun x => 9 * x ^ 5 + 11 * x ^ 4 + 8 * x ^ 2 + 20 * x) ?m.978610",
            "endPos": {
                "line": 538,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 272,
            "pos": {
                "line": 546,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) (Icc 0 1)",
            "endPos": {
                "line": 546,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "LE.le",
                "Real.instOne",
                "And",
                "Set.Icc",
                "One.toOfNat1",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "Real.instPreorder",
                "Set"
            ],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 273,
            "pos": {
                "line": 547,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nhxy : x \u2264 y\n\u22a2 (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) x \u2264\n    (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) y",
            "endPos": {
                "line": 547,
                "column": 30
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x + y), hx.1, hx.2, hy.1,\n  hy.2, hxy]",
            "proofState": 274,
            "pos": {
                "line": 548,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 1\nhy : 0 \u2264 y \u2227 y \u2264 1\n\u22a2 (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) x \u2264\n    (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) y",
            "endPos": {
                "line": 549,
                "column": 51
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Set.Icc_subset_Icc_right",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Set.Icc_subset_Icc_right (by norm_num : (2 : \u211d) \u2264 2))",
            "proofState": 275,
            "pos": {
                "line": 552,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 9 * x ^ 5 + 14 * x ^ 4 + 12 * x + 10) (Icc 0 2)",
            "endPos": {
                "line": 552,
                "column": 80
            }
        },
        {
            "usedConstants": [
                "Real.instIsOrderedRing",
                "Real.partialOrder",
                "Real",
                "AddGroupWithOne.toAddMonoidWithOne",
                "Real.semiring",
                "AddMonoidWithOne.toNatCast",
                "Real.instRing",
                "instOfNatNat",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "Bool.true",
                "instNatAtLeastTwo",
                "Nat",
                "Bool",
                "Eq.refl",
                "OfNat.ofNat",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Mathlib.Meta.NormNum.isNat_le_true",
                "Real.instNatCast"
            ],
            "tactic": "norm_num",
            "proofState": 276,
            "pos": {
                "line": 552,
                "column": 56
            },
            "goals": "\u22a2 2 \u2264 2",
            "endPos": {
                "line": 552,
                "column": 64
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real.partialOrder",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "covariant_swap_add_of_covariant_add",
                "Preorder.toLE",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "MonotoneOn.add",
                "Lean.Name.num",
                "LE.le",
                "Real.instAddCommSemigroup",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Real.instAddCommMonoid",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "Real.instIsOrderedAddMonoid",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "IsOrderedAddMonoid.toAddLeftMono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "exact\n  MonotoneOn.add (MonotoneOn.const_mul (fun x hx => by norm_num) (by norm_num : (0 : \u211d) \u2264 9))\n    (MonotoneOn.const_mul (fun x hx => by norm_num) (by norm_num : (0 : \u211d) \u2264 14))",
            "proofState": 277,
            "pos": {
                "line": 553,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 9 * x ^ 5 + 14 * x ^ 4 + 12 * x + 10) (Icc 0 2)",
            "endPos": {
                "line": 556,
                "column": 83
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 278,
            "pos": {
                "line": 559,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) (Icc 0 9)",
            "endPos": {
                "line": 559,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 279,
            "pos": {
                "line": 560,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nh : x \u2264 y\n\u22a2 (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) x \u2264\n    (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) y",
            "endPos": {
                "line": 560,
                "column": 30
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 280,
            "pos": {
                "line": 561,
                "column": 2
            },
            "goals": "x y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 9\nhy : 0 \u2264 y \u2227 y \u2264 9\n\u22a2 (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) x \u2264\n    (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) y",
            "endPos": {
                "line": 561,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Set.Icc_subset_Icc_right",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_right (by norm_num))",
            "proofState": 281,
            "pos": {
                "line": 564,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 20 * x ^ 5 + 16 * x ^ 4) (Icc 0 10)",
            "endPos": {
                "line": 564,
                "column": 62
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 282,
            "pos": {
                "line": 564,
                "column": 52
            },
            "goals": "\u22a2 10 \u2264 ?m.1018855",
            "endPos": {
                "line": 564,
                "column": 60
            }
        },
        {
            "usedConstants": [],
            "tactic": "intro x hx y hy h",
            "proofState": 283,
            "pos": {
                "line": 565,
                "column": 2
            },
            "goals": "\u22a2 \u211d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 5 + 16 * x ^ 4) (Icc 0 ?m.1018855)",
            "endPos": {
                "line": 565,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 284,
            "pos": {
                "line": 574,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) (Icc 0 1)",
            "endPos": {
                "line": 574,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx",
            "proofState": 285,
            "pos": {
                "line": 575,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) ?s\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 575,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro y hy",
            "proofState": 286,
            "pos": {
                "line": 576,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) x \u2264\n          (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) b\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 576,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "Real",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Real.instAddMonoid",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "AddGroupWithOne.toAddMonoidWithOne",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "Real.instRing",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "Real.instAdd",
                "AddMonoidWithOne.toOne",
                "Real.instMonoid",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "implies_congr",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Real.instMul",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Real.instCommSemiring",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "ring_nf",
            "proofState": 287,
            "pos": {
                "line": 577,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) x \u2264\n      (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) y\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 577,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 288,
            "pos": {
                "line": 578,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    8 + x * 17 + x ^ 2 * 20 + x ^ 3 * 9 + x ^ 5 * 4 + x ^ 7 * 4 \u2264\n      8 + y * 17 + y ^ 2 * 20 + y ^ 3 * 9 + y ^ 5 * 4 + y ^ 7 * 4\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 578,
                "column": 10
            }
        },
        {
            "usedConstants": [
                "Real",
                "Preorder.toLE",
                "LE.le",
                "Real.instPreorder"
            ],
            "tactic": "intro h",
            "proofState": 289,
            "pos": {
                "line": 579,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    8 + x * 17 + x ^ 2 * 20 + x ^ 3 * 9 + x ^ 5 * 4 + x ^ 7 * 4 \u2264\n      8 + y * 17 + y ^ 2 * 20 + y ^ 3 * 9 + y ^ 5 * 4 + y ^ 7 * 4\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 579,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [hx.1, hx.2, hy.1, hy.2, h]",
            "proofState": 290,
            "pos": {
                "line": 580,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nh : x \u2264 y\n\u22a2 8 + x * 17 + x ^ 2 * 20 + x ^ 3 * 9 + x ^ 5 * 4 + x ^ 7 * 4 \u2264\n    8 + y * 17 + y ^ 2 * 20 + y ^ 3 * 9 + y ^ 5 * 4 + y ^ 7 * 4\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 580,
                "column": 39
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 291,
            "pos": {
                "line": 583,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) (Icc 0 9)",
            "endPos": {
                "line": 583,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hx' : 0 \u2264 x := by\n  cases' hx with hx\u2081 hx\u2082\n  nlinarith",
            "proofState": 292,
            "pos": {
                "line": 584,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x \u2264 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y",
            "endPos": {
                "line": 586,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Membership.mem",
                "instOfNatNat",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "Eq.refl",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "cases' hx with hx\u2081 hx\u2082",
            "proofState": 293,
            "pos": {
                "line": 585,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 585,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith",
            "proofState": 294,
            "pos": {
                "line": 586,
                "column": 4
            },
            "goals": "case intro\nx y : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\nhx\u2081 : 0 \u2264 x\nhx\u2082 : x \u2264 9\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 586,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hy' : 0 \u2264 y := by\n  cases' hy with hy\u2081 hy\u2082\n  nlinarith",
            "proofState": 295,
            "pos": {
                "line": 587,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x \u2264 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y",
            "endPos": {
                "line": 589,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Membership.mem",
                "instOfNatNat",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "Eq.refl",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "cases' hy with hy\u2081 hy\u2082",
            "proofState": 296,
            "pos": {
                "line": 588,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 0 \u2264 y",
            "endPos": {
                "line": 588,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith",
            "proofState": 297,
            "pos": {
                "line": 589,
                "column": 4
            },
            "goals": "case intro\nx : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy\u2081 : 0 \u2264 y\nhy\u2082 : y \u2264 9\n\u22a2 0 \u2264 y",
            "endPos": {
                "line": 589,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "have hxy' : x \u2264 y := by nlinarith",
            "proofState": 298,
            "pos": {
                "line": 590,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x \u2264 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y",
            "endPos": {
                "line": 591,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith",
            "proofState": 299,
            "pos": {
                "line": 591,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 x \u2264 y",
            "endPos": {
                "line": 591,
                "column": 13
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 + y ^ 2)]",
            "proofState": 300,
            "pos": {
                "line": 592,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x \u2264 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y",
            "endPos": {
                "line": 593,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 301,
            "pos": {
                "line": 596,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) (Icc 0 1)",
            "endPos": {
                "line": 596,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 302,
            "pos": {
                "line": 597,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\n\u22a2 (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) x \u2264\n    (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) y",
            "endPos": {
                "line": 597,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 303,
            "pos": {
                "line": 600,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) (Icc 0 5)",
            "endPos": {
                "line": 600,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 304,
            "pos": {
                "line": 601,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 5\ny : \u211d\nhy : y \u2208 Icc 0 5\nhxy : x \u2264 y\n\u22a2 (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) x \u2264\n    (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 601,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "le_of_sub_nonneg"
            ],
            "tactic": "apply le_of_sub_nonneg",
            "proofState": 305,
            "pos": {
                "line": 602,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 5\nhy : 0 \u2264 y \u2227 y \u2264 5\n\u22a2 (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) x \u2264\n    (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 602,
                "column": 24
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2),\n  sq_nonneg (x - y)]",
            "proofState": 306,
            "pos": {
                "line": 603,
                "column": 2
            },
            "goals": "case a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 5\nhy : 0 \u2264 y \u2227 y \u2264 5\n\u22a2 0 \u2264\n    (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) y -\n      (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) x",
            "endPos": {
                "line": 604,
                "column": 76
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 307,
            "pos": {
                "line": 607,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) (Icc 0 7)",
            "endPos": {
                "line": 607,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have hx' := hx",
            "proofState": 308,
            "pos": {
                "line": 608,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\n\u22a2 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) x \u2264 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) y",
            "endPos": {
                "line": 608,
                "column": 16
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have hy' := hy",
            "proofState": 309,
            "pos": {
                "line": 608,
                "column": 18
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\nhx' : x \u2208 Icc 0 7\n\u22a2 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) x \u2264 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) y",
            "endPos": {
                "line": 608,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp_all only [Set.mem_Icc]",
            "proofState": 310,
            "pos": {
                "line": 609,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\nhx' : x \u2208 Icc 0 7\nhy' : y \u2208 Icc 0 7\n\u22a2 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) x \u2264 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) y",
            "endPos": {
                "line": 609,
                "column": 29
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 + y ^ 2)]",
            "proofState": 311,
            "pos": {
                "line": 610,
                "column": 2
            },
            "goals": "x y : \u211d\nh : x \u2264 y\nhx' : 0 \u2264 x \u2227 x \u2264 7\nhy' : 0 \u2264 y \u2227 y \u2264 7\n\u22a2 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14 \u2264 7 * y ^ 6 + 7 * y ^ 4 + 5 * y ^ 2 + 14",
            "endPos": {
                "line": 610,
                "column": 104
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 312,
            "pos": {
                "line": 613,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) (Icc 0 3)",
            "endPos": {
                "line": 613,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 313,
            "pos": {
                "line": 614,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) x \u2264\n    (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) y",
            "endPos": {
                "line": 614,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 314,
            "pos": {
                "line": 617,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 7 * x ^ 6 + 16 * x ^ 4 + 5 * x ^ 3 + 19 * x ^ 2) (Icc 0 6)",
            "endPos": {
                "line": 617,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "exact fun x hx y hy hxy => by\n  nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x + y), sq_nonneg (x - y)]",
            "proofState": 315,
            "pos": {
                "line": 618,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 7 * x ^ 6 + 16 * x ^ 4 + 5 * x ^ 3 + 19 * x ^ 2) (Ici 0)",
            "endPos": {
                "line": 620,
                "column": 43
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x + y), sq_nonneg (x - y)]",
            "proofState": 316,
            "pos": {
                "line": 619,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 7 * x ^ 6 + 16 * x ^ 4 + 5 * x ^ 3 + 19 * x ^ 2 \u2264 7 * y ^ 6 + 16 * y ^ 4 + 5 * y ^ 3 + 19 * y ^ 2",
            "endPos": {
                "line": 620,
                "column": 43
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Set.Icc_subset_Icc_right",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ <| Icc_subset_Icc_right (by norm_num)",
            "proofState": 317,
            "pos": {
                "line": 623,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 10 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 5 + 19 * x ^ 4 + 6 * x ^ 3 + 12 * x + 14) (Icc 0 9)",
            "endPos": {
                "line": 623,
                "column": 63
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 318,
            "pos": {
                "line": 623,
                "column": 54
            },
            "goals": "\u22a2 9 \u2264 ?m.1119116",
            "endPos": {
                "line": 623,
                "column": 62
            }
        },
        {
            "usedConstants": [],
            "tactic": "intro x hx y hy hxy",
            "proofState": 319,
            "pos": {
                "line": 624,
                "column": 2
            },
            "goals": "\u22a2 \u211d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 5 + 19 * x ^ 4 + 6 * x ^ 3 + 12 * x + 14) (Icc 0 ?m.1119116)",
            "endPos": {
                "line": 624,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 320,
            "pos": {
                "line": 630,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 3 * x ^ 5 + 8 * x ^ 4 + 4 * x ^ 3 + 20 * x) (Icc 0 4)",
            "endPos": {
                "line": 630,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 321,
            "pos": {
                "line": 631,
                "column": 6
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 3 * x ^ 5 + 8 * x ^ 4 + 4 * x ^ 3) (Icc 0 4)",
            "endPos": {
                "line": 631,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "MonotoneOn",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 322,
            "pos": {
                "line": 631,
                "column": 6
            },
            "goals": "case hg\n\u22a2 MonotoneOn (HMul.hMul 20) (Icc 0 4)",
            "endPos": {
                "line": 631,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Unit",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ Icc_subset_Icc_right",
            "proofState": 323,
            "pos": {
                "line": 640,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 2 * x ^ 6 + 9 * x ^ 5 + 10 * x + 13) (Icc 0 9)",
            "endPos": {
                "line": 640,
                "column": 46
            }
        },
        {
            "usedConstants": [],
            "tactic": "refine' MonotoneOn.add _ _",
            "proofState": 324,
            "pos": {
                "line": 641,
                "column": 2
            },
            "goals": "\u22a2 Set \u211d",
            "endPos": {
                "line": 641,
                "column": 28
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 325,
            "pos": {
                "line": 650,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3) (Icc 0 3)",
            "endPos": {
                "line": 650,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp_all only [Icc_subset_Icc_iff, le_refl, true_and, le_of_lt, and_true]",
            "proofState": 326,
            "pos": {
                "line": 651,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nh : x \u2264 y\n\u22a2 (fun x => 17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3) x \u2264\n    (fun x => 17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3) y",
            "endPos": {
                "line": 651,
                "column": 75
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x ^ 2 - x * y),\n  sq_nonneg (x * y - y ^ 2)]",
            "proofState": 327,
            "pos": {
                "line": 652,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nh : x \u2264 y\n\u22a2 17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3 \u2264\n    17 * y ^ 7 + 11 * y ^ 5 + 20 * y ^ 4 + 7 * y ^ 3 + 6 * y ^ 2 + 12 * y + 3",
            "endPos": {
                "line": 653,
                "column": 57
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 328,
            "pos": {
                "line": 656,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 4 + 19 * x + 13) (Icc 0 7)",
            "endPos": {
                "line": 656,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 329,
            "pos": {
                "line": 657,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 15 * x ^ 4 + 19 * x + 13) (Ici 0)",
            "endPos": {
                "line": 657,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mul_comm, mul_one] at hx hy",
            "proofState": 330,
            "pos": {
                "line": 658,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 4 + 19 * x + 13) x \u2264 (fun x => 15 * x ^ 4 + 19 * x + 13) y",
            "endPos": {
                "line": 658,
                "column": 40
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "sorryAx",
                "Monoid.toNatPow",
                "Set.Icc_subset_Icc_left",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 331,
            "pos": {
                "line": 663,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) (Icc 0 5)",
            "endPos": {
                "line": 663,
                "column": 63
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 332,
            "pos": {
                "line": 663,
                "column": 53
            },
            "goals": "\u22a2 ?m.1163506 \u2264 0",
            "endPos": {
                "line": 663,
                "column": 61
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 333,
            "pos": {
                "line": 664,
                "column": 2
            },
            "goals": "case refine'_1\n\u22a2 MonotoneOn (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) (Icc ?refine'_2 5)\ncase refine'_2\n\u22a2 \u211d",
            "endPos": {
                "line": 664,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 334,
            "pos": {
                "line": 665,
                "column": 2
            },
            "goals": "case refine'_1\nx : \u211d\nhx : x \u2208 Icc ?refine'_2 5\ny : \u211d\nhy : y \u2208 Icc ?refine'_2 5\nhxy : x \u2264 y\n\u22a2 (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) x \u2264 (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) y\ncase refine'_2\n\u22a2 \u211d",
            "endPos": {
                "line": 665,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x + y), sq_nonneg (x - y), sq_nonneg (x + y - 1), sq_nonneg (x + y + 1)]",
            "proofState": 335,
            "pos": {
                "line": 666,
                "column": 2
            },
            "goals": "case refine'_1\nx y : \u211d\nhxy : x \u2264 y\nhx : ?refine'_2 \u2264 x \u2227 x \u2264 5\nhy : ?refine'_2 \u2264 y \u2227 y \u2264 5\n\u22a2 (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) x \u2264 (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) y\ncase refine'_2\n\u22a2 \u211d",
            "endPos": {
                "line": 666,
                "column": 96
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Set.Icc_subset_Ici_self)",
            "proofState": 336,
            "pos": {
                "line": 669,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 10 * x ^ 6 + 9 * x ^ 5 + 14 * x ^ 4 + 3 * x ^ 2 + 17) (Icc 0 10)",
            "endPos": {
                "line": 669,
                "column": 51
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "Eq.mp",
                "instOfNatNat",
                "_private.0._proof_2",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Lean.Name",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "exact fun x hx y hy hxy \u21a6\n  by\n  simp_all only [Set.mem_Icc, Set.mem_Ici, le_refl, true_and_iff, and_true_iff]\n  nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x + y),\n    sq_nonneg (x ^ 2 + y ^ 2), sq_nonneg (x ^ 3 + y ^ 3)]",
            "proofState": 337,
            "pos": {
                "line": 670,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 10 * x ^ 6 + 9 * x ^ 5 + 14 * x ^ 4 + 3 * x ^ 2 + 17) (Ici 0)",
            "endPos": {
                "line": 677,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Real",
                "Set.Ici",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "_private.0._proof_2",
                "LE.le",
                "Zero.toOfNat0",
                "OfNat.ofNat",
                "Set.instMembership",
                "Real.instPreorder",
                "Set"
            ],
            "tactic": "simp_all only [Set.mem_Icc, Set.mem_Ici, le_refl, true_and_iff, and_true_iff]",
            "proofState": 338,
            "pos": {
                "line": 671,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 10 * x ^ 6 + 9 * x ^ 5 + 14 * x ^ 4 + 3 * x ^ 2 + 17 \u2264 10 * y ^ 6 + 9 * y ^ 5 + 14 * y ^ 4 + 3 * y ^ 2 + 17",
            "endPos": {
                "line": 671,
                "column": 81
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x + y),\n  sq_nonneg (x ^ 2 + y ^ 2), sq_nonneg (x ^ 3 + y ^ 3)]",
            "proofState": 339,
            "pos": {
                "line": 672,
                "column": 4
            },
            "goals": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhxy : x \u2264 y\n\u22a2 10 * x ^ 6 + 9 * x ^ 5 + 14 * x ^ 4 + 3 * x ^ 2 + 17 \u2264 10 * y ^ 6 + 9 * y ^ 5 + 14 * y ^ 4 + 3 * y ^ 2 + 17",
            "endPos": {
                "line": 677,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Monoid.toNatPow",
                "Set.Icc_subset_Icc_left",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 340,
            "pos": {
                "line": 680,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 14 * x ^ 4 + 18 * x ^ 3 + 3 * x ^ 2 + 8 * x) (Icc 0 7)",
            "endPos": {
                "line": 680,
                "column": 61
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 341,
            "pos": {
                "line": 680,
                "column": 51
            },
            "goals": "\u22a2 ?m.1194572 \u2264 0",
            "endPos": {
                "line": 680,
                "column": 59
            }
        },
        {
            "usedConstants": [],
            "tactic": "intro x hx y hy hxy",
            "proofState": 342,
            "pos": {
                "line": 681,
                "column": 2
            },
            "goals": "\u22a2 \u211d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 14 * x ^ 4 + 18 * x ^ 3 + 3 * x ^ 2 + 8 * x) (Icc ?m.1194572 7)",
            "endPos": {
                "line": 681,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Set.Icc_subset_Icc",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ <| Icc_subset_Icc (by norm_num) (by norm_num)",
            "proofState": 343,
            "pos": {
                "line": 688,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 3 * x ^ 7 + 19 * x ^ 5 + 13 * x ^ 4 + 4 * x ^ 2 + 8 * x + 12) (Icc 0 10)",
            "endPos": {
                "line": 688,
                "column": 71
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 344,
            "pos": {
                "line": 688,
                "column": 48
            },
            "goals": "\u22a2 ?m.1203096 \u2264 0",
            "endPos": {
                "line": 688,
                "column": 56
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 345,
            "pos": {
                "line": 688,
                "column": 62
            },
            "goals": "\u22a2 10 \u2264 ?m.1203098",
            "endPos": {
                "line": 688,
                "column": 70
            }
        },
        {
            "usedConstants": [],
            "tactic": "intro x hx y hy hxy",
            "proofState": 346,
            "pos": {
                "line": 689,
                "column": 2
            },
            "goals": "\u22a2 \u211d\n\u22a2 \u211d\n\u22a2 MonotoneOn (fun x => 3 * x ^ 7 + 19 * x ^ 5 + 13 * x ^ 4 + 4 * x ^ 2 + 8 * x + 12) (Icc ?m.1203096 ?m.1203098)",
            "endPos": {
                "line": 689,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 347,
            "pos": {
                "line": 694,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 13 * x ^ 2 + 12 * x) (Icc 0 8)",
            "endPos": {
                "line": 694,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Icc_def, mem_setOf_eq] at hx hy",
            "proofState": 348,
            "pos": {
                "line": 695,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nhxy : x \u2264 y\n\u22a2 (fun x => 13 * x ^ 2 + 12 * x) x \u2264 (fun x => 13 * x ^ 2 + 12 * x) y",
            "endPos": {
                "line": 695,
                "column": 44
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instOne",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "One.toOfNat1",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 349,
            "pos": {
                "line": 699,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 3 * x ^ 7 + 13 * x ^ 6 + 18 * x ^ 5 + 15 * x ^ 4 + 9 * x ^ 3 + 17 * x ^ 2 + 6 * x) (Icc 0 1)",
            "endPos": {
                "line": 699,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 350,
            "pos": {
                "line": 700,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 3 * x ^ 7 + 13 * x ^ 6 + 18 * x ^ 5 + 15 * x ^ 4 + 9 * x ^ 3 + 17 * x ^ 2 + 6 * x) (Ici 0)",
            "endPos": {
                "line": 700,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (x ^ 2 + x), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (y ^ 2 + y)]",
            "proofState": 351,
            "pos": {
                "line": 701,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 3 * x ^ 7 + 13 * x ^ 6 + 18 * x ^ 5 + 15 * x ^ 4 + 9 * x ^ 3 + 17 * x ^ 2 + 6 * x) x \u2264\n    (fun x => 3 * x ^ 7 + 13 * x ^ 6 + 18 * x ^ 5 + 15 * x ^ 4 + 9 * x ^ 3 + 17 * x ^ 2 + 6 * x) y",
            "endPos": {
                "line": 702,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 352,
            "pos": {
                "line": 705,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 20 * x ^ 6 + 14 * x ^ 5 + 3 * x ^ 4 + 13 * x ^ 2) (Icc 0 6)",
            "endPos": {
                "line": 705,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 353,
            "pos": {
                "line": 706,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 20 * x ^ 6 + 14 * x ^ 5 + 3 * x ^ 4 + 13 * x ^ 2) (Ici 0)",
            "endPos": {
                "line": 706,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 354,
            "pos": {
                "line": 707,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 20 * x ^ 6 + 14 * x ^ 5 + 3 * x ^ 4 + 13 * x ^ 2) x \u2264\n    (fun x => 20 * x ^ 6 + 14 * x ^ 5 + 3 * x ^ 4 + 13 * x ^ 2) y",
            "endPos": {
                "line": 707,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 355,
            "pos": {
                "line": 719,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2 + 2 * x) (Icc 0 7)",
            "endPos": {
                "line": 719,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 356,
            "pos": {
                "line": 720,
                "column": 2
            },
            "goals": "case hf\n\u22a2 MonotoneOn (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) (Icc 0 7)\ncase hg\n\u22a2 MonotoneOn (HMul.hMul 2) (Icc 0 7)",
            "endPos": {
                "line": 720,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x ^ 5 - y ^ 5),\n  sq_nonneg (x ^ 7 - y ^ 7)]",
            "proofState": 357,
            "pos": {
                "line": 721,
                "column": 2
            },
            "goals": "case hf\nx : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nhxy : x \u2264 y\n\u22a2 (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) x \u2264\n    (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) y\ncase hg\n\u22a2 MonotoneOn (HMul.hMul 2) (Icc 0 7)",
            "endPos": {
                "line": 722,
                "column": 76
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 358,
            "pos": {
                "line": 732,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 2 + 8 * x + 7) (Icc 0 1)",
            "endPos": {
                "line": 732,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 359,
            "pos": {
                "line": 733,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 2 + 8 * x + 7) ?s",
            "endPos": {
                "line": 733,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Lean.Name.str",
                "Real.instAdd",
                "Lean.Name.anonymous",
                "Real.instMonoid",
                "Bool.true",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "Lean.Name",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "<failed to pretty print>",
            "proofState": 360,
            "pos": {
                "line": 734,
                "column": 6
            },
            "goals": "case h.hf\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 2 + 8 * x) ?s",
            "endPos": {
                "line": 737,
                "column": 35
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm]",
            "proofState": 361,
            "pos": {
                "line": 735,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 4 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 2 + 8 * x \u2264 4 * y ^ 7 + 7 * y ^ 6 + 3 * y ^ 2 + 8 * y",
            "endPos": {
                "line": 735,
                "column": 50
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 362,
            "pos": {
                "line": 736,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 x ^ 7 * 4 + x ^ 6 * 7 + x ^ 2 * 3 + x * 8 \u2264 y ^ 7 * 4 + y ^ 6 * 7 + y ^ 2 * 3 + y * 8",
            "endPos": {
                "line": 736,
                "column": 87
            }
        },
        {
            "usedConstants": [
                "Real",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instNatAtLeastTwo",
                "Nat",
                "Lean.Name",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "<failed to pretty print>",
            "proofState": 363,
            "pos": {
                "line": 734,
                "column": 6
            },
            "goals": "case h.hg\n\u22a2 MonotoneOn (fun x => 7) ?s",
            "endPos": {
                "line": 737,
                "column": 35
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm]",
            "proofState": 364,
            "pos": {
                "line": 735,
                "column": 4
            },
            "goals": "x : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 7 \u2264 7",
            "endPos": {
                "line": 735,
                "column": 50
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 365,
            "pos": {
                "line": 748,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) (Icc 0 1)",
            "endPos": {
                "line": 748,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx",
            "proofState": 366,
            "pos": {
                "line": 749,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) ?s\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 749,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro y hy",
            "proofState": 367,
            "pos": {
                "line": 750,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) x \u2264\n          (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) b\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 750,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy \u22a2",
            "proofState": 368,
            "pos": {
                "line": 751,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) x \u2264\n      (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) y\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 751,
                "column": 36
            }
        },
        {
            "usedConstants": [
                "Real",
                "Preorder.toLE",
                "LE.le",
                "Real.instPreorder"
            ],
            "tactic": "intro h",
            "proofState": 369,
            "pos": {
                "line": 752,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20 \u2264\n      13 * y ^ 7 + 4 * y ^ 6 + 16 * y ^ 5 + 11 * y ^ 4 + 5 * y ^ 3 + 15 * y ^ 2 + 20\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 752,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 3 + y ^ 3),\n  sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 + y ^ 2)]",
            "proofState": 370,
            "pos": {
                "line": 753,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nh : x \u2264 y\n\u22a2 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20 \u2264\n    13 * y ^ 7 + 4 * y ^ 6 + 16 * y ^ 5 + 11 * y ^ 4 + 5 * y ^ 3 + 15 * y ^ 2 + 20\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 754,
                "column": 84
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Monoid.toNatPow",
                "Set.Icc_subset_Icc_left",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instOne",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "One.toOfNat1",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 371,
            "pos": {
                "line": 757,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 18 * x ^ 4 + 14 * x ^ 3 + 8 * x ^ 2 + 13 * x + 11) (Icc 0 1)",
            "endPos": {
                "line": 757,
                "column": 61
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 372,
            "pos": {
                "line": 757,
                "column": 51
            },
            "goals": "\u22a2 ?m.1279589 \u2264 0",
            "endPos": {
                "line": 757,
                "column": 59
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat"
            ],
            "tactic": "exact\n  MonotoneOn.of_deriv_nonneg\n    (by\n      intro x hx\n      simp\n      nlinarith [sq_nonneg x, sq_nonneg (x + 1 / 3), sq_nonneg (x + 2 / 3), sq_nonneg (x + 1), sq_nonneg (x + 4 / 3),\n        sq_nonneg (x + 5 / 3), sq_nonneg (x + 2), sq_nonneg (x + 7 / 3), sq_nonneg (x + 8 / 3), sq_nonneg (x + 3),\n        sq_nonneg (x + 9 / 3), sq_nonneg (x + 10 / 3)])\n    (by\n      intro x hx\n      simp\n      nlinarith [sq_nonneg x, sq_nonneg (x + 1 / 3), sq_nonneg (x + 2 / 3), sq_nonneg (x + 1), sq_nonneg (x + 4 / 3),\n        sq_nonneg (x + 5 / 3), sq_nonneg (x + 2), sq_nonneg (x + 7 / 3), sq_nonneg (x + 8 / 3), sq_nonneg (x + 3),\n        sq_nonneg (x + 9 / 3), sq_nonneg (x + 10 / 3)])",
            "proofState": 373,
            "pos": {
                "line": 758,
                "column": 2
            },
            "goals": "\u22a2 \u211d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 4 + 14 * x ^ 3 + 8 * x ^ 2 + 13 * x + 11) (Icc ?m.1279589 1)",
            "endPos": {
                "line": 775,
                "column": 9
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 374,
            "pos": {
                "line": 778,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) (Icc 0 1)",
            "endPos": {
                "line": 778,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx",
            "proofState": 375,
            "pos": {
                "line": 779,
                "column": 2
            },
            "goals": "case h\n\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) ?s\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 779,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have h1 : 0 \u2264 x := by exact hx.1",
            "proofState": 376,
            "pos": {
                "line": 780,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) x \u2264\n          (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) b\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 780,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real.instLE",
                "Real",
                "Real.instZero",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "Zero.toOfNat0",
                "OfNat.ofNat"
            ],
            "tactic": "exact hx.1",
            "proofState": 377,
            "pos": {
                "line": 780,
                "column": 24
            },
            "goals": "x : \u211d\nhx : x \u2208 ?s\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 780,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Real.instLE",
                "Real",
                "HMul.hMul",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "instOfNatNat",
                "LE.le",
                "Real.instAdd",
                "Real.instOne",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "One.toOfNat1",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "letFun",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "have h2 : x \u2264 1 := by exact hx.2",
            "proofState": 378,
            "pos": {
                "line": 781,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\nh1 : 0 \u2264 x\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) x \u2264\n          (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) b\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 781,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "Real.instLE",
                "Real",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Real.instOne",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "One.toOfNat1",
                "Lean.Name",
                "OfNat.ofNat"
            ],
            "tactic": "exact hx.2",
            "proofState": 379,
            "pos": {
                "line": 781,
                "column": 24
            },
            "goals": "x : \u211d\nhx : x \u2208 ?s\nh1 : 0 \u2264 x\n\u22a2 x \u2264 1",
            "endPos": {
                "line": 781,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [pow_nonneg h1 7, pow_nonneg h1 6, pow_nonneg h1 4, pow_nonneg h1 3]",
            "proofState": 380,
            "pos": {
                "line": 782,
                "column": 2
            },
            "goals": "case h\nx : \u211d\nhx : x \u2208 ?s\nh1 : 0 \u2264 x\nh2 : x \u2264 1\n\u22a2 \u2200 \u2983b : \u211d\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) x \u2264\n          (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) b\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\ncase s\n\u22a2 Set \u211d",
            "endPos": {
                "line": 782,
                "column": 80
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 381,
            "pos": {
                "line": 785,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) (Icc 0 1)",
            "endPos": {
                "line": 785,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "LE.le",
                "_private.Mathlib.Order.Interval.Set.Defs.0._proof_4",
                "Real.instOne",
                "And",
                "Set.Icc",
                "One.toOfNat1",
                "Zero.toOfNat0",
                "OfNat.ofNat",
                "Set.instMembership",
                "Real.instPreorder",
                "Set"
            ],
            "tactic": "norm_num at hx hy",
            "proofState": 382,
            "pos": {
                "line": 786,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) x \u2264\n    (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) y",
            "endPos": {
                "line": 786,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "Real",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Real.instAddMonoid",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "AddGroupWithOne.toAddMonoidWithOne",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "Real.instRing",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "Real.instAdd",
                "AddMonoidWithOne.toOne",
                "Real.instMonoid",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Real.instMul",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "Ring.toAddGroupWithOne",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Real.instCommSemiring",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "ring_nf",
            "proofState": 383,
            "pos": {
                "line": 787,
                "column": 2
            },
            "goals": "x y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 1\nhy : 0 \u2264 y \u2227 y \u2264 1\n\u22a2 (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) x \u2264\n    (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) y",
            "endPos": {
                "line": 787,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x - 1), sq_nonneg (y - 1), sq_nonneg (x + 1),\n  sq_nonneg (y + 1)]",
            "proofState": 384,
            "pos": {
                "line": 788,
                "column": 2
            },
            "goals": "x y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 1\nhy : 0 \u2264 y \u2227 y \u2264 1\n\u22a2 10 + x * 2 + x ^ 2 * 6 + x ^ 5 * 12 + x ^ 6 * 17 + x ^ 7 * 5 \u2264\n    10 + y * 2 + y ^ 2 * 6 + y ^ 5 * 12 + y ^ 6 * 17 + y ^ 7 * 5",
            "endPos": {
                "line": 789,
                "column": 41
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 385,
            "pos": {
                "line": 792,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) (Icc 0 6)",
            "endPos": {
                "line": 792,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y),\n  sq_nonneg (x ^ 2 - 2 * x * y + y ^ 2)]",
            "proofState": 386,
            "pos": {
                "line": 793,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\n\u22a2 (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) x \u2264 (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) y",
            "endPos": {
                "line": 793,
                "column": 124
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 387,
            "pos": {
                "line": 796,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) (Icc 0 8)",
            "endPos": {
                "line": 796,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 388,
            "pos": {
                "line": 797,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nhxy : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) x \u2264\n    (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) y",
            "endPos": {
                "line": 797,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x ^ 3 - x ^ 2 * y),\n  sq_nonneg (x ^ 2 * y - x * y ^ 2), sq_nonneg (x * y ^ 2 - y ^ 3)]",
            "proofState": 389,
            "pos": {
                "line": 798,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 8\nhy : 0 \u2264 y \u2227 y \u2264 8\n\u22a2 (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) x \u2264\n    (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) y",
            "endPos": {
                "line": 799,
                "column": 100
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 390,
            "pos": {
                "line": 802,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) (Icc 0 5)",
            "endPos": {
                "line": 802,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Real",
                "Real.instZero",
                "Preorder.toLE",
                "Membership.mem",
                "Eq.mp",
                "instOfNatNat",
                "LE.le",
                "And",
                "Set.Icc",
                "instNatAtLeastTwo",
                "Nat",
                "Zero.toOfNat0",
                "_private.0._proof_1",
                "OfNat.ofNat",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "Real.instNatCast",
                "Set"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 391,
            "pos": {
                "line": 803,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 5\ny : \u211d\nhy : y \u2208 Icc 0 5\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) x \u2264 (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) y",
            "endPos": {
                "line": 803,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3), sq_nonneg (x ^ 2), sq_nonneg (y ^ 3), sq_nonneg (y ^ 2), sq_nonneg (x ^ 3 + x ^ 2),\n  sq_nonneg (y ^ 3 + y ^ 2)]",
            "proofState": 392,
            "pos": {
                "line": 804,
                "column": 2
            },
            "goals": "x y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 5\nhy : 0 \u2264 y \u2227 y \u2264 5\n\u22a2 (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) x \u2264 (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) y",
            "endPos": {
                "line": 805,
                "column": 57
            }
        },
        {
            "usedConstants": [
                "Real",
                "HMul.hMul",
                "Set.Ici",
                "Real.instZero",
                "Monoid.toNatPow",
                "instOfNatNat",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "Set.Icc",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "Zero.toOfNat0",
                "instHPow",
                "OfNat.ofNat",
                "instOfNatAtLeastTwo",
                "Set.Icc_subset_Ici_self",
                "Real.instPreorder",
                "MonotoneOn.mono",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 393,
            "pos": {
                "line": 808,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 14 * x ^ 7 + 15 * x ^ 5 + 5 * x ^ 4 + 4 * x ^ 3) (Icc 0 6)",
            "endPos": {
                "line": 808,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 394,
            "pos": {
                "line": 809,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 14 * x ^ 7 + 15 * x ^ 5 + 5 * x ^ 4 + 4 * x ^ 3) (Ici 0)",
            "endPos": {
                "line": 809,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
                "Eq.mpr",
                "Real",
                "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
                "HMul.hMul",
                "congrArg",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instOfNatNat",
                "LE.le",
                "NormedCommRing.toNonUnitalNormedCommRing",
                "Real.instAdd",
                "Real.instMonoid",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Real.normedCommRing",
                "HAdd.hAdd",
                "Nat",
                "Real.instMul",
                "NonUnitalNonAssocCommSemiring.toCommMagma",
                "congr",
                "mul_comm",
                "instHPow",
                "NonUnitalNormedCommRing.toNonUnitalCommRing",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Real.instPreorder",
                "instHMul",
                "Real.instNatCast"
            ],
            "tactic": "simp only [mul_comm, mul_left_comm, mul_assoc, mul_add]",
            "proofState": 395,
            "pos": {
                "line": 810,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 (fun x => 14 * x ^ 7 + 15 * x ^ 5 + 5 * x ^ 4 + 4 * x ^ 3) x \u2264\n    (fun x => 14 * x ^ 7 + 15 * x ^ 5 + 5 * x ^ 4 + 4 * x ^ 3) y",
            "endPos": {
                "line": 810,
                "column": 57
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 396,
            "pos": {
                "line": 811,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\n\u22a2 x ^ 7 * 14 + x ^ 5 * 15 + x ^ 4 * 5 + x ^ 3 * 4 \u2264 y ^ 7 * 14 + y ^ 5 * 15 + y ^ 4 * 5 + y ^ 3 * 4",
            "endPos": {
                "line": 811,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Real"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 397,
            "pos": {
                "line": 814,
                "column": 2
            },
            "goals": "\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) (Icc 0 6)",
            "endPos": {
                "line": 814,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "have h := mvt_on_Icc (fun x \u21a6 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) hx hy hxy",
            "proofState": 398,
            "pos": {
                "line": 815,
                "column": 2
            },
            "goals": "x : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\n\u22a2 (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) x \u2264\n    (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) y",
            "endPos": {
                "line": 815,
                "column": 106
            }
        }
    ],
    "messages": [
        {
            "severity": "error",
            "pos": {
                "line": 7,
                "column": 2
            },
            "endPos": {
                "line": 8,
                "column": 32
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 4\nhy : 0 \u2264 y \u2227 y \u2264 4\na\u271d :\n  (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) x >\n    (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 14,
                "column": 4
            },
            "endPos": {
                "line": 14,
                "column": 68
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d : x ^ 6 * 15 + x ^ 4 * 6 + x ^ 3 * 4 > y ^ 6 * 15 + y ^ 4 * 6 + y ^ 3 * 4\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 15,
                "column": 34
            },
            "endPos": {
                "line": 15,
                "column": 45
            },
            "data": "unsolved goals\n\u22a2 9 \u2264 ?m.24796"
        },
        {
            "severity": "error",
            "pos": {
                "line": 10,
                "column": 86
            },
            "endPos": {
                "line": 15,
                "column": 46
            },
            "data": "unsolved goals\ncase h'\n\u22a2 Icc 0 9 \u2286 Icc 0 ?m.24796"
        },
        {
            "severity": "error",
            "pos": {
                "line": 21,
                "column": 2
            },
            "endPos": {
                "line": 21,
                "column": 63
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\na\u271d : x ^ 3 * 16 + x ^ 2 * 17 + x * 7 + 6 > y ^ 3 * 16 + y ^ 2 * 17 + y * 7 + 6\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 26,
                "column": 2
            },
            "endPos": {
                "line": 26,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 38,
                "column": 2
            },
            "endPos": {
                "line": 38,
                "column": 50
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : y \u2264 3\na\u271d : (fun x => 17 * x ^ 7 + 3 * x ^ 2) x > (fun x => 17 * x ^ 7 + 3 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 44,
                "column": 2
            },
            "endPos": {
                "line": 45,
                "column": 49
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\na\u271d :\n  x * 19 + x ^ 2 * 8 + x ^ 3 * 15 + x ^ 4 * 19 + x ^ 5 * 8 + x ^ 6 * 13 + x ^ 7 * 5 >\n    y * 19 + y ^ 2 * 8 + y ^ 3 * 15 + y ^ 4 * 19 + y ^ 5 * 8 + y ^ 6 * 13 + y ^ 7 * 5\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 49,
                "column": 88
            },
            "endPos": {
                "line": 49,
                "column": 97
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\na\u271d : 0 > 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 50,
                "column": 88
            },
            "endPos": {
                "line": 50,
                "column": 97
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\na\u271d : 0 > 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 52,
                "column": 4
            },
            "endPos": {
                "line": 53,
                "column": 105
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\na\u271d : 0 > 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 54,
                "column": 2
            },
            "endPos": {
                "line": 55,
                "column": 103
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\nh\u2083 : 0 \u2264 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20\na\u271d :\n  (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x >\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 59,
                "column": 2
            },
            "endPos": {
                "line": 59,
                "column": 41
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 66,
                "column": 2
            },
            "endPos": {
                "line": 66,
                "column": 74
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 8\ny : \u211d\nhy : y \u2208 Icc 0 8\nhxy : x \u2264 y\na\u271d :\n  12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2 >\n    12 * y ^ 7 + 4 * y ^ 6 + 5 * y ^ 5 + 20 * y ^ 4 + 19 * y ^ 3 + 4 * y ^ 2\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 69,
                "column": 8
            },
            "endPos": {
                "line": 69,
                "column": 43
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  MonotoneOn\nhas type\n  (?m.148102 \u2192 ?m.148103) \u2192 Set ?m.148102 \u2192 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 70,
                "column": 2
            },
            "endPos": {
                "line": 70,
                "column": 12
            },
            "data": "no goals to be solved"
        },
        {
            "severity": "error",
            "pos": {
                "line": 85,
                "column": 2
            },
            "endPos": {
                "line": 85,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 91,
                "column": 15
            },
            "endPos": {
                "line": 91,
                "column": 32
            },
            "data": "typeclass instance problem is stuck, it is often due to metavariables\n  AddLeftStrictMono ?m.164939"
        },
        {
            "severity": "error",
            "pos": {
                "line": 90,
                "column": 34
            },
            "endPos": {
                "line": 92,
                "column": 113
            },
            "data": "application type mismatch\n  monotone_iff_forall_lt.mpr fun x x_1 y x_2 h => ?m.162003\nargument\n  fun x x_1 y x_2 h => ?m.162003\nhas type\n  (x x_1 : ?m.164957) \u2192\n    (y : x < x_1) \u2192\n      (x_2 : ?m.162004 x x_1 y) \u2192\n        (h : ?m.162005 x x_1 y x_2) \u2192\n          ?m.162006 x x_1 y x_2 h : Sort (imax (?u.164949 + 1) (?u.164949 + 1) ?u.161995 ?u.161998 ?u.162001)\nbut is expected to have type\n  \u2200 \u2983a b : ?m.164957\u2984, a < b \u2192 ?m.161970 a \u2264 ?m.161970 b : Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 106,
                "column": 2
            },
            "endPos": {
                "line": 106,
                "column": 96
            },
            "data": "linarith failed to find a contradiction\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 111,
                "column": 2
            },
            "endPos": {
                "line": 112,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 8\nhy : 0 \u2264 y \u2227 y \u2264 8\na\u271d : 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x > 16 * y ^ 6 + 12 * y ^ 5 + 6 * y ^ 3 + 15 * y ^ 2 + 8 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 117,
                "column": 2
            },
            "endPos": {
                "line": 119,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 10\nhy : 0 \u2264 y \u2227 y \u2264 10\na\u271d :\n  (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) x >\n    (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 126,
                "column": 2
            },
            "endPos": {
                "line": 127,
                "column": 57
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\na\u271d : x ^ 6 * 8 + x ^ 5 * 8 + x ^ 2 * 15 > y ^ 6 * 8 + y ^ 5 * 8 + y ^ 2 * 15\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 131,
                "column": 2
            },
            "endPos": {
                "line": 132,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 10\ny : \u211d\nhy : y \u2208 Icc 0 10\nhxy : x \u2264 y\na\u271d : (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) x > (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 135,
                "column": 2
            },
            "endPos": {
                "line": 135,
                "column": 40
            },
            "data": "type mismatch\n  monotoneOn_of_deriv_nonneg ?m.250702 ?m.250704\nhas type\n  DifferentiableOn \u211d ?m.250703 (interior ?m.250701) \u2192\n    (\u2200 x \u2208 interior ?m.250701, 0 \u2264 deriv ?m.250703 x) \u2192 MonotoneOn ?m.250703 ?m.250701 : Prop\nbut is expected to have type\n  MonotoneOn (fun x => 16 * x ^ 7 + 11 * x ^ 6 + 2 * x ^ 4 + 19 * x ^ 2) (Icc 0 7) : Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 146,
                "column": 2
            },
            "endPos": {
                "line": 146,
                "column": 120
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 2\nhy : 0 \u2264 y \u2227 y \u2264 2\na\u271d :\n  (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) x >\n    (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 151,
                "column": 2
            },
            "endPos": {
                "line": 151,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 157,
                "column": 34
            },
            "endPos": {
                "line": 157,
                "column": 63
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\na\u271d : 2 * x ^ 3 + 11 * x > 2 * y ^ 3 + 11 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 164,
                "column": 2
            },
            "endPos": {
                "line": 164,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 174,
                "column": 2
            },
            "endPos": {
                "line": 174,
                "column": 50
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nh : x \u2264 y\na\u271d : 12 + x * 19 + x ^ 2 * 3 + x ^ 4 * 9 > 12 + y * 19 + y ^ 2 * 3 + y ^ 4 * 9\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 179,
                "column": 2
            },
            "endPos": {
                "line": 179,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 5\ny : \u211d\nhy : y \u2208 Icc 0 5\nhxy : x \u2264 y\na\u271d : x ^ 7 * 2 + x ^ 6 * 14 + x ^ 3 * 3 + x ^ 2 * 20 + x * 13 > y ^ 7 * 2 + y ^ 6 * 14 + y ^ 3 * 3 + y ^ 2 * 20 + y * 13\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 184,
                "column": 2
            },
            "endPos": {
                "line": 184,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 189,
                "column": 2
            },
            "endPos": {
                "line": 189,
                "column": 73
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\na\u271d : (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) x > (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 201,
                "column": 2
            },
            "endPos": {
                "line": 201,
                "column": 187
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : 0 \u2264 y - x\na\u271d : x ^ 6 * 8 + x ^ 5 * 11 + x * 19 + 10 > y ^ 6 * 8 + y ^ 5 * 11 + y * 19 + 10\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 208,
                "column": 2
            },
            "endPos": {
                "line": 208,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx' : 0 \u2264 x \u2227 x \u2264 8\nhy' : 0 \u2264 y \u2227 y \u2264 8\na\u271d : 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x > 15 * y ^ 6 + 18 * y ^ 5 + 9 * y ^ 3 + 4 * y ^ 2 + 3 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 211,
                "column": 49
            },
            "endPos": {
                "line": 211,
                "column": 60
            },
            "data": "unsolved goals\n\u22a2 5 \u2264 ?m.357800"
        },
        {
            "severity": "error",
            "pos": {
                "line": 215,
                "column": 74
            },
            "endPos": {
                "line": 215,
                "column": 85
            },
            "data": "unsolved goals\n\u22a2 0 \u2264 ?m.372914"
        },
        {
            "severity": "error",
            "pos": {
                "line": 216,
                "column": 44
            },
            "endPos": {
                "line": 216,
                "column": 55
            },
            "data": "unsolved goals\n\u22a2 0 \u2264 ?m.388017"
        },
        {
            "severity": "error",
            "pos": {
                "line": 217,
                "column": 44
            },
            "endPos": {
                "line": 217,
                "column": 55
            },
            "data": "unsolved goals\n\u22a2 0 \u2264 ?m.403660"
        },
        {
            "severity": "error",
            "pos": {
                "line": 218,
                "column": 42
            },
            "endPos": {
                "line": 218,
                "column": 53
            },
            "data": "unsolved goals\n\u22a2 0 \u2264 ?m.419303"
        },
        {
            "severity": "error",
            "pos": {
                "line": 219,
                "column": 40
            },
            "endPos": {
                "line": 219,
                "column": 51
            },
            "data": "unsolved goals\n\u22a2 0 \u2264 ?m.434946"
        },
        {
            "severity": "error",
            "pos": {
                "line": 222,
                "column": 26
            },
            "endPos": {
                "line": 222,
                "column": 46
            },
            "data": "application type mismatch\n  MonotoneOn.mono ?m.467664 Icc_subset_Icc_right\nargument\n  Icc_subset_Icc_right\nhas type\n  ?m.467669 \u2264 ?m.467670 \u2192 Icc ?m.467668 ?m.467669 \u2286 Icc ?m.467668 ?m.467670 : Prop\nbut is expected to have type\n  ?m.467660 \u2286 ?m.467659 : Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 224,
                "column": 4
            },
            "endPos": {
                "line": 224,
                "column": 36
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 223,
                "column": 2
            },
            "endPos": {
                "line": 225,
                "column": 87
            },
            "data": "type mismatch\n  fun x hx y hy h => ?m.469103\nhas type\n  (x : \u211d) \u2192\n    (hx : ?m.469104 x) \u2192\n      (y : ?m.469105 x hx) \u2192\n        (hy : ?m.469106 x hx y) \u2192\n          (h : ?m.469107 x hx y hy) \u2192\n            ?m.469108 x hx y hy h : Sort (imax 1 ?u.469089 ?u.469092 ?u.469095 ?u.469098 ?u.469101)\nbut is expected to have type\n  Set \u211d : Type"
        },
        {
            "severity": "error",
            "pos": {
                "line": 229,
                "column": 2
            },
            "endPos": {
                "line": 230,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 4\ny : \u211d\nhy : y \u2208 Icc 0 4\nh : x \u2264 y\na\u271d :\n  (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) x >\n    (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 235,
                "column": 4
            },
            "endPos": {
                "line": 235,
                "column": 55
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 241,
                "column": 50
            },
            "endPos": {
                "line": 241,
                "column": 61
            },
            "data": "unsolved goals\n\u22a2 ?m.502342 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 244,
                "column": 2
            },
            "endPos": {
                "line": 251,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase refine'_1.a\nx : \u211d\nhx : x \u2208 Icc ?refine'_2 3\ny : \u211d\nhy : y \u2208 Icc ?refine'_2 3\nhxy : x \u2264 y\na\u271d :\n  4 * x ^ 7 + (8 * x ^ 3 + (10 * x ^ 6 + (15 * x ^ 2 + (20 * x ^ 5 + 19 * x)))) >\n    4 * y ^ 7 + (8 * y ^ 3 + (10 * y ^ 6 + (15 * y ^ 2 + (20 * y ^ 5 + 19 * y))))\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 256,
                "column": 2
            },
            "endPos": {
                "line": 256,
                "column": 76
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nh : x \u2264 y\na\u271d : 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x > 8 * y ^ 7 + 17 * y ^ 6 + 10 * y ^ 2 + 12 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 262,
                "column": 2
            },
            "endPos": {
                "line": 262,
                "column": 74
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nh : x \u2264 y\na\u271d : 14 + x * 8 + x ^ 7 * 11 > 14 + y * 8 + y ^ 7 * 11\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 267,
                "column": 2
            },
            "endPos": {
                "line": 268,
                "column": 54
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\na\u271d : (fun x => 6 * x ^ 4 + 20 * x ^ 3 + 5 * x ^ 2 + 19 * x) x > (fun x => 6 * x ^ 4 + 20 * x ^ 3 + 5 * x ^ 2 + 19 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 273,
                "column": 41
            },
            "endPos": {
                "line": 273,
                "column": 53
            },
            "data": "unknown identifier 'true_and_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 275,
                "column": 4
            },
            "endPos": {
                "line": 275,
                "column": 141
            },
            "data": "linarith failed to find a contradiction\nx : \u211d\nhx : 0 \u2264 x \u2227 x \u2264 4\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 276,
                "column": 2
            },
            "endPos": {
                "line": 276,
                "column": 22
            },
            "data": "tactic 'apply' failed, failed to unify\n  ?a \u2264 ?b \u2192 (fun x => ?f x + ?g x) ?a \u2264 (fun x => ?f x + ?g x) ?b\nwith\n  Set \u211d\n\u22a2 Set \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 307,
                "column": 16
            },
            "endPos": {
                "line": 307,
                "column": 17
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 307,
                "column": 34
            },
            "endPos": {
                "line": 307,
                "column": 36
            },
            "data": "unknown identifier 'hx'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 308,
                "column": 34
            },
            "endPos": {
                "line": 308,
                "column": 36
            },
            "data": "unknown identifier 'hx'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 309,
                "column": 20
            },
            "endPos": {
                "line": 309,
                "column": 21
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 309,
                "column": 32
            },
            "endPos": {
                "line": 309,
                "column": 33
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 309,
                "column": 45
            },
            "endPos": {
                "line": 309,
                "column": 46
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 309,
                "column": 57
            },
            "endPos": {
                "line": 309,
                "column": 58
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 310,
                "column": 30
            },
            "endPos": {
                "line": 310,
                "column": 31
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 313,
                "column": 21
            },
            "endPos": {
                "line": 313,
                "column": 22
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 313,
                "column": 33
            },
            "endPos": {
                "line": 313,
                "column": 34
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 313,
                "column": 46
            },
            "endPos": {
                "line": 313,
                "column": 47
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 313,
                "column": 58
            },
            "endPos": {
                "line": 313,
                "column": 59
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 315,
                "column": 27
            },
            "endPos": {
                "line": 315,
                "column": 28
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 320,
                "column": 31
            },
            "endPos": {
                "line": 320,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  x \u2208 Ici 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 320,
                "column": 31
            },
            "endPos": {
                "line": 320,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  (Ici 0).Mem x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 320,
                "column": 31
            },
            "endPos": {
                "line": 320,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  Ici 0 x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 320,
                "column": 31
            },
            "endPos": {
                "line": 320,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  {x | 0 \u2264 x} x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 320,
                "column": 31
            },
            "endPos": {
                "line": 320,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  0 \u2264 x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 320,
                "column": 31
            },
            "endPos": {
                "line": 320,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  0 \u2264 x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 320,
                "column": 31
            },
            "endPos": {
                "line": 320,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  Real.le\u271d 0 x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 321,
                "column": 31
            },
            "endPos": {
                "line": 321,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hy\nhas type\n  y \u2208 Ici 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 321,
                "column": 31
            },
            "endPos": {
                "line": 321,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hy\nhas type\n  (Ici 0).Mem y"
        },
        {
            "severity": "error",
            "pos": {
                "line": 321,
                "column": 31
            },
            "endPos": {
                "line": 321,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hy\nhas type\n  Ici 0 y"
        },
        {
            "severity": "error",
            "pos": {
                "line": 321,
                "column": 31
            },
            "endPos": {
                "line": 321,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hy\nhas type\n  {x | 0 \u2264 x} y"
        },
        {
            "severity": "error",
            "pos": {
                "line": 321,
                "column": 31
            },
            "endPos": {
                "line": 321,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hy\nhas type\n  0 \u2264 y"
        },
        {
            "severity": "error",
            "pos": {
                "line": 321,
                "column": 31
            },
            "endPos": {
                "line": 321,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hy\nhas type\n  0 \u2264 y"
        },
        {
            "severity": "error",
            "pos": {
                "line": 321,
                "column": 31
            },
            "endPos": {
                "line": 321,
                "column": 35
            },
            "data": "invalid projection, structure expected\n  hy\nhas type\n  Real.le\u271d 0 y"
        },
        {
            "severity": "error",
            "pos": {
                "line": 322,
                "column": 2
            },
            "endPos": {
                "line": 323,
                "column": 68
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\na\u271d : (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) x > (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 328,
                "column": 8
            },
            "endPos": {
                "line": 328,
                "column": 28
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 329,
                "column": 8
            },
            "endPos": {
                "line": 329,
                "column": 22
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  MonotoneOn\nhas type\n  (?m.681623 \u2192 ?m.681624) \u2192 Set ?m.681623 \u2192 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 330,
                "column": 2
            },
            "endPos": {
                "line": 330,
                "column": 21
            },
            "data": "no goals to be solved"
        },
        {
            "severity": "error",
            "pos": {
                "line": 340,
                "column": 29
            },
            "endPos": {
                "line": 340,
                "column": 40
            },
            "data": "unsolved goals\n\u22a2 ?m.689882 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 338,
                "column": 112
            },
            "endPos": {
                "line": 343,
                "column": 100
            },
            "data": "unsolved goals\n\u22a2 Icc 0 4 \u2286 Icc ?m.689882 4\n\n\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 6 * x ^ 5 + 3 * x ^ 4 + 6 * x ^ 3 + 16 * x + 14) (Icc ?m.689882 4)"
        },
        {
            "severity": "error",
            "pos": {
                "line": 348,
                "column": 2
            },
            "endPos": {
                "line": 348,
                "column": 63
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nh : x \u2264 y\na\u271d :\n  (fun x => 12 * x ^ 7 + 15 * x ^ 6 + 20 * x ^ 5 + 17 * x ^ 4 + 4 * x ^ 2) x >\n    (fun x => 12 * x ^ 7 + 15 * x ^ 6 + 20 * x ^ 5 + 17 * x ^ 4 + 4 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 357,
                "column": 2
            },
            "endPos": {
                "line": 357,
                "column": 32
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 361,
                "column": 76
            },
            "endPos": {
                "line": 361,
                "column": 87
            },
            "data": "unsolved goals\n\u22a2 ?m.715333 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 362,
                "column": 24
            },
            "endPos": {
                "line": 362,
                "column": 25
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 366,
                "column": 26
            },
            "endPos": {
                "line": 366,
                "column": 45
            },
            "data": "application type mismatch\n  MonotoneOn.mono ?m.725389 Icc_subset_Icc_left\nargument\n  Icc_subset_Icc_left\nhas type\n  ?m.725393 \u2264 ?m.725394 \u2192 Icc ?m.725394 ?m.725395 \u2286 Icc ?m.725393 ?m.725395 : Prop\nbut is expected to have type\n  ?m.725385 \u2286 ?m.725384 : Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 367,
                "column": 10
            },
            "endPos": {
                "line": 367,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx : \u211d\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 379,
                "column": 12
            },
            "endPos": {
                "line": 379,
                "column": 32
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 379,
                "column": 12
            },
            "endPos": {
                "line": 379,
                "column": 32
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 391,
                "column": 15
            },
            "endPos": {
                "line": 391,
                "column": 29
            },
            "data": "typeclass instance problem is stuck, it is often due to metavariables\n  PosMulStrictMono ?m.753398"
        },
        {
            "severity": "error",
            "pos": {
                "line": 393,
                "column": 23
            },
            "endPos": {
                "line": 393,
                "column": 27
            },
            "data": "application type mismatch\n  pow_pos hy.left\nargument\n  hy.left\nhas type\n  0 \u2264 y : Prop\nbut is expected to have type\n  0 < ?m.762317 : Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 394,
                "column": 36
            },
            "endPos": {
                "line": 394,
                "column": 39
            },
            "data": "application type mismatch\n  pow_pos hxy\nargument\n  hxy\nhas type\n  x \u2264 y : Prop\nbut is expected to have type\n  0 < ?m.768551 : Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 401,
                "column": 2
            },
            "endPos": {
                "line": 404,
                "column": 72
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 3\nhy : 0 \u2264 y \u2227 y \u2264 3\na\u271d :\n  x ^ 2 * 5 + x ^ 3 * 15 + x ^ 4 * 16 + x ^ 5 * 9 + x ^ 6 * 13 + x ^ 7 * 13 >\n    y ^ 2 * 5 + y ^ 3 * 15 + y ^ 4 * 16 + y ^ 5 * 9 + y ^ 6 * 13 + y ^ 7 * 13\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 409,
                "column": 2
            },
            "endPos": {
                "line": 409,
                "column": 16
            },
            "data": "ring_nf made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 415,
                "column": 18
            },
            "endPos": {
                "line": 415,
                "column": 38
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 415,
                "column": 18
            },
            "endPos": {
                "line": 415,
                "column": 38
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 425,
                "column": 2
            },
            "endPos": {
                "line": 426,
                "column": 68
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 5\ny : \u211d\nhy : y \u2208 Icc 0 5\nh : x \u2264 y\na\u271d : (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) x > (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 433,
                "column": 12
            },
            "endPos": {
                "line": 433,
                "column": 15
            },
            "data": "tactic 'introN' failed, insufficient number of binders\ncase h\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhx0 : x \u2264 y\n\u22a2 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x \u2264 18 * y ^ 7 + 10 * y ^ 5 + 13 * y ^ 4 + 3 * y"
        },
        {
            "severity": "error",
            "pos": {
                "line": 439,
                "column": 2
            },
            "endPos": {
                "line": 439,
                "column": 104
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d :\n  (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) x >\n    (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 445,
                "column": 26
            },
            "endPos": {
                "line": 445,
                "column": 27
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 442,
                "column": 91
            },
            "endPos": {
                "line": 446,
                "column": 62
            },
            "data": "unsolved goals\ncase h'\n\u22a2 Icc 0 6 \u2286 ?s\n\ncase s\n\u22a2 Set \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 451,
                "column": 33
            },
            "endPos": {
                "line": 451,
                "column": 34
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 451,
                "column": 33
            },
            "endPos": {
                "line": 451,
                "column": 34
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 458,
                "column": 2
            },
            "endPos": {
                "line": 458,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d :\n  19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x > 19 * y ^ 7 + 15 * y ^ 5 + 15 * y ^ 3 + 15 * y ^ 2 + 7 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 466,
                "column": 4
            },
            "endPos": {
                "line": 466,
                "column": 7
            },
            "data": "unknown identifier 'MVT'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 460,
                "column": 132
            },
            "endPos": {
                "line": 470,
                "column": 33
            },
            "data": "unsolved goals\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 2\nhy : 0 \u2264 y \u2227 y \u2264 2\nh :\n  (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) x >\n    (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) y\n\u22a2 False"
        },
        {
            "severity": "error",
            "pos": {
                "line": 473,
                "column": 48
            },
            "endPos": {
                "line": 473,
                "column": 59
            },
            "data": "unsolved goals\n\u22a2 ?m.899887 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 474,
                "column": 2
            },
            "endPos": {
                "line": 474,
                "column": 22
            },
            "data": "tactic 'apply' failed, failed to unify\n  (fun x => ?f x + ?g x) ?a \u2264 (fun x => ?f x + ?g x) ?b\nwith\n  \u211d\n\u22a2 \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 484,
                "column": 2
            },
            "endPos": {
                "line": 484,
                "column": 49
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 491,
                "column": 48
            },
            "endPos": {
                "line": 491,
                "column": 59
            },
            "data": "unsolved goals\n\u22a2 ?m.914333 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 492,
                "column": 8
            },
            "endPos": {
                "line": 492,
                "column": 9
            },
            "data": "tactic 'introN' failed, insufficient number of binders\n\u22a2 \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 497,
                "column": 46
            },
            "endPos": {
                "line": 497,
                "column": 58
            },
            "data": "unknown identifier 'true_and_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 498,
                "column": 59
            },
            "endPos": {
                "line": 498,
                "column": 71
            },
            "data": "unknown identifier 'zero_le_five'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 498,
                "column": 73
            },
            "endPos": {
                "line": 498,
                "column": 84
            },
            "data": "unknown identifier 'zero_le_six'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 499,
                "column": 4
            },
            "endPos": {
                "line": 499,
                "column": 17
            },
            "data": "unknown identifier 'zero_le_seven'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 499,
                "column": 19
            },
            "endPos": {
                "line": 499,
                "column": 32
            },
            "data": "unknown identifier 'zero_le_eight'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 499,
                "column": 34
            },
            "endPos": {
                "line": 499,
                "column": 46
            },
            "data": "unknown identifier 'zero_le_nine'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 499,
                "column": 48
            },
            "endPos": {
                "line": 499,
                "column": 59
            },
            "data": "unknown identifier 'zero_le_ten'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 500,
                "column": 2
            },
            "endPos": {
                "line": 500,
                "column": 31
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 10\ny : \u211d\nhy : y \u2208 Icc 0 10\nh : x \u2264 y\na\u271d : 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7 > 15 * y ^ 6 + 5 * y ^ 3 + 16 * y ^ 2 + 7\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 503,
                "column": 2
            },
            "endPos": {
                "line": 503,
                "column": 28
            },
            "data": "tactic 'apply' failed, failed to unify\n  MonotoneOn (fun x => ?a + ?f x) ?s\nwith\n  MonotoneOn (fun x => 16 * x ^ 7 + 20 * x ^ 4 + 4 * x ^ 2 + 18 * x + 15) (Icc 0 5)\n\u22a2 MonotoneOn (fun x => 16 * x ^ 7 + 20 * x ^ 4 + 4 * x ^ 2 + 18 * x + 15) (Icc 0 5)"
        },
        {
            "severity": "error",
            "pos": {
                "line": 517,
                "column": 4
            },
            "endPos": {
                "line": 517,
                "column": 98
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nhxy : x \u2264 y\na\u271d : x ^ 7 * 2 + x ^ 5 * 19 + x ^ 3 * 4 + x * 20 > y ^ 7 * 2 + y ^ 5 * 19 + y ^ 3 * 4 + y * 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 522,
                "column": 2
            },
            "endPos": {
                "line": 522,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d :\n  (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) x >\n    (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 529,
                "column": 2
            },
            "endPos": {
                "line": 534,
                "column": 22
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 7\nhy : 0 \u2264 y \u2227 y \u2264 7\na\u271d :\n  (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) x >\n    (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 538,
                "column": 13
            },
            "endPos": {
                "line": 538,
                "column": 14
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx : \u211d\nhx : x \u2208 Icc 0 5\n\u22a2 x \u2208 ?m.978610"
        },
        {
            "severity": "error",
            "pos": {
                "line": 548,
                "column": 2
            },
            "endPos": {
                "line": 549,
                "column": 51
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 1\nhy : 0 \u2264 y \u2227 y \u2264 1\na\u271d :\n  (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) x >\n    (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 555,
                "column": 7
            },
            "endPos": {
                "line": 555,
                "column": 81
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 556,
                "column": 7
            },
            "endPos": {
                "line": 556,
                "column": 82
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 561,
                "column": 2
            },
            "endPos": {
                "line": 561,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 9\nhy : 0 \u2264 y \u2227 y \u2264 9\na\u271d :\n  (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) x >\n    (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 564,
                "column": 49
            },
            "endPos": {
                "line": 564,
                "column": 60
            },
            "data": "unsolved goals\n\u22a2 10 \u2264 ?m.1018855"
        },
        {
            "severity": "error",
            "pos": {
                "line": 565,
                "column": 8
            },
            "endPos": {
                "line": 565,
                "column": 9
            },
            "data": "tactic 'introN' failed, insufficient number of binders\n\u22a2 \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 580,
                "column": 13
            },
            "endPos": {
                "line": 580,
                "column": 17
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  x \u2208 ?s"
        },
        {
            "severity": "error",
            "pos": {
                "line": 580,
                "column": 13
            },
            "endPos": {
                "line": 580,
                "column": 17
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  Set.Mem ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 580,
                "column": 13
            },
            "endPos": {
                "line": 580,
                "column": 17
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  hx\nhas type\n  ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 580,
                "column": 13
            },
            "endPos": {
                "line": 580,
                "column": 17
            },
            "data": "Argument passed to nlinarith has metavariables:\n  ?h"
        },
        {
            "severity": "error",
            "pos": {
                "line": 592,
                "column": 2
            },
            "endPos": {
                "line": 593,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 9\ny : \u211d\nhy : y \u2208 Icc 0 9\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : x \u2264 y\na\u271d : (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x > (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 597,
                "column": 2
            },
            "endPos": {
                "line": 597,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 1\ny : \u211d\nhy : y \u2208 Icc 0 1\nh : x \u2264 y\na\u271d :\n  (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) x >\n    (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 603,
                "column": 2
            },
            "endPos": {
                "line": 604,
                "column": 76
            },
            "data": "linarith failed to find a contradiction\ncase a.a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 5\nhy : 0 \u2264 y \u2227 y \u2264 5\na\u271d :\n  0 >\n    (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) y -\n      (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) x\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 610,
                "column": 2
            },
            "endPos": {
                "line": 610,
                "column": 104
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nh : x \u2264 y\nhx' : 0 \u2264 x \u2227 x \u2264 7\nhy' : 0 \u2264 y \u2227 y \u2264 7\na\u271d : 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14 > 7 * y ^ 6 + 7 * y ^ 4 + 5 * y ^ 2 + 14\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 614,
                "column": 2
            },
            "endPos": {
                "line": 614,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nh : x \u2264 y\na\u271d :\n  (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) x >\n    (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 619,
                "column": 4
            },
            "endPos": {
                "line": 620,
                "column": 43
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\na\u271d : 7 * x ^ 6 + 16 * x ^ 4 + 5 * x ^ 3 + 19 * x ^ 2 > 7 * y ^ 6 + 16 * y ^ 4 + 5 * y ^ 3 + 19 * y ^ 2\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 623,
                "column": 51
            },
            "endPos": {
                "line": 623,
                "column": 62
            },
            "data": "unsolved goals\n\u22a2 9 \u2264 ?m.1119116"
        },
        {
            "severity": "error",
            "pos": {
                "line": 624,
                "column": 8
            },
            "endPos": {
                "line": 624,
                "column": 9
            },
            "data": "tactic 'introN' failed, insufficient number of binders\n\u22a2 \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 631,
                "column": 12
            },
            "endPos": {
                "line": 631,
                "column": 32
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 631,
                "column": 12
            },
            "endPos": {
                "line": 631,
                "column": 32
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 640,
                "column": 26
            },
            "endPos": {
                "line": 640,
                "column": 46
            },
            "data": "application type mismatch\n  MonotoneOn.mono ?m.1134336 Icc_subset_Icc_right\nargument\n  Icc_subset_Icc_right\nhas type\n  ?m.1134341 \u2264 ?m.1134342 \u2192 Icc ?m.1134340 ?m.1134341 \u2286 Icc ?m.1134340 ?m.1134342 : Prop\nbut is expected to have type\n  ?m.1134332 \u2286 ?m.1134331 : Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 641,
                "column": 2
            },
            "endPos": {
                "line": 641,
                "column": 28
            },
            "data": "type mismatch\n  MonotoneOn.add ?m.1135770 ?m.1135771\nhas type\n  MonotoneOn (fun x => ?m.1135765 x + ?m.1135766 x) ?m.1135767 : Prop\nbut is expected to have type\n  Set \u211d : Type"
        },
        {
            "severity": "error",
            "pos": {
                "line": 652,
                "column": 2
            },
            "endPos": {
                "line": 653,
                "column": 57
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 3\ny : \u211d\nhy : y \u2208 Icc 0 3\nh : x \u2264 y\na\u271d :\n  17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3 >\n    17 * y ^ 7 + 11 * y ^ 5 + 20 * y ^ 4 + 7 * y ^ 3 + 6 * y ^ 2 + 12 * y + 3\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 658,
                "column": 2
            },
            "endPos": {
                "line": 658,
                "column": 40
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 663,
                "column": 50
            },
            "endPos": {
                "line": 663,
                "column": 61
            },
            "data": "unsolved goals\n\u22a2 ?m.1163506 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 666,
                "column": 2
            },
            "endPos": {
                "line": 666,
                "column": 96
            },
            "data": "linarith failed to find a contradiction\ncase refine'_1.a\nx y : \u211d\nhxy : x \u2264 y\nhx : ?refine'_2 \u2264 x \u2227 x \u2264 5\nhy : ?refine'_2 \u2264 y \u2227 y \u2264 5\na\u271d : (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) x > (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 671,
                "column": 54
            },
            "endPos": {
                "line": 671,
                "column": 66
            },
            "data": "unknown identifier 'true_and_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 671,
                "column": 68
            },
            "endPos": {
                "line": 671,
                "column": 80
            },
            "data": "unknown identifier 'and_true_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 672,
                "column": 4
            },
            "endPos": {
                "line": 677,
                "column": 32
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhxy : x \u2264 y\na\u271d : 10 * x ^ 6 + 9 * x ^ 5 + 14 * x ^ 4 + 3 * x ^ 2 + 17 > 10 * y ^ 6 + 9 * y ^ 5 + 14 * y ^ 4 + 3 * y ^ 2 + 17\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 680,
                "column": 48
            },
            "endPos": {
                "line": 680,
                "column": 59
            },
            "data": "unsolved goals\n\u22a2 ?m.1194572 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 681,
                "column": 8
            },
            "endPos": {
                "line": 681,
                "column": 9
            },
            "data": "tactic 'introN' failed, insufficient number of binders\n\u22a2 \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 688,
                "column": 45
            },
            "endPos": {
                "line": 688,
                "column": 56
            },
            "data": "unsolved goals\n\u22a2 ?m.1203096 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 688,
                "column": 59
            },
            "endPos": {
                "line": 688,
                "column": 70
            },
            "data": "unsolved goals\n\u22a2 10 \u2264 ?m.1203098"
        },
        {
            "severity": "error",
            "pos": {
                "line": 689,
                "column": 8
            },
            "endPos": {
                "line": 689,
                "column": 9
            },
            "data": "tactic 'introN' failed, insufficient number of binders\n\u22a2 \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 695,
                "column": 2
            },
            "endPos": {
                "line": 695,
                "column": 44
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 701,
                "column": 2
            },
            "endPos": {
                "line": 702,
                "column": 26
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\na\u271d :\n  (fun x => 3 * x ^ 7 + 13 * x ^ 6 + 18 * x ^ 5 + 15 * x ^ 4 + 9 * x ^ 3 + 17 * x ^ 2 + 6 * x) x >\n    (fun x => 3 * x ^ 7 + 13 * x ^ 6 + 18 * x ^ 5 + 15 * x ^ 4 + 9 * x ^ 3 + 17 * x ^ 2 + 6 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 707,
                "column": 2
            },
            "endPos": {
                "line": 707,
                "column": 30
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 721,
                "column": 2
            },
            "endPos": {
                "line": 722,
                "column": 76
            },
            "data": "linarith failed to find a contradiction\ncase hf.a\nx : \u211d\nhx : x \u2208 Icc 0 7\ny : \u211d\nhy : y \u2208 Icc 0 7\nhxy : x \u2264 y\na\u271d :\n  (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) x >\n    (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 738,
                "column": 4
            },
            "endPos": null,
            "data": "expected '{' or indented tactic sequence"
        },
        {
            "severity": "error",
            "pos": {
                "line": 736,
                "column": 4
            },
            "endPos": {
                "line": 736,
                "column": 87
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d : x ^ 7 * 4 + x ^ 6 * 7 + x ^ 2 * 3 + x * 8 > y ^ 7 * 4 + y ^ 6 * 7 + y ^ 2 * 3 + y * 8\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 735,
                "column": 4
            },
            "endPos": {
                "line": 735,
                "column": 50
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 731,
                "column": 97
            },
            "endPos": {
                "line": 737,
                "column": 35
            },
            "data": "unsolved goals\ncase h'\n\u22a2 Icc 0 1 \u2286 ?s\n\ncase s\n\u22a2 Set \u211d"
        },
        {
            "severity": "error",
            "pos": {
                "line": 753,
                "column": 2
            },
            "endPos": {
                "line": 754,
                "column": 84
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx : \u211d\nhx : x \u2208 ?s\ny : \u211d\nhy : y \u2208 ?s\nh : x \u2264 y\na\u271d :\n  13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20 >\n    13 * y ^ 7 + 4 * y ^ 6 + 16 * y ^ 5 + 11 * y ^ 4 + 5 * y ^ 3 + 15 * y ^ 2 + 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 757,
                "column": 48
            },
            "endPos": {
                "line": 757,
                "column": 59
            },
            "data": "unsolved goals\n\u22a2 ?m.1279589 \u2264 0"
        },
        {
            "severity": "error",
            "pos": {
                "line": 759,
                "column": 4
            },
            "endPos": {
                "line": 775,
                "column": 9
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  MonotoneOn\nhas type\n  (?m.1281115 \u2192 ?m.1281116) \u2192 Set ?m.1281115 \u2192 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 756,
                "column": 101
            },
            "endPos": {
                "line": 775,
                "column": 9
            },
            "data": "unsolved goals\n\u22a2 MonotoneOn (fun x => 18 * x ^ 4 + 14 * x ^ 3 + 8 * x ^ 2 + 13 * x + 11) (Icc sorry 1)"
        },
        {
            "severity": "error",
            "pos": {
                "line": 780,
                "column": 30
            },
            "endPos": {
                "line": 780,
                "column": 34
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  x \u2208 ?s"
        },
        {
            "severity": "error",
            "pos": {
                "line": 780,
                "column": 30
            },
            "endPos": {
                "line": 780,
                "column": 34
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  Set.Mem ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 780,
                "column": 30
            },
            "endPos": {
                "line": 780,
                "column": 34
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  hx\nhas type\n  ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 781,
                "column": 30
            },
            "endPos": {
                "line": 781,
                "column": 34
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  x \u2208 ?s"
        },
        {
            "severity": "error",
            "pos": {
                "line": 781,
                "column": 30
            },
            "endPos": {
                "line": 781,
                "column": 34
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  Set.Mem ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 781,
                "column": 30
            },
            "endPos": {
                "line": 781,
                "column": 34
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  hx\nhas type\n  ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 782,
                "column": 2
            },
            "endPos": {
                "line": 782,
                "column": 80
            },
            "data": "linarith failed to find a contradiction\ncase h\nx : \u211d\nhx : x \u2208 ?s\nh1 : 0 \u2264 x\nh2 : x \u2264 1\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 788,
                "column": 2
            },
            "endPos": {
                "line": 789,
                "column": 41
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nh : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 1\nhy : 0 \u2264 y \u2227 y \u2264 1\na\u271d :\n  10 + x * 2 + x ^ 2 * 6 + x ^ 5 * 12 + x ^ 6 * 17 + x ^ 7 * 5 >\n    10 + y * 2 + y ^ 2 * 6 + y ^ 5 * 12 + y ^ 6 * 17 + y ^ 7 * 5\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 793,
                "column": 2
            },
            "endPos": {
                "line": 793,
                "column": 124
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\na\u271d : (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) x > (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 798,
                "column": 2
            },
            "endPos": {
                "line": 799,
                "column": 100
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 8\nhy : 0 \u2264 y \u2227 y \u2264 8\na\u271d :\n  (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) x >\n    (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 804,
                "column": 2
            },
            "endPos": {
                "line": 805,
                "column": 57
            },
            "data": "linarith failed to find a contradiction\ncase a\nx y : \u211d\nhxy : x \u2264 y\nhx : 0 \u2264 x \u2227 x \u2264 5\nhy : 0 \u2264 y \u2227 y \u2264 5\na\u271d : (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) x > (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 811,
                "column": 2
            },
            "endPos": {
                "line": 811,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx : \u211d\nhx : x \u2208 Ici 0\ny : \u211d\nhy : y \u2208 Ici 0\nhxy : x \u2264 y\na\u271d : x ^ 7 * 14 + x ^ 5 * 15 + x ^ 4 * 5 + x ^ 3 * 4 > y ^ 7 * 14 + y ^ 5 * 15 + y ^ 4 * 5 + y ^ 3 * 4\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 815,
                "column": 12
            },
            "endPos": {
                "line": 815,
                "column": 22
            },
            "data": "unknown identifier 'mvt_on_Icc'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 813,
                "column": 115
            },
            "endPos": {
                "line": 817,
                "column": 9
            },
            "data": "unsolved goals\nx : \u211d\nhx : x \u2208 Icc 0 6\ny : \u211d\nhy : y \u2208 Icc 0 6\nhxy : x \u2264 y\n\u22a2 (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) x \u2264\n    (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) y"
        }
    ],
    "env": 0
}