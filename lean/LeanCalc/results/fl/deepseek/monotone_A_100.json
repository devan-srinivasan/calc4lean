{
    "tactics": [
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 0,
            "pos": {
                "line": 5,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) sorry",
            "endPos": {
                "line": 5,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 1,
            "pos": {
                "line": 6,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) x \u2264\n    (fun x => 6 * x ^ 7 + 4 * x ^ 6 + 7 * x ^ 5 + 3 * x ^ 4 + 15 * x ^ 3 + 10 * x ^ 2 + 4) y",
            "endPos": {
                "line": 6,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 2,
            "pos": {
                "line": 11,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 6 * x ^ 4 + 4 * x ^ 3) sorry",
            "endPos": {
                "line": 11,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Set.instMembership",
                "Nat.instCommSemigroup",
                "instHMul",
                "Set"
            ],
            "tactic": "exact fun x hx y hy hxy => by\n  simp only [mul_assoc, mul_comm, mul_left_comm, mul_pow]\n  nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2)]",
            "proofState": 3,
            "pos": {
                "line": 12,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 6 * x ^ 4 + 4 * x ^ 3) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 14,
                "column": 68
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Nat.instCommSemigroup",
                "instHMul"
            ],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm, mul_pow]",
            "proofState": 4,
            "pos": {
                "line": 13,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 15 * x ^ 6 + 6 * x ^ 4 + 4 * x ^ 3 \u2264 15 * y ^ 6 + 6 * y ^ 4 + 4 * y ^ 3",
            "endPos": {
                "line": 13,
                "column": 59
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2)]",
            "proofState": 5,
            "pos": {
                "line": 14,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 x ^ 6 * 15 + x ^ 4 * 6 + x ^ 3 * 4 \u2264 y ^ 6 * 15 + y ^ 4 * 6 + y ^ 3 * 4",
            "endPos": {
                "line": 14,
                "column": 68
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact Set.Icc_subset_Icc_right (by norm_num)",
            "proofState": 6,
            "pos": {
                "line": 15,
                "column": 2
            },
            "goals": "case h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 15,
                "column": 46
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 7,
            "pos": {
                "line": 15,
                "column": 37
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 ?m.42535 \u2264 ?m.42536",
            "endPos": {
                "line": 15,
                "column": 45
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 8,
            "pos": {
                "line": 18,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 16 * x ^ 3 + 17 * x ^ 2 + 7 * x + 6) sorry",
            "endPos": {
                "line": 18,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 9,
            "pos": {
                "line": 19,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 16 * x ^ 3 + 17 * x ^ 2 + 7 * x + 6) ?m.54112",
            "endPos": {
                "line": 19,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ Icc_subset_Ici_self",
            "proofState": 10,
            "pos": {
                "line": 24,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 6 + 7 * x ^ 4 + 17 * x ^ 3 + 4) sorry",
            "endPos": {
                "line": 24,
                "column": 45
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 11,
            "pos": {
                "line": 25,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 6 + 7 * x ^ 4 + 17 * x ^ 3 + 4) ?m.64991",
            "endPos": {
                "line": 25,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 12,
            "pos": {
                "line": 31,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 3 * x ^ 2) sorry",
            "endPos": {
                "line": 31,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have hx' : 0 \u2264 x := by\n  cases' hx with hx\u2081 hx\u2082\n  nlinarith",
            "proofState": 13,
            "pos": {
                "line": 32,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 17 * x ^ 7 + 3 * x ^ 2) x \u2264 (fun x => 17 * x ^ 7 + 3 * x ^ 2) y",
            "endPos": {
                "line": 34,
                "column": 13
            }
        },
        {
            "usedConstants": [],
            "tactic": "cases' hx with hx\u2081 hx\u2082",
            "proofState": 14,
            "pos": {
                "line": 33,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 33,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have hy' : y \u2264 3 := by\n  cases' hy with hy\u2081 hy\u2082\n  nlinarith",
            "proofState": 15,
            "pos": {
                "line": 35,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 (fun x => 17 * x ^ 7 + 3 * x ^ 2) x \u2264 (fun x => 17 * x ^ 7 + 3 * x ^ 2) y",
            "endPos": {
                "line": 37,
                "column": 13
            }
        },
        {
            "usedConstants": [],
            "tactic": "cases' hy with hy\u2081 hy\u2082",
            "proofState": 16,
            "pos": {
                "line": 36,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 y \u2264 3",
            "endPos": {
                "line": 36,
                "column": 26
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x + y), sq_nonneg (x - y)]",
            "proofState": 17,
            "pos": {
                "line": 38,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : y \u2264 3\n\u22a2 (fun x => 17 * x ^ 7 + 3 * x ^ 2) x \u2264 (fun x => 17 * x ^ 7 + 3 * x ^ 2) y",
            "endPos": {
                "line": 38,
                "column": 50
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 18,
            "pos": {
                "line": 41,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 13 * x ^ 6 + 8 * x ^ 5 + 19 * x ^ 4 + 15 * x ^ 3 + 8 * x ^ 2 + 19 * x + 5) sorry",
            "endPos": {
                "line": 41,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "Preorder.toLT",
                "Nat.instIsOrderedAddMonoid",
                "HMul.hMul",
                "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
                "Nat.instMonoid",
                "covariant_swap_add_of_covariant_add",
                "PartialOrder.toPreorder",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "contravariant_lt_of_covariant_le",
                "LE.le",
                "instHAdd",
                "Nat.instIsOrderedCancelAddMonoid",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_4",
                "Nat",
                "LT.lt",
                "Nat.instPartialOrder",
                "instAddNat",
                "Nat.instAddCommMonoid",
                "contravariant_swap_add_of_contravariant_add",
                "AddCommSemigroup.toAddCommMagma",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "IsOrderedCancelAddMonoid.toIsCancelAdd",
                "IsCancelAdd.toIsRightCancelAdd",
                "Nat.instAddCommSemigroup",
                "AddCommMagma.toAdd",
                "IsOrderedAddMonoid.toAddLeftMono",
                "instHMul",
                "Nat.instLinearOrder"
            ],
            "tactic": "norm_num",
            "proofState": 19,
            "pos": {
                "line": 42,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 13 * x ^ 6 + 8 * x ^ 5 + 19 * x ^ 4 + 15 * x ^ 3 + 8 * x ^ 2 + 19 * x + 5) x \u2264\n    (fun x => 5 * x ^ 7 + 13 * x ^ 6 + 8 * x ^ 5 + 19 * x ^ 4 + 15 * x ^ 3 + 8 * x ^ 2 + 19 * x + 5) y",
            "endPos": {
                "line": 42,
                "column": 10
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Nat.instMonoid",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Nat.instAddMonoid",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "instMulNat",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "AddMonoidWithOne.toOne",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "instAddNat",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "instOfNatAtLeastTwo",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul"
            ],
            "tactic": "ring_nf",
            "proofState": 20,
            "pos": {
                "line": 43,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 5 * x ^ 7 + 13 * x ^ 6 + 8 * x ^ 5 + 19 * x ^ 4 + 15 * x ^ 3 + 8 * x ^ 2 + 19 * x \u2264\n    5 * y ^ 7 + 13 * y ^ 6 + 8 * y ^ 5 + 19 * y ^ 4 + 15 * y ^ 3 + 8 * y ^ 2 + 19 * y",
            "endPos": {
                "line": 43,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x - 1 / 2), sq_nonneg (x + 1 / 2), sq_nonneg (y - 1 / 2),\n  sq_nonneg (y + 1 / 2)]",
            "proofState": 21,
            "pos": {
                "line": 44,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 x * 19 + x ^ 2 * 8 + x ^ 3 * 15 + x ^ 4 * 19 + x ^ 5 * 8 + x ^ 6 * 13 + x ^ 7 * 5 \u2264\n    y * 19 + y ^ 2 * 8 + y ^ 3 * 15 + y ^ 4 * 19 + y ^ 5 * 8 + y ^ 6 * 13 + y ^ 7 * 5",
            "endPos": {
                "line": 45,
                "column": 49
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 22,
            "pos": {
                "line": 48,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) sorry",
            "endPos": {
                "line": 48,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have h\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20 := by nlinarith",
            "proofState": 23,
            "pos": {
                "line": 49,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x \u2264\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y",
            "endPos": {
                "line": 49,
                "column": 97
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith",
            "proofState": 24,
            "pos": {
                "line": 49,
                "column": 88
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20",
            "endPos": {
                "line": 49,
                "column": 97
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have h\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20 := by nlinarith",
            "proofState": 25,
            "pos": {
                "line": 50,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\n\u22a2 (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x \u2264\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y",
            "endPos": {
                "line": 50,
                "column": 97
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith",
            "proofState": 26,
            "pos": {
                "line": 50,
                "column": 88
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\n\u22a2 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20",
            "endPos": {
                "line": 50,
                "column": 97
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "HSub.hSub",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instSubNat",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "instHSub",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have h\u2083 : 0 \u2264 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20 := by\n  nlinarith [sq_nonneg (y - x), sq_nonneg (y + x), sq_nonneg (2 * y - x), sq_nonneg (y + 2 * x), sq_nonneg (y - 2 * x),\n    sq_nonneg (2 * y + x), sq_nonneg (2 * y - 3 * x), sq_nonneg (3 * y - 2 * x)]",
            "proofState": 27,
            "pos": {
                "line": 51,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\n\u22a2 (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x \u2264\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y",
            "endPos": {
                "line": 53,
                "column": 105
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (y - x), sq_nonneg (y + x), sq_nonneg (2 * y - x), sq_nonneg (y + 2 * x), sq_nonneg (y - 2 * x),\n  sq_nonneg (2 * y + x), sq_nonneg (2 * y - 3 * x), sq_nonneg (3 * y - 2 * x)]",
            "proofState": 28,
            "pos": {
                "line": 52,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\n\u22a2 0 \u2264 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20",
            "endPos": {
                "line": 53,
                "column": 105
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (y - x), sq_nonneg (y + x), sq_nonneg (2 * y - x), sq_nonneg (y + 2 * x), sq_nonneg (y - 2 * x),\n  sq_nonneg (2 * y + x), sq_nonneg (2 * y - 3 * x), sq_nonneg (3 * y - 2 * x)]",
            "proofState": 29,
            "pos": {
                "line": 54,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\nh\u2083 : 0 \u2264 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20\n\u22a2 (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x \u2264\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y",
            "endPos": {
                "line": 55,
                "column": 103
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 30,
            "pos": {
                "line": 58,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 5 + 9 * x ^ 3 + 12 * x ^ 2 + 2 * x + 12) sorry",
            "endPos": {
                "line": 58,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Icc_subset_Icc_iff] at hx hy",
            "proofState": 31,
            "pos": {
                "line": 59,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 10 * x ^ 5 + 9 * x ^ 3 + 12 * x ^ 2 + 2 * x + 12) x \u2264\n    (fun x => 10 * x ^ 5 + 9 * x ^ 3 + 12 * x ^ 2 + 2 * x + 12) y",
            "endPos": {
                "line": 59,
                "column": 41
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 32,
            "pos": {
                "line": 64,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2) sorry",
            "endPos": {
                "line": 64,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp_all only [Icc_def, le_refl, le_of_lt, true_and, and_true, le_of_eq]",
            "proofState": 33,
            "pos": {
                "line": 65,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2) x \u2264\n    (fun x => 12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2) y",
            "endPos": {
                "line": 65,
                "column": 74
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + 2 * x ^ 2), sq_nonneg (y ^ 3 + 2 * y ^ 2)]",
            "proofState": 34,
            "pos": {
                "line": 66,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2 \u2264\n    12 * y ^ 7 + 4 * y ^ 6 + 5 * y ^ 5 + 20 * y ^ 4 + 19 * y ^ 3 + 4 * y ^ 2",
            "endPos": {
                "line": 66,
                "column": 74
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.of_deriv (fun x hx => _)",
            "proofState": 35,
            "pos": {
                "line": 69,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 2 * x ^ 4 + 7 * x ^ 3 + 8 * x ^ 2 + 19 * x + 12) sorry",
            "endPos": {
                "line": 69,
                "column": 43
            }
        },
        {
            "usedConstants": [],
            "tactic": "intro x hx",
            "proofState": 36,
            "pos": {
                "line": 70,
                "column": 2
            },
            "goals": "no goals",
            "endPos": {
                "line": 70,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ <| Icc_subset_Ici_self",
            "proofState": 37,
            "pos": {
                "line": 83,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 18 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 2) sorry",
            "endPos": {
                "line": 83,
                "column": 48
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 38,
            "pos": {
                "line": 84,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 18 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 2) ?m.388958",
            "endPos": {
                "line": 84,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 39,
            "pos": {
                "line": 89,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 18 * x ^ 6 + 2 * x ^ 5 + 17 * x ^ 3 + 7 * x) sorry",
            "endPos": {
                "line": 89,
                "column": 23
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact\n  (monotone_iff_forall_lt.2 fun x _ y _ h => by\n    nlinarith [sq_nonneg (x + y), sq_nonneg (x - y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2),\n      sq_nonneg (x ^ 4 - y ^ 4), sq_nonneg (x ^ 5 - y ^ 5), sq_nonneg (x ^ 6 - y ^ 6), sq_nonneg (x ^ 7 - y ^ 7)])",
            "proofState": 40,
            "pos": {
                "line": 90,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 18 * x ^ 6 + 2 * x ^ 5 + 17 * x ^ 3 + 7 * x) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 93,
                "column": 3
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x + y), sq_nonneg (x - y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2),\n  sq_nonneg (x ^ 4 - y ^ 4), sq_nonneg (x ^ 5 - y ^ 5), sq_nonneg (x ^ 6 - y ^ 6), sq_nonneg (x ^ 7 - y ^ 7)]",
            "proofState": 41,
            "pos": {
                "line": 91,
                "column": 4
            },
            "goals": "x\u271d\u00b2 : Sort u_1\nIcc : x\u271d\u00b2\nx x\u271d\u00b9 : ?m.403635\ny : x < x\u271d\u00b9\nx\u271d : ?m.403952 x x\u271d\u00b9 y\nh : ?m.403953 x x\u271d\u00b9 y x\u271d\n\u22a2 ?m.403954 x x\u271d\u00b9 y x\u271d h",
            "endPos": {
                "line": 92,
                "column": 113
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 42,
            "pos": {
                "line": 102,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 7 + 18 * x ^ 6 + 11 * x ^ 5 + 14 * x ^ 4 + 20 * x ^ 3 + 13 * x ^ 2 + 5 * x + 8) sorry",
            "endPos": {
                "line": 102,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx",
            "proofState": 43,
            "pos": {
                "line": 103,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 7 + 18 * x ^ 6 + 11 * x ^ 5 + 14 * x ^ 4 + 20 * x ^ 3 + 13 * x ^ 2 + 5 * x + 8)\n    ?m.437690",
            "endPos": {
                "line": 103,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 44,
            "pos": {
                "line": 109,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x) sorry",
            "endPos": {
                "line": 109,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp only [MonotoneOn, Set.mem_Icc] at hx hy h \u22a2",
            "proofState": 45,
            "pos": {
                "line": 110,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x) x \u2264\n    (fun x => 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x) y",
            "endPos": {
                "line": 110,
                "column": 50
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 46,
            "pos": {
                "line": 111,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x \u2264 16 * y ^ 6 + 12 * y ^ 5 + 6 * y ^ 3 + 15 * y ^ 2 + 8 * y",
            "endPos": {
                "line": 112,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 47,
            "pos": {
                "line": 115,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) sorry",
            "endPos": {
                "line": 115,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 48,
            "pos": {
                "line": 116,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) x \u2264\n    (fun x => 4 * x ^ 7 + 15 * x ^ 6 + 9 * x ^ 4 + 8 * x ^ 2 + 17 * x + 15) y",
            "endPos": {
                "line": 116,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 49,
            "pos": {
                "line": 122,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 8 * x ^ 5 + 15 * x ^ 2) sorry",
            "endPos": {
                "line": 122,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 50,
            "pos": {
                "line": 123,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 8 * x ^ 5 + 15 * x ^ 2) ?m.504583",
            "endPos": {
                "line": 123,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 51,
            "pos": {
                "line": 130,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) sorry",
            "endPos": {
                "line": 130,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x - y + x + y), sq_nonneg (x - y - x - y)]",
            "proofState": 52,
            "pos": {
                "line": 131,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) x \u2264 (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) y",
            "endPos": {
                "line": 132,
                "column": 30
            }
        },
        {
            "usedConstants": [],
            "tactic": "refine' monotoneOn_of_deriv_nonneg _ _",
            "proofState": 53,
            "pos": {
                "line": 135,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 16 * x ^ 7 + 11 * x ^ 6 + 2 * x ^ 4 + 19 * x ^ 2) sorry",
            "endPos": {
                "line": 135,
                "column": 40
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 54,
            "pos": {
                "line": 144,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) sorry",
            "endPos": {
                "line": 144,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 55,
            "pos": {
                "line": 145,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) x \u2264\n    (fun x => 12 * x ^ 7 + 7 * x ^ 6 + 13 * x ^ 5 + 13 * x ^ 3) y",
            "endPos": {
                "line": 145,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 56,
            "pos": {
                "line": 149,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 3 * x ^ 6 + 17 * x ^ 4 + 13 * x ^ 3 + 2 * x ^ 2 + 18 * x + 13) sorry",
            "endPos": {
                "line": 149,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 57,
            "pos": {
                "line": 150,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 3 * x ^ 6 + 17 * x ^ 4 + 13 * x ^ 3 + 2 * x ^ 2 + 18 * x + 13) ?m.599051",
            "endPos": {
                "line": 150,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 58,
            "pos": {
                "line": 155,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 2 * x ^ 3 + 11 * x + 4) sorry",
            "endPos": {
                "line": 155,
                "column": 49
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.add",
            "proofState": 59,
            "pos": {
                "line": 156,
                "column": 2
            },
            "goals": "case refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\ncase refine'_2\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 2 * x ^ 3 + 11 * x + 4) ?refine'_1",
            "endPos": {
                "line": 156,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 60,
            "pos": {
                "line": 161,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 14 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 14 * x ^ 3 + 2 * x ^ 2 + 18 * x + 19) sorry",
            "endPos": {
                "line": 161,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx",
            "proofState": 61,
            "pos": {
                "line": 162,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 14 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 14 * x ^ 3 + 2 * x ^ 2 + 18 * x + 19) ?m.625363",
            "endPos": {
                "line": 162,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 62,
            "pos": {
                "line": 169,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) sorry",
            "endPos": {
                "line": 169,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx",
            "proofState": 63,
            "pos": {
                "line": 170,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 170,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro y hy",
            "proofState": 64,
            "pos": {
                "line": 171,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?s \u2192 x \u2264 b \u2192 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) x \u2264 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) b\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 171,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Preorder.toLE",
                "LE.le",
                "Nat.instPreorder",
                "Nat"
            ],
            "tactic": "intro h",
            "proofState": 65,
            "pos": {
                "line": 172,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) x \u2264 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) y\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 172,
                "column": 9
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Nat.instMonoid",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Nat.instAddMonoid",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "instMulNat",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "AddMonoidWithOne.toOne",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "instAddNat",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "instOfNatAtLeastTwo",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul"
            ],
            "tactic": "ring_nf",
            "proofState": 66,
            "pos": {
                "line": 173,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nh : x \u2264 y\n\u22a2 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) x \u2264 (fun x => 9 * x ^ 4 + 3 * x ^ 2 + 19 * x + 12) y\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 173,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y)]",
            "proofState": 67,
            "pos": {
                "line": 174,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nh : x \u2264 y\n\u22a2 12 + x * 19 + x ^ 2 * 3 + x ^ 4 * 9 \u2264 12 + y * 19 + y ^ 2 * 3 + y ^ 4 * 9\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 174,
                "column": 50
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 68,
            "pos": {
                "line": 177,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 2 * x ^ 7 + 14 * x ^ 6 + 3 * x ^ 3 + 20 * x ^ 2 + 13 * x) sorry",
            "endPos": {
                "line": 177,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Nat.instCommSemigroup",
                "instHMul"
            ],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm] at *",
            "proofState": 69,
            "pos": {
                "line": 178,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 2 * x ^ 7 + 14 * x ^ 6 + 3 * x ^ 3 + 20 * x ^ 2 + 13 * x) x \u2264\n    (fun x => 2 * x ^ 7 + 14 * x ^ 6 + 3 * x ^ 3 + 20 * x ^ 2 + 13 * x) y",
            "endPos": {
                "line": 178,
                "column": 53
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 70,
            "pos": {
                "line": 179,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 2 * x ^ 7 + x ^ 6 * 14 + 3 * x ^ 3 + x ^ 2 * 20 + x * 13 \u2264 2 * y ^ 7 + y ^ 6 * 14 + 3 * y ^ 3 + y ^ 2 * 20 + y * 13",
            "endPos": {
                "line": 179,
                "column": 85
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.mono _ (Set.Icc_subset_Ici_self)",
            "proofState": 71,
            "pos": {
                "line": 182,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 2 + 6) sorry",
            "endPos": {
                "line": 182,
                "column": 51
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 72,
            "pos": {
                "line": 188,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) sorry",
            "endPos": {
                "line": 188,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x + y), sq_nonneg (x - y), sq_nonneg (x + y - 2)]",
            "proofState": 73,
            "pos": {
                "line": 189,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) x \u2264 (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) y",
            "endPos": {
                "line": 189,
                "column": 73
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 74,
            "pos": {
                "line": 192,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) sorry",
            "endPos": {
                "line": 192,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have hx' : 0 \u2264 x := by\n  cases' hx with hx\u2081 hx\u2082\n  linarith",
            "proofState": 75,
            "pos": {
                "line": 193,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) x \u2264 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) y",
            "endPos": {
                "line": 195,
                "column": 12
            }
        },
        {
            "usedConstants": [],
            "tactic": "cases' hx with hx\u2081 hx\u2082",
            "proofState": 76,
            "pos": {
                "line": 194,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 194,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have hy' : 0 \u2264 y := by\n  cases' hy with hy\u2081 hy\u2082\n  linarith",
            "proofState": 77,
            "pos": {
                "line": 196,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) x \u2264 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) y",
            "endPos": {
                "line": 198,
                "column": 12
            }
        },
        {
            "usedConstants": [],
            "tactic": "cases' hy with hy\u2081 hy\u2082",
            "proofState": 78,
            "pos": {
                "line": 197,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 0 \u2264 y",
            "endPos": {
                "line": 197,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "HSub.hSub",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instSubNat",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "instHSub",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have hxy' : 0 \u2264 y - x := by linarith",
            "proofState": 79,
            "pos": {
                "line": 199,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) x \u2264 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) y",
            "endPos": {
                "line": 199,
                "column": 38
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "linarith",
            "proofState": 80,
            "pos": {
                "line": 199,
                "column": 30
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 0 \u2264 y - x",
            "endPos": {
                "line": 199,
                "column": 38
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Nat.instCommSemigroup",
                "instHMul"
            ],
            "tactic": "simp only [mul_assoc, mul_one, mul_add, mul_comm, mul_left_comm]",
            "proofState": 81,
            "pos": {
                "line": 200,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : 0 \u2264 y - x\n\u22a2 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) x \u2264 (fun x => 8 * x ^ 6 + 11 * x ^ 5 + 19 * x + 10) y",
            "endPos": {
                "line": 200,
                "column": 66
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3), sq_nonneg (x ^ 2), sq_nonneg x, sq_nonneg (y ^ 3), sq_nonneg (y ^ 2), sq_nonneg y,\n  sq_nonneg (x - y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 82,
            "pos": {
                "line": 201,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : 0 \u2264 y - x\n\u22a2 x ^ 6 * 8 + x ^ 5 * 11 + x * 19 + 10 \u2264 y ^ 6 * 8 + y ^ 5 * 11 + y * 19 + 10",
            "endPos": {
                "line": 201,
                "column": 187
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 83,
            "pos": {
                "line": 204,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) sorry",
            "endPos": {
                "line": 204,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "letFun",
                "instHMul",
                "Set"
            ],
            "tactic": "have hx' := hx",
            "proofState": 84,
            "pos": {
                "line": 205,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) x \u2264\n    (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) y",
            "endPos": {
                "line": 205,
                "column": 16
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "letFun",
                "instHMul",
                "Set"
            ],
            "tactic": "have hy' := hy",
            "proofState": 85,
            "pos": {
                "line": 206,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : x \u2208 sorry\n\u22a2 (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) x \u2264\n    (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) y",
            "endPos": {
                "line": 206,
                "column": 16
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp_all only [Set.mem_Icc, Set.mem_Icc]",
            "proofState": 86,
            "pos": {
                "line": 207,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : x \u2208 sorry\nhy' : y \u2208 sorry\n\u22a2 (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) x \u2264\n    (fun x => 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x) y",
            "endPos": {
                "line": 207,
                "column": 42
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 87,
            "pos": {
                "line": 208,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx y : \u2115\nhxy : x \u2264 y\nhx' : x \u2208 sorry\nhy' : y \u2208 sorry\n\u22a2 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x \u2264 15 * y ^ 6 + 18 * y ^ 5 + 9 * y ^ 3 + 4 * y ^ 2 + 3 * y",
            "endPos": {
                "line": 208,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_right (by norm_num))",
            "proofState": 88,
            "pos": {
                "line": 211,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 19 * x ^ 6 + 7 * x ^ 5 + 12 * x ^ 4 + 18) sorry",
            "endPos": {
                "line": 211,
                "column": 62
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact\n  MonotoneOn.add\n    (MonotoneOn.add\n      (MonotoneOn.add\n        (MonotoneOn.add (by exact (monotone_id.const_mul (by norm_num)).monotoneOn)\n          (by exact (monotone_id.const_mul (by norm_num)).monotoneOn))\n        (by exact (monotone_id.const_mul (by norm_num)).monotoneOn))\n      (by exact (monotone_id.const_mul (by norm_num)).monotoneOn))\n    (by exact (monotone_id.const_mul (by norm_num)).monotoneOn)",
            "proofState": 89,
            "pos": {
                "line": 212,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 19 * x ^ 6 + 7 * x ^ 5 + 12 * x ^ 4 + 18) ?m.847299",
            "endPos": {
                "line": 219,
                "column": 65
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 90,
            "pos": {
                "line": 215,
                "column": 44
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn ?m.849378 ?m.849380",
            "endPos": {
                "line": 215,
                "column": 98
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 91,
            "pos": {
                "line": 215,
                "column": 77
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.861409",
            "endPos": {
                "line": 215,
                "column": 85
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 92,
            "pos": {
                "line": 216,
                "column": 14
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn ?m.849379 ?m.849380",
            "endPos": {
                "line": 216,
                "column": 68
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 93,
            "pos": {
                "line": 216,
                "column": 47
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.876512",
            "endPos": {
                "line": 216,
                "column": 55
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 94,
            "pos": {
                "line": 217,
                "column": 14
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn ?m.848798 ?m.849380",
            "endPos": {
                "line": 217,
                "column": 68
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 95,
            "pos": {
                "line": 217,
                "column": 47
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.892155",
            "endPos": {
                "line": 217,
                "column": 55
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 96,
            "pos": {
                "line": 218,
                "column": 12
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn ?m.848217 ?m.849380",
            "endPos": {
                "line": 218,
                "column": 66
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 97,
            "pos": {
                "line": 218,
                "column": 45
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.907798",
            "endPos": {
                "line": 218,
                "column": 53
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact (monotone_id.const_mul (by norm_num)).monotoneOn",
            "proofState": 98,
            "pos": {
                "line": 219,
                "column": 10
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn ?m.847648 ?m.849380",
            "endPos": {
                "line": 219,
                "column": 64
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 99,
            "pos": {
                "line": 219,
                "column": 43
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.923441",
            "endPos": {
                "line": 219,
                "column": 51
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ Icc_subset_Icc_right",
            "proofState": 100,
            "pos": {
                "line": 222,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 6 + 11 * x ^ 5 + 17 * x ^ 4 + 5 * x ^ 3 + 18 * x ^ 2 + 13 * x) sorry",
            "endPos": {
                "line": 222,
                "column": 46
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact fun x hx y hy h => by\n  simp only [Set.mem_Icc] at hx hy\n  nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 101,
            "pos": {
                "line": 223,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 6 + 11 * x ^ 5 + 17 * x ^ 4 + 5 * x ^ 3 + 18 * x ^ 2 + 13 * x) ?m.965543",
            "endPos": {
                "line": 225,
                "column": 87
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 102,
            "pos": {
                "line": 224,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : ?m.965902 x\ny : ?m.965903 x hx\nhy : ?m.965904 x hx y\nh : ?m.965905 x hx y hy\n\u22a2 ?m.965906 x hx y hy h",
            "endPos": {
                "line": 224,
                "column": 36
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 103,
            "pos": {
                "line": 228,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) sorry",
            "endPos": {
                "line": 228,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + x ^ 2), sq_nonneg (y ^ 3 + y ^ 2), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2)]",
            "proofState": 104,
            "pos": {
                "line": 229,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) x \u2264\n    (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) y",
            "endPos": {
                "line": 230,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 105,
            "pos": {
                "line": 233,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 6 + 4 * x ^ 5 + 20 * x ^ 4 + 11 * x ^ 3 + 2 * x ^ 2 + 9 * x + 7) sorry",
            "endPos": {
                "line": 233,
                "column": 49
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact fun x hx y hy h => by\n  simp only [mul_comm, mul_left_comm, mul_assoc] at h\n  nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 + y ^ 2),\n    sq_nonneg (x ^ 2 - 3 * y ^ 2), sq_nonneg (x ^ 2 + 3 * y ^ 2), sq_nonneg (2 * x ^ 2 - y ^ 2),\n    sq_nonneg (2 * x ^ 2 + y ^ 2)]",
            "proofState": 106,
            "pos": {
                "line": 234,
                "column": 2
            },
            "goals": "case refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\ncase refine'_2\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 6 + 4 * x ^ 5 + 20 * x ^ 4 + 11 * x ^ 3 + 2 * x ^ 2 + 9 * x + 7) ?refine'_1",
            "endPos": {
                "line": 238,
                "column": 67
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mul_comm, mul_left_comm, mul_assoc] at h",
            "proofState": 107,
            "pos": {
                "line": 235,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : ?m.1031157 x\ny : ?m.1031158 x hx\nhy : ?m.1031159 x hx y\nh : ?m.1031160 x hx y hy\n\u22a2 ?m.1031161 x hx y hy h",
            "endPos": {
                "line": 235,
                "column": 55
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 108,
            "pos": {
                "line": 241,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 10 * x ^ 6 + 20 * x ^ 5 + 8 * x ^ 3 + 15 * x ^ 2 + 19 * x) sorry",
            "endPos": {
                "line": 241,
                "column": 63
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 109,
            "pos": {
                "line": 242,
                "column": 2
            },
            "goals": "case refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\ncase refine'_2\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 10 * x ^ 6 + 20 * x ^ 5 + 8 * x ^ 3 + 15 * x ^ 2 + 19 * x) ?refine'_1",
            "endPos": {
                "line": 242,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 110,
            "pos": {
                "line": 254,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x + 13) sorry",
            "endPos": {
                "line": 254,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "Preorder.toLT",
                "Nat.instIsOrderedAddMonoid",
                "HMul.hMul",
                "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
                "Nat.instMonoid",
                "covariant_swap_add_of_covariant_add",
                "PartialOrder.toPreorder",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "contravariant_lt_of_covariant_le",
                "LE.le",
                "instHAdd",
                "Nat.instIsOrderedCancelAddMonoid",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_4",
                "Nat",
                "LT.lt",
                "Nat.instPartialOrder",
                "instAddNat",
                "Nat.instAddCommMonoid",
                "contravariant_swap_add_of_contravariant_add",
                "AddCommSemigroup.toAddCommMagma",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "IsOrderedCancelAddMonoid.toIsCancelAdd",
                "IsCancelAdd.toIsRightCancelAdd",
                "Nat.instAddCommSemigroup",
                "AddCommMagma.toAdd",
                "IsOrderedAddMonoid.toAddLeftMono",
                "instHMul",
                "Nat.instLinearOrder"
            ],
            "tactic": "norm_num",
            "proofState": 111,
            "pos": {
                "line": 255,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x + 13) x \u2264\n    (fun x => 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x + 13) y",
            "endPos": {
                "line": 255,
                "column": 10
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 + 13 * x ^ 2), sq_nonneg (y ^ 3 + 13 * y ^ 2)]",
            "proofState": 112,
            "pos": {
                "line": 256,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x \u2264 8 * y ^ 7 + 17 * y ^ 6 + 10 * y ^ 2 + 12 * y",
            "endPos": {
                "line": 256,
                "column": 76
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 113,
            "pos": {
                "line": 259,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 8 * x + 14) sorry",
            "endPos": {
                "line": 259,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp_all only [Icc_subset_Icc_iff, le_of_lt]",
            "proofState": 114,
            "pos": {
                "line": 260,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 11 * x ^ 7 + 8 * x + 14) x \u2264 (fun x => 11 * x ^ 7 + 8 * x + 14) y",
            "endPos": {
                "line": 260,
                "column": 46
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Nat.instMonoid",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Nat.instAddMonoid",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "instMulNat",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "AddMonoidWithOne.toOne",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "instAddNat",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "instOfNatAtLeastTwo",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul"
            ],
            "tactic": "ring_nf",
            "proofState": 115,
            "pos": {
                "line": 261,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 11 * x ^ 7 + 8 * x + 14 \u2264 11 * y ^ 7 + 8 * y + 14",
            "endPos": {
                "line": 261,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), hx.1, hx.2, hy.1, hy.2]",
            "proofState": 116,
            "pos": {
                "line": 262,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 14 + x * 8 + x ^ 7 * 11 \u2264 14 + y * 8 + y ^ 7 * 11",
            "endPos": {
                "line": 262,
                "column": 74
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 117,
            "pos": {
                "line": 265,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 6 * x ^ 4 + 20 * x ^ 3 + 5 * x ^ 2 + 19 * x) sorry",
            "endPos": {
                "line": 265,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 118,
            "pos": {
                "line": 266,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 6 * x ^ 4 + 20 * x ^ 3 + 5 * x ^ 2 + 19 * x) ?m.1102875",
            "endPos": {
                "line": 266,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _",
            "proofState": 119,
            "pos": {
                "line": 271,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 15 * x ^ 6 + 8 * x ^ 5 + 2 * x ^ 4 + 7 * x ^ 2 + 18 * x + 13) sorry",
            "endPos": {
                "line": 271,
                "column": 25
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx",
            "proofState": 120,
            "pos": {
                "line": 272,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?m.1122399",
            "endPos": {
                "line": 272,
                "column": 14
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp_all only [Set.mem_Icc, le_refl, true_and_iff, zero_le_four]",
            "proofState": 121,
            "pos": {
                "line": 273,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\n\u22a2 x \u2208 ?m.1122399",
            "endPos": {
                "line": 273,
                "column": 68
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.add",
            "proofState": 122,
            "pos": {
                "line": 276,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 15 * x ^ 6 + 8 * x ^ 5 + 2 * x ^ 4 + 7 * x ^ 2 + 18 * x + 13) ?m.1122399",
            "endPos": {
                "line": 276,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono (fun x hx => ?_)",
            "proofState": 123,
            "pos": {
                "line": 306,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x) sorry",
            "endPos": {
                "line": 306,
                "column": 40
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "sorryAx",
                "HasSubset.Subset",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat",
                "letFun",
                "Set.instHasSubset",
                "Set"
            ],
            "tactic": "have h\u2080 : 0 \u2264 x := by linarith [hx.1]",
            "proofState": 124,
            "pos": {
                "line": 307,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?m.1134105\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?m.1134105\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?m.1134105 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 307,
                "column": 39
            }
        },
        {
            "usedConstants": [],
            "tactic": "linarith [hx.1]",
            "proofState": 125,
            "pos": {
                "line": 307,
                "column": 24
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 sorry",
            "endPos": {
                "line": 307,
                "column": 39
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "sorryAx",
                "HasSubset.Subset",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat",
                "letFun",
                "Set.instHasSubset",
                "Set"
            ],
            "tactic": "have h\u2081 : 0 \u2264 5 := by linarith [hx.2]",
            "proofState": 126,
            "pos": {
                "line": 308,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\n\u22a2 sorry \u2286 ?m.1134105\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?m.1134105\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?m.1134105 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 308,
                "column": 39
            }
        },
        {
            "usedConstants": [],
            "tactic": "linarith [hx.2]",
            "proofState": 127,
            "pos": {
                "line": 308,
                "column": 24
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\n\u22a2 0 \u2264 5",
            "endPos": {
                "line": 308,
                "column": 39
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "Set.instHasSubset",
                "instHMul",
                "Set"
            ],
            "tactic": "have h\u2082 : 0 \u2264 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x := by\n  nlinarith [sq_nonneg (3 * x ^ 3 + x), sq_nonneg (3 * x ^ 2), sq_nonneg x, sq_nonneg 1]",
            "proofState": 128,
            "pos": {
                "line": 309,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\n\u22a2 sorry \u2286 ?m.1134105\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?m.1134105\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?m.1134105 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 310,
                "column": 90
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (3 * x ^ 3 + x), sq_nonneg (3 * x ^ 2), sq_nonneg x, sq_nonneg 1]",
            "proofState": 129,
            "pos": {
                "line": 310,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\n\u22a2 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry",
            "endPos": {
                "line": 310,
                "column": 90
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "Set.instHasSubset",
                "instHMul",
                "Set"
            ],
            "tactic": "have h\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5 := by\n  nlinarith [sq_nonneg (3 * 5 ^ 3 + 5), sq_nonneg (3 * 5 ^ 2), sq_nonneg 5, sq_nonneg 1]",
            "proofState": 130,
            "pos": {
                "line": 311,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\n\u22a2 sorry \u2286 ?m.1134105\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?m.1134105\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?m.1134105 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 312,
                "column": 90
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith [sq_nonneg (3 * 5 ^ 3 + 5), sq_nonneg (3 * 5 ^ 2), sq_nonneg 5, sq_nonneg 1]",
            "proofState": 131,
            "pos": {
                "line": 312,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\n\u22a2 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5",
            "endPos": {
                "line": 312,
                "column": 90
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "instHDiv",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HDiv.hDiv",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Nat.instDiv",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "Set.instHasSubset",
                "instHMul",
                "Set"
            ],
            "tactic": "have h\u2084 : 0 \u2264 (9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x) / 7 := by positivity",
            "proofState": 132,
            "pos": {
                "line": 313,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\n\u22a2 sorry \u2286 ?m.1134105\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?m.1134105\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?m.1134105 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 313,
                "column": 81
            }
        },
        {
            "usedConstants": [
                "zero_le",
                "Unit.unit",
                "Nat.instCanonicallyOrderedAdd",
                "instHDiv",
                "HMul.hMul",
                "Nat.instMonoid",
                "AddMonoid.toAddZeroClass",
                "PartialOrder.toPreorder",
                "Preorder.toLE",
                "Nat.instAddMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HDiv.hDiv",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Nat.instDiv",
                "Nat.instPartialOrder",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "positivity",
            "proofState": 133,
            "pos": {
                "line": 313,
                "column": 71
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\n\u22a2 0 \u2264 (9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry) / 7",
            "endPos": {
                "line": 313,
                "column": 81
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "instHDiv",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HDiv.hDiv",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat",
                "Nat.instDiv",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "Set.instHasSubset",
                "instHMul",
                "Set"
            ],
            "tactic": "have h\u2085 : 0 \u2264 (9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5) / 7 := by positivity",
            "proofState": 134,
            "pos": {
                "line": 314,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\nh\u2084 : 0 \u2264 (9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry) / 7\n\u22a2 sorry \u2286 ?m.1134105\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?m.1134105\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?m.1134105 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 314,
                "column": 81
            }
        },
        {
            "usedConstants": [
                "Nat.instMulZeroClass",
                "Mathlib.Meta.NormNum.isNat_add",
                "instHDiv",
                "HMul.hMul",
                "Nat.ble",
                "Nat.instNontrivial",
                "Mathlib.Meta.NormNum.IsNatPowT.run",
                "Nat.instMonoid",
                "PartialOrder.toPreorder",
                "le_of_lt",
                "Monoid.toNatPow",
                "HDiv.hDiv",
                "Nat.instStarOrderedRing",
                "Mathlib.Meta.NormNum.IsNatPowT.bit1",
                "Nat.instStarRing",
                "Mathlib.Meta.NormNum.IsNatPowT.bit0",
                "instMulNat",
                "instOfNatNat",
                "Mathlib.Meta.NormNum.IsNatPowT.trans",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "Nat.instAddMonoidWithOne",
                "instHAdd",
                "HPow.hPow",
                "Mathlib.Meta.Positivity.pos_of_isNat",
                "HAdd.hAdd",
                "Nat",
                "Mathlib.Meta.NormNum.isNat_natDiv",
                "Nat.instCommSemiring",
                "Nat.instDiv",
                "Nat.pow",
                "Nat.instPartialOrder",
                "StarOrderedRing.toIsOrderedRing",
                "Bool",
                "Mathlib.Meta.NormNum.isNat_mul",
                "instAddNat",
                "Nat.instSemiring",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Mathlib.Meta.NormNum.isNat_pow",
                "MulZeroClass.toZero",
                "instHMul"
            ],
            "tactic": "positivity",
            "proofState": 135,
            "pos": {
                "line": 314,
                "column": 71
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\nh\u2084 : 0 \u2264 (9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry) / 7\n\u22a2 0 \u2264 (9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5) / 7",
            "endPos": {
                "line": 314,
                "column": 81
            }
        },
        {
            "usedConstants": [],
            "tactic": "linarith [sq_nonneg (3 * x ^ 3 + x), sq_nonneg (3 * x ^ 2), sq_nonneg x, sq_nonneg 1]",
            "proofState": 136,
            "pos": {
                "line": 315,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nh\u2080 : 0 \u2264 sorry\nh\u2081 : 0 \u2264 5\nh\u2082 : 0 \u2264 9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry\nh\u2083 : 0 \u2264 9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5\nh\u2084 : 0 \u2264 (9 * sorry ^ 7 + 7 * sorry ^ 5 + 19 * sorry ^ 3 + 7 * sorry) / 7\nh\u2085 : 0 \u2264 (9 * 5 ^ 7 + 7 * 5 ^ 5 + 19 * 5 ^ 3 + 7 * 5) / 7\n\u22a2 sorry \u2286 ?m.1134105\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?m.1134105\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?m.1134105 \u2192 x \u2264 b \u2192 9 * x ^ 7 + 7 * x ^ 5 + 19 * x ^ 3 + 7 * x \u2264 9 * b ^ 7 + 7 * b ^ 5 + 19 * b ^ 3 + 7 * b",
            "endPos": {
                "line": 315,
                "column": 87
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 137,
            "pos": {
                "line": 318,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) sorry",
            "endPos": {
                "line": 318,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 138,
            "pos": {
                "line": 319,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 4 + 15 * x ^ 2 + 18 * x) ?m.1227779",
            "endPos": {
                "line": 319,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 139,
            "pos": {
                "line": 326,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 3 * x ^ 6 + 14 * x ^ 5 + 14 * x ^ 4) sorry",
            "endPos": {
                "line": 326,
                "column": 47
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.add",
            "proofState": 140,
            "pos": {
                "line": 327,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 3 * x ^ 6 + 14 * x ^ 5 + 14 * x ^ 4) ?m.1237551",
            "endPos": {
                "line": 327,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _",
            "proofState": 141,
            "pos": {
                "line": 339,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 6 * x ^ 5 + 3 * x ^ 4 + 6 * x ^ 3 + 16 * x + 14) sorry",
            "endPos": {
                "line": 339,
                "column": 25
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "sorryAx",
                "HasSubset.Subset",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "Set"
            ],
            "tactic": "exact Icc_subset_Icc_left (by norm_num)",
            "proofState": 142,
            "pos": {
                "line": 340,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?m.1253608\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 6 * x ^ 5 + 3 * x ^ 4 + 6 * x ^ 3 + 16 * x + 14) ?m.1253608",
            "endPos": {
                "line": 340,
                "column": 41
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 143,
            "pos": {
                "line": 341,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 6 * x ^ 5 + 3 * x ^ 4 + 6 * x ^ 3 + 16 * x + 14) ?m.1253608",
            "endPos": {
                "line": 341,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 144,
            "pos": {
                "line": 346,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 15 * x ^ 6 + 20 * x ^ 5 + 17 * x ^ 4 + 4 * x ^ 2) sorry",
            "endPos": {
                "line": 346,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 145,
            "pos": {
                "line": 347,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 15 * x ^ 6 + 20 * x ^ 5 + 17 * x ^ 4 + 4 * x ^ 2) ?m.1270120",
            "endPos": {
                "line": 347,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 146,
            "pos": {
                "line": 355,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 5 + 3 * x ^ 3 + 6 * x ^ 2 + 17 * x + 6) sorry",
            "endPos": {
                "line": 355,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 147,
            "pos": {
                "line": 356,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 10 * x ^ 5 + 3 * x ^ 3 + 6 * x ^ 2 + 17 * x + 6) x \u2264\n    (fun x => 10 * x ^ 5 + 3 * x ^ 3 + 6 * x ^ 2 + 17 * x + 6) y",
            "endPos": {
                "line": 356,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.mono (fun x hx y hy hxy => ?_) (Set.Icc_subset_Icc_left (by norm_num))",
            "proofState": 148,
            "pos": {
                "line": 361,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 11 * x ^ 5 + 17 * x ^ 4 + 9 * x ^ 3 + 12 * x + 18) sorry",
            "endPos": {
                "line": 361,
                "column": 89
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ Icc_subset_Icc_left",
            "proofState": 149,
            "pos": {
                "line": 366,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 9 * x ^ 6 + 3 * x ^ 4 + 8 * x ^ 3 + 12 * x ^ 2 + 18 * x) sorry",
            "endPos": {
                "line": 366,
                "column": 45
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 150,
            "pos": {
                "line": 367,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 9 * x ^ 6 + 3 * x ^ 4 + 8 * x ^ 3 + 12 * x ^ 2 + 18 * x) ?m.1317000",
            "endPos": {
                "line": 367,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 151,
            "pos": {
                "line": 378,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 12 * x ^ 6 + 14 * x ^ 5 + 13 * x ^ 4 + 18 * x ^ 3 + 5 * x ^ 2 + 18 * x) sorry",
            "endPos": {
                "line": 378,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 152,
            "pos": {
                "line": 379,
                "column": 6
            },
            "goals": "case hf\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 12 * x ^ 6 + 14 * x ^ 5 + 13 * x ^ 4 + 18 * x ^ 3 + 5 * x ^ 2) sorry",
            "endPos": {
                "line": 379,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "sorryAx",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "MonotoneOn",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 153,
            "pos": {
                "line": 379,
                "column": 6
            },
            "goals": "case hg\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (HMul.hMul 18) sorry",
            "endPos": {
                "line": 379,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 154,
            "pos": {
                "line": 386,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) sorry",
            "endPos": {
                "line": 386,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 155,
            "pos": {
                "line": 387,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) x \u2264\n    (fun x => 11 * x ^ 7 + 4 * x ^ 6 + 19 * x ^ 5 + 10 * x ^ 4 + 10 * x ^ 3 + 4 * x ^ 2) y",
            "endPos": {
                "line": 387,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 156,
            "pos": {
                "line": 397,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 13 * x ^ 7 + 13 * x ^ 6 + 9 * x ^ 5 + 16 * x ^ 4 + 15 * x ^ 3 + 5 * x ^ 2) sorry",
            "endPos": {
                "line": 397,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 157,
            "pos": {
                "line": 398,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 13 * x ^ 7 + 13 * x ^ 6 + 9 * x ^ 5 + 16 * x ^ 4 + 15 * x ^ 3 + 5 * x ^ 2) x \u2264\n    (fun x => 13 * x ^ 7 + 13 * x ^ 6 + 9 * x ^ 5 + 16 * x ^ 4 + 15 * x ^ 3 + 5 * x ^ 2) y",
            "endPos": {
                "line": 398,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 158,
            "pos": {
                "line": 407,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 5 + 15 * x ^ 3 + 20 * x ^ 2) sorry",
            "endPos": {
                "line": 407,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "add_assoc",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "AddSemigroup.toAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Nat.instCommSemigroup",
                "Nat.instAddSemigroup",
                "Eq.trans",
                "instHMul"
            ],
            "tactic": "simp only [mul_assoc, mul_one, mul_zero, add_assoc, add_right_comm, add_zero, mul_add, mul_comm, mul_left_comm] at h \u22a2",
            "proofState": 159,
            "pos": {
                "line": 408,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 5 + 15 * x ^ 3 + 20 * x ^ 2) x \u2264 (fun x => 5 * x ^ 5 + 15 * x ^ 3 + 20 * x ^ 2) y",
            "endPos": {
                "line": 408,
                "column": 120
            }
        },
        {
            "usedConstants": [],
            "tactic": "ring_nf at h \u22a2",
            "proofState": 160,
            "pos": {
                "line": 409,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 5 * x ^ 5 + (x ^ 3 * 15 + x ^ 2 * 20) \u2264 5 * y ^ 5 + (y ^ 3 * 15 + y ^ 2 * 20)",
            "endPos": {
                "line": 409,
                "column": 16
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 161,
            "pos": {
                "line": 413,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 12 * x ^ 5 + 15 * x ^ 4 + 4 * x ^ 2 + 11 * x + 4) sorry",
            "endPos": {
                "line": 413,
                "column": 49
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.add",
            "proofState": 162,
            "pos": {
                "line": 414,
                "column": 2
            },
            "goals": "case refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\ncase refine'_2\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 12 * x ^ 5 + 15 * x ^ 4 + 4 * x ^ 2 + 11 * x + 4) ?refine'_1",
            "endPos": {
                "line": 414,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 163,
            "pos": {
                "line": 424,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) sorry",
            "endPos": {
                "line": 424,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 2 + 7 / 10), sq_nonneg (y ^ 2 + 7 / 10), sq_nonneg (x - y), sq_nonneg (x + y),\n  sq_nonneg (x + y - 1), sq_nonneg (x + y + 1)]",
            "proofState": 164,
            "pos": {
                "line": 425,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) x \u2264 (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 426,
                "column": 68
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 165,
            "pos": {
                "line": 429,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) sorry",
            "endPos": {
                "line": 429,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx",
            "proofState": 166,
            "pos": {
                "line": 430,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 430,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro y hy",
            "proofState": 167,
            "pos": {
                "line": 431,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) x \u2264\n          (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) b\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 431,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp_all only [Set.mem_Icc, and_imp]",
            "proofState": 168,
            "pos": {
                "line": 432,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) x \u2264\n      (fun x => 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x) y\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 432,
                "column": 38
            }
        },
        {
            "usedConstants": [
                "Preorder.toLE",
                "LE.le",
                "Nat.instPreorder",
                "Nat"
            ],
            "tactic": "intro hx0 hx1 hy0 hy1",
            "proofState": 169,
            "pos": {
                "line": 433,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x \u2264 18 * y ^ 7 + 10 * y ^ 5 + 13 * y ^ 4 + 3 * y\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 433,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 170,
            "pos": {
                "line": 437,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) sorry",
            "endPos": {
                "line": 437,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 171,
            "pos": {
                "line": 438,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 438,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x + y), sq_nonneg (x - y)]",
            "proofState": 172,
            "pos": {
                "line": 439,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) x \u2264\n    (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 439,
                "column": 104
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 173,
            "pos": {
                "line": 443,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 12 * x ^ 4 + 18 * x ^ 3 + 8) sorry",
            "endPos": {
                "line": 443,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "instHMul",
                "Set"
            ],
            "tactic": "exact fun _ hx _ _ h => by\n  nlinarith [sq_nonneg (x - 1), sq_nonneg (x - 2), sq_nonneg (x - 3), sq_nonneg (x + 1), sq_nonneg (x + 2),\n    sq_nonneg (x + 3)]",
            "proofState": 174,
            "pos": {
                "line": 444,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 6 * x ^ 7 + 12 * x ^ 4 + 18 * x ^ 3 + 8) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 446,
                "column": 62
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - 1), sq_nonneg (x - 2), sq_nonneg (x - 3), sq_nonneg (x + 1), sq_nonneg (x + 2),\n  sq_nonneg (x + 3)]",
            "proofState": 175,
            "pos": {
                "line": 445,
                "column": 4
            },
            "goals": "x\u271d\u00b3 : Sort u_1\nIcc : x\u271d\u00b3\nx\u271d\u00b2 : \u2115\nhx : x\u271d\u00b2 \u2208 ?s\nx\u271d\u00b9 : \u2115\nx\u271d : x\u271d\u00b9 \u2208 ?s\nh : x\u271d\u00b2 \u2264 x\u271d\u00b9\n\u22a2 6 * x\u271d\u00b2 ^ 7 + 12 * x\u271d\u00b2 ^ 4 + 18 * x\u271d\u00b2 ^ 3 + 8 \u2264 6 * x\u271d\u00b9 ^ 7 + 12 * x\u271d\u00b9 ^ 4 + 18 * x\u271d\u00b9 ^ 3 + 8",
            "endPos": {
                "line": 446,
                "column": 62
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 176,
            "pos": {
                "line": 449,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 9 * x ^ 5 + 5 * x ^ 3) sorry",
            "endPos": {
                "line": 449,
                "column": 47
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.add",
            "proofState": 177,
            "pos": {
                "line": 450,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 9 * x ^ 5 + 5 * x ^ 3) ?m.1526580",
            "endPos": {
                "line": 450,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 178,
            "pos": {
                "line": 454,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3) sorry",
            "endPos": {
                "line": 454,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 179,
            "pos": {
                "line": 455,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 455,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp only [Function.comp_apply, Icc_subset_Icc_iff] at hx hy \u22a2",
            "proofState": 180,
            "pos": {
                "line": 456,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 (fun x => 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3) x \u2264\n    (fun x => 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3) y\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 456,
                "column": 64
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "Preorder.toLT",
                "Nat.instIsOrderedAddMonoid",
                "HMul.hMul",
                "IsRightCancelAdd.addRightReflectLE_of_addRightReflectLT",
                "Nat.instMonoid",
                "covariant_swap_add_of_covariant_add",
                "PartialOrder.toPreorder",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "contravariant_lt_of_covariant_le",
                "LE.le",
                "instHAdd",
                "Nat.instIsOrderedCancelAddMonoid",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "_private.Mathlib.Algebra.Order.Monoid.Unbundled.Basic.0._proof_4",
                "Nat",
                "LT.lt",
                "Nat.instPartialOrder",
                "instAddNat",
                "Nat.instAddCommMonoid",
                "contravariant_swap_add_of_contravariant_add",
                "AddCommSemigroup.toAddCommMagma",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "IsOrderedCancelAddMonoid.toIsCancelAdd",
                "IsCancelAdd.toIsRightCancelAdd",
                "Nat.instAddCommSemigroup",
                "AddCommMagma.toAdd",
                "IsOrderedAddMonoid.toAddLeftMono",
                "instHMul",
                "Nat.instLinearOrder"
            ],
            "tactic": "norm_num",
            "proofState": 181,
            "pos": {
                "line": 457,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x + 3 \u2264\n    19 * y ^ 7 + 15 * y ^ 5 + 15 * y ^ 3 + 15 * y ^ 2 + 7 * y + 3\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 457,
                "column": 10
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 182,
            "pos": {
                "line": 458,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x \u2264 19 * y ^ 7 + 15 * y ^ 5 + 15 * y ^ 3 + 15 * y ^ 2 + 7 * y\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 458,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 183,
            "pos": {
                "line": 461,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) sorry",
            "endPos": {
                "line": 461,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 184,
            "pos": {
                "line": 462,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) x \u2264\n    (fun x => 12 * x ^ 7 + 11 * x ^ 6 + 13 * x ^ 5 + 8 * x ^ 4 + 5 * x ^ 3 + 8 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 462,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 185,
            "pos": {
                "line": 473,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 7 * x ^ 5 + 12 * x ^ 4 + 9 * x ^ 3 + 18 * x ^ 2 + 12 * x + 16) sorry",
            "endPos": {
                "line": 473,
                "column": 61
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.add",
            "proofState": 186,
            "pos": {
                "line": 474,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 6 + 7 * x ^ 5 + 12 * x ^ 4 + 9 * x ^ 3 + 18 * x ^ 2 + 12 * x + 16) ?m.1616064",
            "endPos": {
                "line": 474,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 187,
            "pos": {
                "line": 483,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 7 + 6 * x ^ 6 + 17 * x ^ 3 + 12 * x ^ 2 + 9 * x) sorry",
            "endPos": {
                "line": 483,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Icc_def, le_iff_exists_add] at hx hy",
            "proofState": 188,
            "pos": {
                "line": 484,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 7 + 6 * x ^ 6 + 17 * x ^ 3 + 12 * x ^ 2 + 9 * x) x \u2264\n    (fun x => 15 * x ^ 7 + 6 * x ^ 6 + 17 * x ^ 3 + 12 * x ^ 2 + 9 * x) y",
            "endPos": {
                "line": 484,
                "column": 49
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 189,
            "pos": {
                "line": 491,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 12 * x ^ 6 + 12 * x ^ 5 + 3 * x ^ 4 + 7 * x) sorry",
            "endPos": {
                "line": 491,
                "column": 61
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 190,
            "pos": {
                "line": 492,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 12 * x ^ 6 + 12 * x ^ 5 + 3 * x ^ 4 + 7 * x) ?m.1645318",
            "endPos": {
                "line": 492,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 191,
            "pos": {
                "line": 496,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7) sorry",
            "endPos": {
                "line": 496,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp_all only [Icc_subset_Icc_iff, le_refl, true_and_iff, le_of_eq, zero_le_one, zero_le_two, zero_le_three,\n  zero_le_four, zero_le_five, zero_le_six, zero_le_seven, zero_le_eight, zero_le_nine, zero_le_ten]",
            "proofState": 192,
            "pos": {
                "line": 497,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7) x \u2264 (fun x => 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7) y",
            "endPos": {
                "line": 499,
                "column": 60
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y)]",
            "proofState": 193,
            "pos": {
                "line": 500,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7 \u2264 15 * y ^ 6 + 5 * y ^ 3 + 16 * y ^ 2 + 7",
            "endPos": {
                "line": 500,
                "column": 31
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.const_add",
            "proofState": 194,
            "pos": {
                "line": 503,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 16 * x ^ 7 + 20 * x ^ 4 + 4 * x ^ 2 + 18 * x + 15) sorry",
            "endPos": {
                "line": 503,
                "column": 28
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "Unit.unit",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "Preorder.toLE",
                "two_mul",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Lean.Name.num",
                "LE.le",
                "Nat.instNonAssocSemiring",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "Function.const",
                "NonUnitalNonAssocSemiring.toDistrib",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Set.instMembership",
                "instOfNatAtLeastTwo",
                "Nat.instCommSemigroup",
                "instHMul",
                "Set"
            ],
            "tactic": "exact fun x hx y hy hxy \u21a6\n  by\n  simp only [two_mul, mul_add, mul_one, mul_assoc, mul_comm, mul_left_comm]\n  nlinarith [sq_nonneg (x ^ 2), sq_nonneg (y ^ 2), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 195,
            "pos": {
                "line": 515,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 2 * x ^ 7 + 19 * x ^ 5 + 4 * x ^ 3 + 20 * x) sorry",
            "endPos": {
                "line": 517,
                "column": 98
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "Preorder.toLE",
                "two_mul",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "LE.le",
                "Nat.instNonAssocSemiring",
                "instHAdd",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "NonUnitalNonAssocSemiring.toDistrib",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "instOfNatAtLeastTwo",
                "Nat.instCommSemigroup",
                "instHMul"
            ],
            "tactic": "simp only [two_mul, mul_add, mul_one, mul_assoc, mul_comm, mul_left_comm]",
            "proofState": 196,
            "pos": {
                "line": 516,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 2 * x ^ 7 + 19 * x ^ 5 + 4 * x ^ 3 + 20 * x) x \u2264 (fun x => 2 * x ^ 7 + 19 * x ^ 5 + 4 * x ^ 3 + 20 * x) y",
            "endPos": {
                "line": 516,
                "column": 77
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 2), sq_nonneg (y ^ 2), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 197,
            "pos": {
                "line": 517,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 x ^ 7 + x ^ 7 + x ^ 5 * 19 + x ^ 3 * 4 + x * 20 \u2264 y ^ 7 + y ^ 7 + y ^ 5 * 19 + y ^ 3 * 4 + y * 20",
            "endPos": {
                "line": 517,
                "column": 98
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 198,
            "pos": {
                "line": 520,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) sorry",
            "endPos": {
                "line": 520,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 199,
            "pos": {
                "line": 521,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 521,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 200,
            "pos": {
                "line": 522,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) x \u2264\n    (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) y",
            "endPos": {
                "line": 522,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 201,
            "pos": {
                "line": 527,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) sorry",
            "endPos": {
                "line": 527,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 202,
            "pos": {
                "line": 528,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) x \u2264\n    (fun x => 13 * x ^ 6 + 13 * x ^ 5 + 17 * x ^ 4 + 17 * x ^ 3 + 7 * x ^ 2 + 10 * x + 2) y",
            "endPos": {
                "line": 528,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _",
            "proofState": 203,
            "pos": {
                "line": 537,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 9 * x ^ 5 + 11 * x ^ 4 + 8 * x ^ 2 + 20 * x) sorry",
            "endPos": {
                "line": 537,
                "column": 25
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 204,
            "pos": {
                "line": 538,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?m.1790210\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 9 * x ^ 5 + 11 * x ^ 4 + 8 * x ^ 2 + 20 * x) ?m.1790210",
            "endPos": {
                "line": 538,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 205,
            "pos": {
                "line": 546,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) sorry",
            "endPos": {
                "line": 546,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 206,
            "pos": {
                "line": 547,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) x \u2264\n    (fun x => 2 * x ^ 6 + 4 * x ^ 4 + 11 * x ^ 2 + 19 * x + 3) y",
            "endPos": {
                "line": 547,
                "column": 30
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.mono _ (Set.Icc_subset_Icc_right (by norm_num : (2 : \u211d) \u2264 2))",
            "proofState": 207,
            "pos": {
                "line": 552,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 9 * x ^ 5 + 14 * x ^ 4 + 12 * x + 10) sorry",
            "endPos": {
                "line": 552,
                "column": 80
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 208,
            "pos": {
                "line": 559,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) sorry",
            "endPos": {
                "line": 559,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 209,
            "pos": {
                "line": 560,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) x \u2264\n    (fun x => 20 * x ^ 6 + 4 * x ^ 5 + 8 * x ^ 4 + 3 * x ^ 3 + 20 * x ^ 2 + 8 * x) y",
            "endPos": {
                "line": 560,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_right (by norm_num))",
            "proofState": 210,
            "pos": {
                "line": 564,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 5 + 16 * x ^ 4) sorry",
            "endPos": {
                "line": 564,
                "column": 62
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 211,
            "pos": {
                "line": 565,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 5 + 16 * x ^ 4) ?m.1836875",
            "endPos": {
                "line": 565,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 212,
            "pos": {
                "line": 574,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) sorry",
            "endPos": {
                "line": 574,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx",
            "proofState": 213,
            "pos": {
                "line": 575,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 575,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro y hy",
            "proofState": 214,
            "pos": {
                "line": 576,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) x \u2264\n          (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) b\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 576,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Nat.instMonoid",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Nat.instAddMonoid",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "instMulNat",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "AddMonoidWithOne.toOne",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "implies_congr",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "instAddNat",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "instOfNatAtLeastTwo",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul"
            ],
            "tactic": "ring_nf",
            "proofState": 215,
            "pos": {
                "line": 577,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) x \u2264\n      (fun x => 4 * x ^ 7 + 4 * x ^ 5 + 9 * x ^ 3 + 20 * x ^ 2 + 17 * x + 8) y\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 577,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num",
            "proofState": 216,
            "pos": {
                "line": 578,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    8 + x * 17 + x ^ 2 * 20 + x ^ 3 * 9 + x ^ 5 * 4 + x ^ 7 * 4 \u2264\n      8 + y * 17 + y ^ 2 * 20 + y ^ 3 * 9 + y ^ 5 * 4 + y ^ 7 * 4\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 578,
                "column": 10
            }
        },
        {
            "usedConstants": [
                "Preorder.toLE",
                "LE.le",
                "Nat.instPreorder",
                "Nat"
            ],
            "tactic": "intro h",
            "proofState": 217,
            "pos": {
                "line": 579,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    8 + x * 17 + x ^ 2 * 20 + x ^ 3 * 9 + x ^ 5 * 4 + x ^ 7 * 4 \u2264\n      8 + y * 17 + y ^ 2 * 20 + y ^ 3 * 9 + y ^ 5 * 4 + y ^ 7 * 4\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 579,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [hx.1, hx.2, hy.1, hy.2, h]",
            "proofState": 218,
            "pos": {
                "line": 580,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nh : x \u2264 y\n\u22a2 8 + x * 17 + x ^ 2 * 20 + x ^ 3 * 9 + x ^ 5 * 4 + x ^ 7 * 4 \u2264\n    8 + y * 17 + y ^ 2 * 20 + y ^ 3 * 9 + y ^ 5 * 4 + y ^ 7 * 4\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 580,
                "column": 39
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 219,
            "pos": {
                "line": 583,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) sorry",
            "endPos": {
                "line": 583,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have hx' : 0 \u2264 x := by\n  cases' hx with hx\u2081 hx\u2082\n  nlinarith",
            "proofState": 220,
            "pos": {
                "line": 584,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x \u2264 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y",
            "endPos": {
                "line": 586,
                "column": 13
            }
        },
        {
            "usedConstants": [],
            "tactic": "cases' hx with hx\u2081 hx\u2082",
            "proofState": 221,
            "pos": {
                "line": 585,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 585,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have hy' : 0 \u2264 y := by\n  cases' hy with hy\u2081 hy\u2082\n  nlinarith",
            "proofState": 222,
            "pos": {
                "line": 587,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x \u2264 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y",
            "endPos": {
                "line": 589,
                "column": 13
            }
        },
        {
            "usedConstants": [],
            "tactic": "cases' hy with hy\u2081 hy\u2082",
            "proofState": 223,
            "pos": {
                "line": 588,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\n\u22a2 0 \u2264 y",
            "endPos": {
                "line": 588,
                "column": 26
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "letFun",
                "instHMul"
            ],
            "tactic": "have hxy' : x \u2264 y := by nlinarith",
            "proofState": 224,
            "pos": {
                "line": 590,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x \u2264 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y",
            "endPos": {
                "line": 591,
                "column": 13
            }
        },
        {
            "usedConstants": [
                "le_of_not_gt"
            ],
            "tactic": "nlinarith",
            "proofState": 225,
            "pos": {
                "line": 591,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\n\u22a2 x \u2264 y",
            "endPos": {
                "line": 591,
                "column": 13
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 + y ^ 2)]",
            "proofState": 226,
            "pos": {
                "line": 592,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : x \u2264 y\n\u22a2 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x \u2264 (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y",
            "endPos": {
                "line": 593,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 227,
            "pos": {
                "line": 596,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) sorry",
            "endPos": {
                "line": 596,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 228,
            "pos": {
                "line": 597,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) x \u2264\n    (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) y",
            "endPos": {
                "line": 597,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 229,
            "pos": {
                "line": 600,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) sorry",
            "endPos": {
                "line": 600,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mem_Icc] at hx hy",
            "proofState": 230,
            "pos": {
                "line": 601,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) x \u2264\n    (fun x => 18 * x ^ 7 + 5 * x ^ 6 + 15 * x ^ 4 + 3 * x ^ 2 + 7 * x) y",
            "endPos": {
                "line": 601,
                "column": 30
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 231,
            "pos": {
                "line": 607,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) sorry",
            "endPos": {
                "line": 607,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "letFun",
                "instHMul",
                "Set"
            ],
            "tactic": "have hx' := hx",
            "proofState": 232,
            "pos": {
                "line": 608,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) x \u2264 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) y",
            "endPos": {
                "line": 608,
                "column": 16
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "letFun",
                "instHMul",
                "Set"
            ],
            "tactic": "have hy' := hy",
            "proofState": 233,
            "pos": {
                "line": 608,
                "column": 18
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nhx' : x \u2208 sorry\n\u22a2 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) x \u2264 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) y",
            "endPos": {
                "line": 608,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp_all only [Set.mem_Icc]",
            "proofState": 234,
            "pos": {
                "line": 609,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nhx' : x \u2208 sorry\nhy' : y \u2208 sorry\n\u22a2 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) x \u2264 (fun x => 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14) y",
            "endPos": {
                "line": 609,
                "column": 29
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 + y ^ 2)]",
            "proofState": 235,
            "pos": {
                "line": 610,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx y : \u2115\nh : x \u2264 y\nhx' : x \u2208 sorry\nhy' : y \u2208 sorry\n\u22a2 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14 \u2264 7 * y ^ 6 + 7 * y ^ 4 + 5 * y ^ 2 + 14",
            "endPos": {
                "line": 610,
                "column": 104
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 236,
            "pos": {
                "line": 613,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) sorry",
            "endPos": {
                "line": 613,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 237,
            "pos": {
                "line": 614,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) x \u2264\n    (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) y",
            "endPos": {
                "line": 614,
                "column": 85
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 238,
            "pos": {
                "line": 617,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 6 + 16 * x ^ 4 + 5 * x ^ 3 + 19 * x ^ 2) sorry",
            "endPos": {
                "line": 617,
                "column": 47
            }
        },
        {
            "usedConstants": [],
            "tactic": "exact fun x hx y hy hxy => by\n  nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x + y), sq_nonneg (x - y)]",
            "proofState": 239,
            "pos": {
                "line": 618,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 6 + 16 * x ^ 4 + 5 * x ^ 3 + 19 * x ^ 2) ?m.2046402",
            "endPos": {
                "line": 620,
                "column": 43
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x + y), sq_nonneg (x - y)]",
            "proofState": 240,
            "pos": {
                "line": 619,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : ?m.2046761 x\ny : ?m.2046762 x hx\nhy : ?m.2046763 x hx y\nhxy : ?m.2046764 x hx y hy\n\u22a2 ?m.2046765 x hx y hy hxy",
            "endPos": {
                "line": 620,
                "column": 43
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ <| Icc_subset_Icc_right (by norm_num)",
            "proofState": 241,
            "pos": {
                "line": 623,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 5 + 19 * x ^ 4 + 6 * x ^ 3 + 12 * x + 14) sorry",
            "endPos": {
                "line": 623,
                "column": 63
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 242,
            "pos": {
                "line": 624,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 5 + 19 * x ^ 4 + 6 * x ^ 3 + 12 * x + 14) ?m.2089546",
            "endPos": {
                "line": 624,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 243,
            "pos": {
                "line": 630,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 3 * x ^ 5 + 8 * x ^ 4 + 4 * x ^ 3 + 20 * x) sorry",
            "endPos": {
                "line": 630,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "MonotoneOn",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 244,
            "pos": {
                "line": 631,
                "column": 6
            },
            "goals": "case hf\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 7 + 3 * x ^ 5 + 8 * x ^ 4 + 4 * x ^ 3) sorry",
            "endPos": {
                "line": 631,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "sorryAx",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "MonotoneOn",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.const_mul",
            "proofState": 245,
            "pos": {
                "line": 631,
                "column": 6
            },
            "goals": "case hg\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (HMul.hMul 20) sorry",
            "endPos": {
                "line": 631,
                "column": 32
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ Icc_subset_Icc_right",
            "proofState": 246,
            "pos": {
                "line": 640,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 2 * x ^ 6 + 9 * x ^ 5 + 10 * x + 13) sorry",
            "endPos": {
                "line": 640,
                "column": 46
            }
        },
        {
            "usedConstants": [],
            "tactic": "refine' MonotoneOn.add _ _",
            "proofState": 247,
            "pos": {
                "line": 641,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 641,
                "column": 28
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 248,
            "pos": {
                "line": 650,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3) sorry",
            "endPos": {
                "line": 650,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp_all only [Icc_subset_Icc_iff, le_refl, true_and, le_of_lt, and_true]",
            "proofState": 249,
            "pos": {
                "line": 651,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3) x \u2264\n    (fun x => 17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3) y",
            "endPos": {
                "line": 651,
                "column": 75
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x ^ 2 - x * y),\n  sq_nonneg (x * y - y ^ 2)]",
            "proofState": 250,
            "pos": {
                "line": 652,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3 \u2264\n    17 * y ^ 7 + 11 * y ^ 5 + 20 * y ^ 4 + 7 * y ^ 3 + 6 * y ^ 2 + 12 * y + 3",
            "endPos": {
                "line": 653,
                "column": 57
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 251,
            "pos": {
                "line": 656,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 4 + 19 * x + 13) sorry",
            "endPos": {
                "line": 656,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 252,
            "pos": {
                "line": 657,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 15 * x ^ 4 + 19 * x + 13) ?m.2191708",
            "endPos": {
                "line": 657,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "refine' MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 253,
            "pos": {
                "line": 663,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) sorry",
            "endPos": {
                "line": 663,
                "column": 63
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 254,
            "pos": {
                "line": 664,
                "column": 2
            },
            "goals": "case refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\ncase refine'_2\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 4 + 6 * x ^ 3 + 14 * x ^ 2 + 6) ?refine'_1",
            "endPos": {
                "line": 664,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "apply MonotoneOn.mono _ (Set.Icc_subset_Ici_self)",
            "proofState": 255,
            "pos": {
                "line": 669,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 6 + 9 * x ^ 5 + 14 * x ^ 4 + 3 * x ^ 2 + 17) sorry",
            "endPos": {
                "line": 669,
                "column": 51
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 256,
            "pos": {
                "line": 680,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 14 * x ^ 4 + 18 * x ^ 3 + 3 * x ^ 2 + 8 * x) sorry",
            "endPos": {
                "line": 680,
                "column": 61
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 257,
            "pos": {
                "line": 681,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 11 * x ^ 7 + 14 * x ^ 4 + 18 * x ^ 3 + 3 * x ^ 2 + 8 * x) ?m.2231651",
            "endPos": {
                "line": 681,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ <| Icc_subset_Icc (by norm_num) (by norm_num)",
            "proofState": 258,
            "pos": {
                "line": 688,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 3 * x ^ 7 + 19 * x ^ 5 + 13 * x ^ 4 + 4 * x ^ 2 + 8 * x + 12) sorry",
            "endPos": {
                "line": 688,
                "column": 71
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 259,
            "pos": {
                "line": 689,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 3 * x ^ 7 + 19 * x ^ 5 + 13 * x ^ 4 + 4 * x ^ 2 + 8 * x + 12) ?m.2247492",
            "endPos": {
                "line": 689,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 260,
            "pos": {
                "line": 694,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 13 * x ^ 2 + 12 * x) sorry",
            "endPos": {
                "line": 694,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Icc_def, mem_setOf_eq] at hx hy",
            "proofState": 261,
            "pos": {
                "line": 695,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 13 * x ^ 2 + 12 * x) x \u2264 (fun x => 13 * x ^ 2 + 12 * x) y",
            "endPos": {
                "line": 695,
                "column": 44
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 262,
            "pos": {
                "line": 699,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 3 * x ^ 7 + 13 * x ^ 6 + 18 * x ^ 5 + 15 * x ^ 4 + 9 * x ^ 3 + 17 * x ^ 2 + 6 * x) sorry",
            "endPos": {
                "line": 699,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 263,
            "pos": {
                "line": 700,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 3 * x ^ 7 + 13 * x ^ 6 + 18 * x ^ 5 + 15 * x ^ 4 + 9 * x ^ 3 + 17 * x ^ 2 + 6 * x) ?m.2275155",
            "endPos": {
                "line": 700,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 264,
            "pos": {
                "line": 705,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 6 + 14 * x ^ 5 + 3 * x ^ 4 + 13 * x ^ 2) sorry",
            "endPos": {
                "line": 705,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 265,
            "pos": {
                "line": 706,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 6 + 14 * x ^ 5 + 3 * x ^ 4 + 13 * x ^ 2) ?m.2288134",
            "endPos": {
                "line": 706,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 266,
            "pos": {
                "line": 719,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2 + 2 * x) sorry",
            "endPos": {
                "line": 719,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 267,
            "pos": {
                "line": 720,
                "column": 2
            },
            "goals": "case hf\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) sorry\ncase hg\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (HMul.hMul 2) sorry",
            "endPos": {
                "line": 720,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y), sq_nonneg (x ^ 5 - y ^ 5),\n  sq_nonneg (x ^ 7 - y ^ 7)]",
            "proofState": 268,
            "pos": {
                "line": 721,
                "column": 2
            },
            "goals": "case hf\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) x \u2264\n    (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) y\ncase hg\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (HMul.hMul 2) sorry",
            "endPos": {
                "line": 722,
                "column": 76
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 269,
            "pos": {
                "line": 732,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 2 + 8 * x + 7) sorry",
            "endPos": {
                "line": 732,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.add"
            ],
            "tactic": "apply MonotoneOn.add",
            "proofState": 270,
            "pos": {
                "line": 733,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 2 + 8 * x + 7) ?s",
            "endPos": {
                "line": 733,
                "column": 22
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Set.instMembership",
                "Nat.instCommSemigroup",
                "instHMul",
                "Set"
            ],
            "tactic": "<failed to pretty print>",
            "proofState": 271,
            "pos": {
                "line": 734,
                "column": 6
            },
            "goals": "case h.hf\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 4 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 2 + 8 * x) ?s",
            "endPos": {
                "line": 737,
                "column": 35
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "HMul.hMul",
                "congrArg",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "CommMagma.toMul",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "congr",
                "CommSemigroup.toCommMagma",
                "mul_comm",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "Eq",
                "Nat.instCommSemigroup",
                "instHMul"
            ],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm]",
            "proofState": 272,
            "pos": {
                "line": 735,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 4 * x ^ 7 + 7 * x ^ 6 + 3 * x ^ 2 + 8 * x \u2264 4 * y ^ 7 + 7 * y ^ 6 + 3 * y ^ 2 + 8 * y",
            "endPos": {
                "line": 735,
                "column": 50
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y)]",
            "proofState": 273,
            "pos": {
                "line": 736,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 4 * x ^ 7 + x ^ 6 * 7 + x ^ 2 * 3 + x * 8 \u2264 4 * y ^ 7 + y ^ 6 * 7 + y ^ 2 * 3 + y * 8",
            "endPos": {
                "line": 736,
                "column": 87
            }
        },
        {
            "usedConstants": [
                "Preorder.toLE",
                "Membership.mem",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Nat.instPreorder",
                "Nat",
                "Lean.Name",
                "OfNat.ofNat",
                "Set.instMembership",
                "Set"
            ],
            "tactic": "<failed to pretty print>",
            "proofState": 274,
            "pos": {
                "line": 734,
                "column": 6
            },
            "goals": "case h.hg\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 7) ?s",
            "endPos": {
                "line": 737,
                "column": 35
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [mul_assoc, mul_comm, mul_left_comm]",
            "proofState": 275,
            "pos": {
                "line": 735,
                "column": 4
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\n\u22a2 7 \u2264 7",
            "endPos": {
                "line": 735,
                "column": 50
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 276,
            "pos": {
                "line": 748,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) sorry",
            "endPos": {
                "line": 748,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx",
            "proofState": 277,
            "pos": {
                "line": 749,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 749,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro y hy",
            "proofState": 278,
            "pos": {
                "line": 750,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) x \u2264\n          (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) b\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 750,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Monoid.toNatPow",
                "id",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "instHMul"
            ],
            "tactic": "simp only [Set.mem_Icc] at hx hy \u22a2",
            "proofState": 279,
            "pos": {
                "line": 751,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) x \u2264\n      (fun x => 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20) y\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 751,
                "column": 36
            }
        },
        {
            "usedConstants": [
                "Preorder.toLE",
                "LE.le",
                "Nat.instPreorder",
                "Nat"
            ],
            "tactic": "intro h",
            "proofState": 280,
            "pos": {
                "line": 752,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\n\u22a2 x \u2264 y \u2192\n    13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20 \u2264\n      13 * y ^ 7 + 4 * y ^ 6 + 16 * y ^ 5 + 11 * y ^ 4 + 5 * y ^ 3 + 15 * y ^ 2 + 20\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 752,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 3 + y ^ 3),\n  sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x ^ 2 + y ^ 2)]",
            "proofState": 281,
            "pos": {
                "line": 753,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nh : x \u2264 y\n\u22a2 13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20 \u2264\n    13 * y ^ 7 + 4 * y ^ 6 + 16 * y ^ 5 + 11 * y ^ 4 + 5 * y ^ 3 + 15 * y ^ 2 + 20\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 754,
                "column": 84
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Icc_left (by norm_num))",
            "proofState": 282,
            "pos": {
                "line": 757,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 4 + 14 * x ^ 3 + 8 * x ^ 2 + 13 * x + 11) sorry",
            "endPos": {
                "line": 757,
                "column": 61
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat",
                "Set"
            ],
            "tactic": "exact\n  MonotoneOn.of_deriv_nonneg\n    (by\n      intro x hx\n      simp\n      nlinarith [sq_nonneg x, sq_nonneg (x + 1 / 3), sq_nonneg (x + 2 / 3), sq_nonneg (x + 1), sq_nonneg (x + 4 / 3),\n        sq_nonneg (x + 5 / 3), sq_nonneg (x + 2), sq_nonneg (x + 7 / 3), sq_nonneg (x + 8 / 3), sq_nonneg (x + 3),\n        sq_nonneg (x + 9 / 3), sq_nonneg (x + 10 / 3)])\n    (by\n      intro x hx\n      simp\n      nlinarith [sq_nonneg x, sq_nonneg (x + 1 / 3), sq_nonneg (x + 2 / 3), sq_nonneg (x + 1), sq_nonneg (x + 4 / 3),\n        sq_nonneg (x + 5 / 3), sq_nonneg (x + 2), sq_nonneg (x + 7 / 3), sq_nonneg (x + 8 / 3), sq_nonneg (x + 3),\n        sq_nonneg (x + 9 / 3), sq_nonneg (x + 10 / 3)])",
            "proofState": 283,
            "pos": {
                "line": 758,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 4 + 14 * x ^ 3 + 8 * x ^ 2 + 13 * x + 11) ?m.2453964",
            "endPos": {
                "line": 775,
                "column": 9
            }
        },
        {
            "usedConstants": [
                "MonotoneOn.mono"
            ],
            "tactic": "apply MonotoneOn.mono",
            "proofState": 284,
            "pos": {
                "line": 778,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) sorry",
            "endPos": {
                "line": 778,
                "column": 23
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx",
            "proofState": 285,
            "pos": {
                "line": 779,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) ?s\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 779,
                "column": 12
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "letFun",
                "instHMul",
                "Set"
            ],
            "tactic": "have h1 : 0 \u2264 x := by exact hx.1",
            "proofState": 286,
            "pos": {
                "line": 780,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) x \u2264\n          (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) b\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 780,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat"
            ],
            "tactic": "exact hx.1",
            "proofState": 287,
            "pos": {
                "line": 780,
                "column": 24
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\n\u22a2 0 \u2264 x",
            "endPos": {
                "line": 780,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "HMul.hMul",
                "Nat.instMonoid",
                "Preorder.toLE",
                "Membership.mem",
                "Monoid.toNatPow",
                "instMulNat",
                "instOfNatNat",
                "LE.le",
                "instLENat",
                "instHAdd",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "instAddNat",
                "instHPow",
                "OfNat.ofNat",
                "Set.instMembership",
                "letFun",
                "instHMul",
                "Set"
            ],
            "tactic": "have h2 : x \u2264 1 := by exact hx.2",
            "proofState": 288,
            "pos": {
                "line": 781,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\nh1 : 0 \u2264 x\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) x \u2264\n          (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) b\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 781,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "sorryAx",
                "instOfNatNat",
                "Lean.Name.num",
                "LE.le",
                "instLENat",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "Unit",
                "Nat",
                "Function.const",
                "Lean.Name",
                "OfNat.ofNat"
            ],
            "tactic": "exact hx.2",
            "proofState": 289,
            "pos": {
                "line": 781,
                "column": 24
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\nh1 : 0 \u2264 x\n\u22a2 x \u2264 1",
            "endPos": {
                "line": 781,
                "column": 34
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [pow_nonneg h1 7, pow_nonneg h1 6, pow_nonneg h1 4, pow_nonneg h1 3]",
            "proofState": 290,
            "pos": {
                "line": 782,
                "column": 2
            },
            "goals": "case h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\nh1 : 0 \u2264 x\nh2 : x \u2264 1\n\u22a2 \u2200 \u2983b : \u2115\u2984,\n    b \u2208 ?s \u2192\n      x \u2264 b \u2192\n        (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) x \u2264\n          (fun x => 8 * x ^ 7 + 10 * x ^ 6 + 11 * x ^ 4 + 10 * x ^ 3 + 13) b\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115",
            "endPos": {
                "line": 782,
                "column": 80
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy h",
            "proofState": 291,
            "pos": {
                "line": 785,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) sorry",
            "endPos": {
                "line": 785,
                "column": 19
            }
        },
        {
            "usedConstants": [],
            "tactic": "norm_num at hx hy",
            "proofState": 292,
            "pos": {
                "line": 786,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) x \u2264\n    (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) y",
            "endPos": {
                "line": 786,
                "column": 19
            }
        },
        {
            "usedConstants": [
                "Eq.mpr",
                "NonAssocSemiring.toAddCommMonoidWithOne",
                "Mathlib.Tactic.Ring.single_pow",
                "Mathlib.Tactic.RingNF.add_assoc_rev",
                "HMul.hMul",
                "Nat.rawCast",
                "Mathlib.Tactic.Ring.mul_zero",
                "Mathlib.Tactic.Ring.mul_pf_left",
                "Mathlib.Tactic.Ring.add_pf_add_gt",
                "congrArg",
                "CommSemiring.toSemiring",
                "Mathlib.Tactic.Ring.mul_pow",
                "Nat.instMonoid",
                "Mathlib.Tactic.Ring.mul_pf_right",
                "AddMonoid.toAddZeroClass",
                "Mathlib.Tactic.Ring.one_mul",
                "Mathlib.Tactic.Ring.zero_mul",
                "NonUnitalNonAssocSemiring.toMulZeroClass",
                "Preorder.toLE",
                "Nat.instAddMonoid",
                "Mathlib.Tactic.Ring.instCommSemiringNat",
                "Monoid.toNatPow",
                "id",
                "Distrib.toAdd",
                "AddMonoidWithOne.toNatCast",
                "instMulNat",
                "instOfNatNat",
                "AddCommMonoidWithOne.toAddMonoidWithOne",
                "Mathlib.Meta.NormNum.isNat_ofNat",
                "LE.le",
                "Mathlib.Tactic.Ring.one_pow",
                "Nat.instAddMonoidWithOne",
                "Mathlib.Tactic.Ring.mul_congr",
                "AddMonoidWithOne.toOne",
                "Mathlib.Tactic.Ring.add_mul",
                "instHAdd",
                "Mathlib.Tactic.Ring.add_pf_add_zero",
                "instNatAtLeastTwo",
                "HPow.hPow",
                "Distrib.toMul",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "pow_one",
                "NonAssocSemiring.toNonUnitalNonAssocSemiring",
                "Mathlib.Tactic.Ring.pow_add",
                "Nat",
                "Mathlib.Tactic.Ring.mul_one",
                "congr",
                "AddZeroClass.toZero",
                "Nat.instCommSemiring",
                "One.toOfNat1",
                "NonUnitalNonAssocSemiring.toDistrib",
                "instAddNat",
                "Zero.toOfNat0",
                "Eq.refl",
                "instHPow",
                "Mathlib.Tactic.Ring.cast_pos",
                "Mathlib.Tactic.RingNF.nat_rawCast_1",
                "Mathlib.Tactic.Ring.atom_pf",
                "add_zero",
                "OfNat.ofNat",
                "AddZeroClass.toAdd",
                "Semiring.toNonAssocSemiring",
                "Eq",
                "instOfNatAtLeastTwo",
                "MonoidWithZero.toMonoid",
                "Mathlib.Tactic.Ring.mul_add",
                "Eq.trans",
                "MulZeroClass.toZero",
                "Mathlib.Tactic.Ring.add_congr",
                "Mathlib.Tactic.Ring.pow_congr",
                "Mathlib.Tactic.Ring.pow_zero",
                "Semiring.toMonoidWithZero",
                "instHMul"
            ],
            "tactic": "ring_nf",
            "proofState": 293,
            "pos": {
                "line": 787,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry ()\ny : \u2115\nhy : y \u2208 sorry ()\nh : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) x \u2264\n    (fun x => 5 * x ^ 7 + 17 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 2 + 2 * x + 10) y",
            "endPos": {
                "line": 787,
                "column": 9
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x - y), sq_nonneg (x + y), sq_nonneg (x - 1), sq_nonneg (y - 1), sq_nonneg (x + 1),\n  sq_nonneg (y + 1)]",
            "proofState": 294,
            "pos": {
                "line": 788,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry ()\ny : \u2115\nhy : y \u2208 sorry ()\nh : x \u2264 y\n\u22a2 10 + x * 2 + x ^ 2 * 6 + x ^ 5 * 12 + x ^ 6 * 17 + x ^ 7 * 5 \u2264\n    10 + y * 2 + y ^ 2 * 6 + y ^ 5 * 12 + y ^ 6 * 17 + y ^ 7 * 5",
            "endPos": {
                "line": 789,
                "column": 41
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 295,
            "pos": {
                "line": 792,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) sorry",
            "endPos": {
                "line": 792,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "nlinarith [sq_nonneg (x ^ 3 - y ^ 3), sq_nonneg (x ^ 2 - y ^ 2), sq_nonneg (x - y),\n  sq_nonneg (x ^ 2 - 2 * x * y + y ^ 2)]",
            "proofState": 296,
            "pos": {
                "line": 793,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) x \u2264 (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) y",
            "endPos": {
                "line": 793,
                "column": 124
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 297,
            "pos": {
                "line": 796,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) sorry",
            "endPos": {
                "line": 796,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 298,
            "pos": {
                "line": 797,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) x \u2264\n    (fun x => 5 * x ^ 7 + 6 * x ^ 6 + 6 * x ^ 5 + 10 * x ^ 4 + 2 * x ^ 3 + 12 * x ^ 2 + 9 * x) y",
            "endPos": {
                "line": 797,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 299,
            "pos": {
                "line": 802,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) sorry",
            "endPos": {
                "line": 802,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "simp only [Set.mem_Icc] at hx hy",
            "proofState": 300,
            "pos": {
                "line": 803,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) x \u2264 (fun x => 12 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 2 + 8 * x) y",
            "endPos": {
                "line": 803,
                "column": 34
            }
        },
        {
            "usedConstants": [
                "Unit.unit",
                "HMul.hMul",
                "Nat.instMonoid",
                "sorryAx",
                "Monoid.toNatPow",
                "HasSubset.Subset",
                "instMulNat",
                "instOfNatNat",
                "Lean.Name.num",
                "Lean.Name.str",
                "Lean.Name.anonymous",
                "Bool.true",
                "instHAdd",
                "Unit",
                "HPow.hPow",
                "HAdd.hAdd",
                "Nat.instPreorder",
                "Nat",
                "Function.const",
                "instAddNat",
                "Lean.Name",
                "instHPow",
                "OfNat.ofNat",
                "Set.instHasSubset",
                "MonotoneOn.mono",
                "instHMul",
                "Set"
            ],
            "tactic": "apply MonotoneOn.mono _ (Icc_subset_Ici_self)",
            "proofState": 301,
            "pos": {
                "line": 808,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 14 * x ^ 7 + 15 * x ^ 5 + 5 * x ^ 4 + 4 * x ^ 3) sorry",
            "endPos": {
                "line": 808,
                "column": 47
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 302,
            "pos": {
                "line": 809,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 14 * x ^ 7 + 15 * x ^ 5 + 5 * x ^ 4 + 4 * x ^ 3) ?m.2612079",
            "endPos": {
                "line": 809,
                "column": 21
            }
        },
        {
            "usedConstants": [
                "Nat"
            ],
            "tactic": "intro x hx y hy hxy",
            "proofState": 303,
            "pos": {
                "line": 814,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) sorry",
            "endPos": {
                "line": 814,
                "column": 21
            }
        },
        {
            "usedConstants": [],
            "tactic": "have h := mvt_on_Icc (fun x \u21a6 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) hx hy hxy",
            "proofState": 304,
            "pos": {
                "line": 815,
                "column": 2
            },
            "goals": "x\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) x \u2264\n    (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) y",
            "endPos": {
                "line": 815,
                "column": 106
            }
        }
    ],
    "messages": [
        {
            "severity": "error",
            "pos": {
                "line": 4,
                "column": 105
            },
            "endPos": {
                "line": 4,
                "column": 122
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.829"
        },
        {
            "severity": "error",
            "pos": {
                "line": 6,
                "column": 2
            },
            "endPos": {
                "line": 6,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 10,
                "column": 64
            },
            "endPos": {
                "line": 10,
                "column": 81
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.21879"
        },
        {
            "severity": "error",
            "pos": {
                "line": 14,
                "column": 4
            },
            "endPos": {
                "line": 14,
                "column": 68
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d : x ^ 6 * 15 + x ^ 4 * 6 + x ^ 3 * 4 > y ^ 6 * 15 + y ^ 4 * 6 + y ^ 3 * 4\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 15,
                "column": 34
            },
            "endPos": {
                "line": 15,
                "column": 45
            },
            "data": "unsolved goals\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 ?m.42535 \u2264 ?m.42536"
        },
        {
            "severity": "error",
            "pos": {
                "line": 17,
                "column": 65
            },
            "endPos": {
                "line": 17,
                "column": 82
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.45487"
        },
        {
            "severity": "error",
            "pos": {
                "line": 18,
                "column": 27
            },
            "endPos": {
                "line": 18,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 19,
                "column": 10
            },
            "endPos": {
                "line": 19,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 23,
                "column": 69
            },
            "endPos": {
                "line": 23,
                "column": 86
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.54970"
        },
        {
            "severity": "error",
            "pos": {
                "line": 24,
                "column": 26
            },
            "endPos": {
                "line": 24,
                "column": 45
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 25,
                "column": 10
            },
            "endPos": {
                "line": 25,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 30,
                "column": 52
            },
            "endPos": {
                "line": 30,
                "column": 69
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.65704"
        },
        {
            "severity": "error",
            "pos": {
                "line": 38,
                "column": 2
            },
            "endPos": {
                "line": 38,
                "column": 50
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : y \u2264 3\na\u271d : (fun x => 17 * x ^ 7 + 3 * x ^ 2) x > (fun x => 17 * x ^ 7 + 3 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 40,
                "column": 115
            },
            "endPos": {
                "line": 40,
                "column": 132
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.86657"
        },
        {
            "severity": "error",
            "pos": {
                "line": 44,
                "column": 2
            },
            "endPos": {
                "line": 45,
                "column": 49
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d :\n  x * 19 + x ^ 2 * 8 + x ^ 3 * 15 + x ^ 4 * 19 + x ^ 5 * 8 + x ^ 6 * 13 + x ^ 7 * 5 >\n    y * 19 + y ^ 2 * 8 + y ^ 3 * 15 + y ^ 4 * 19 + y ^ 5 * 8 + y ^ 6 * 13 + y ^ 7 * 5\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 47,
                "column": 95
            },
            "endPos": {
                "line": 47,
                "column": 112
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.150698"
        },
        {
            "severity": "error",
            "pos": {
                "line": 49,
                "column": 88
            },
            "endPos": {
                "line": 49,
                "column": 97
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d : 0 > 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 50,
                "column": 88
            },
            "endPos": {
                "line": 50,
                "column": 97
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\na\u271d : 0 > 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 52,
                "column": 4
            },
            "endPos": {
                "line": 53,
                "column": 105
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\na\u271d : 0 > 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 54,
                "column": 2
            },
            "endPos": {
                "line": 55,
                "column": 103
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\nh\u2081 : 0 \u2264 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20\nh\u2082 : 0 \u2264 16 * y ^ 7 + 8 * y ^ 6 + 4 * y ^ 5 + 16 * y ^ 4 + 12 * y ^ 2 + 20\nh\u2083 : 0 \u2264 16 * (y - x) ^ 7 + 8 * (y - x) ^ 6 + 4 * (y - x) ^ 5 + 16 * (y - x) ^ 4 + 12 * (y - x) ^ 2 + 20\na\u271d :\n  (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) x >\n    (fun x => 16 * x ^ 7 + 8 * x ^ 6 + 4 * x ^ 5 + 16 * x ^ 4 + 12 * x ^ 2 + 20) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 57,
                "column": 78
            },
            "endPos": {
                "line": 57,
                "column": 95
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.307832"
        },
        {
            "severity": "error",
            "pos": {
                "line": 59,
                "column": 13
            },
            "endPos": {
                "line": 59,
                "column": 31
            },
            "data": "unknown identifier 'Icc_subset_Icc_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 59,
                "column": 2
            },
            "endPos": {
                "line": 59,
                "column": 41
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 63,
                "column": 102
            },
            "endPos": {
                "line": 63,
                "column": 119
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.320257"
        },
        {
            "severity": "error",
            "pos": {
                "line": 65,
                "column": 17
            },
            "endPos": {
                "line": 65,
                "column": 24
            },
            "data": "unknown identifier 'Icc_def'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 66,
                "column": 2
            },
            "endPos": {
                "line": 66,
                "column": 74
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\na\u271d :\n  12 * x ^ 7 + 4 * x ^ 6 + 5 * x ^ 5 + 20 * x ^ 4 + 19 * x ^ 3 + 4 * x ^ 2 >\n    12 * y ^ 7 + 4 * y ^ 6 + 5 * y ^ 5 + 20 * y ^ 4 + 19 * y ^ 3 + 4 * y ^ 2\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 68,
                "column": 90
            },
            "endPos": {
                "line": 68,
                "column": 107
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.360594"
        },
        {
            "severity": "error",
            "pos": {
                "line": 69,
                "column": 8
            },
            "endPos": {
                "line": 69,
                "column": 43
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  MonotoneOn\nhas type\n  (?m.375399 \u2192 ?m.375400) \u2192 Set ?m.375399 \u2192 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 70,
                "column": 2
            },
            "endPos": {
                "line": 70,
                "column": 12
            },
            "data": "no goals to be solved"
        },
        {
            "severity": "error",
            "pos": {
                "line": 82,
                "column": 78
            },
            "endPos": {
                "line": 82,
                "column": 96
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.376909"
        },
        {
            "severity": "error",
            "pos": {
                "line": 83,
                "column": 29
            },
            "endPos": {
                "line": 83,
                "column": 48
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 84,
                "column": 10
            },
            "endPos": {
                "line": 84,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 88,
                "column": 86
            },
            "endPos": {
                "line": 88,
                "column": 103
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.389948"
        },
        {
            "severity": "error",
            "pos": {
                "line": 91,
                "column": 26
            },
            "endPos": {
                "line": 91,
                "column": 31
            },
            "data": "application type mismatch\n  x + y\nargument\n  y\nhas type\n  x < x\u271d\u00b9 : Prop\nbut is expected to have type\n  ?m.406902 : Type ?u.406896"
        },
        {
            "severity": "error",
            "pos": {
                "line": 90,
                "column": 34
            },
            "endPos": {
                "line": 92,
                "column": 113
            },
            "data": "application type mismatch\n  monotone_iff_forall_lt.mpr fun x x_1 y x_2 h => ?m.403951\nargument\n  fun x x_1 y x_2 h => ?m.403951\nhas type\n  (x x_1 : ?m.406905) \u2192\n    (y : x < x_1) \u2192\n      (x_2 : ?m.403952 x x_1 y) \u2192\n        (h : ?m.403953 x x_1 y x_2) \u2192\n          ?m.403954 x x_1 y x_2 h : Sort (imax (?u.406897 + 1) (?u.406897 + 1) ?u.403943 ?u.403946 ?u.403949)\nbut is expected to have type\n  \u2200 \u2983a b : ?m.406905\u2984, a < b \u2192 ?m.403918 a \u2264 ?m.403918 b : Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 101,
                "column": 117
            },
            "endPos": {
                "line": 101,
                "column": 135
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.415390"
        },
        {
            "severity": "error",
            "pos": {
                "line": 102,
                "column": 27
            },
            "endPos": {
                "line": 102,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 103,
                "column": 10
            },
            "endPos": {
                "line": 103,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 108,
                "column": 86
            },
            "endPos": {
                "line": 108,
                "column": 103
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.438680"
        },
        {
            "severity": "error",
            "pos": {
                "line": 111,
                "column": 2
            },
            "endPos": {
                "line": 112,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d : 16 * x ^ 6 + 12 * x ^ 5 + 6 * x ^ 3 + 15 * x ^ 2 + 8 * x > 16 * y ^ 6 + 12 * y ^ 5 + 6 * y ^ 3 + 15 * y ^ 2 + 8 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 114,
                "column": 90
            },
            "endPos": {
                "line": 114,
                "column": 108
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.480227"
        },
        {
            "severity": "error",
            "pos": {
                "line": 116,
                "column": 2
            },
            "endPos": {
                "line": 116,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 121,
                "column": 64
            },
            "endPos": {
                "line": 121,
                "column": 81
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.495625"
        },
        {
            "severity": "error",
            "pos": {
                "line": 122,
                "column": 27
            },
            "endPos": {
                "line": 122,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 123,
                "column": 10
            },
            "endPos": {
                "line": 123,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 129,
                "column": 64
            },
            "endPos": {
                "line": 129,
                "column": 82
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.505400"
        },
        {
            "severity": "error",
            "pos": {
                "line": 131,
                "column": 2
            },
            "endPos": {
                "line": 132,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\na\u271d : (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) x > (fun x => 12 * x ^ 6 + 6 * x ^ 2 + 5 * x + 4) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 134,
                "column": 78
            },
            "endPos": {
                "line": 134,
                "column": 95
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.555073"
        },
        {
            "severity": "error",
            "pos": {
                "line": 143,
                "column": 78
            },
            "endPos": {
                "line": 143,
                "column": 95
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.567721"
        },
        {
            "severity": "error",
            "pos": {
                "line": 145,
                "column": 2
            },
            "endPos": {
                "line": 145,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 148,
                "column": 103
            },
            "endPos": {
                "line": 148,
                "column": 120
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.580667"
        },
        {
            "severity": "error",
            "pos": {
                "line": 149,
                "column": 27
            },
            "endPos": {
                "line": 149,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 150,
                "column": 10
            },
            "endPos": {
                "line": 150,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 154,
                "column": 52
            },
            "endPos": {
                "line": 154,
                "column": 69
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.599762"
        },
        {
            "severity": "error",
            "pos": {
                "line": 155,
                "column": 29
            },
            "endPos": {
                "line": 155,
                "column": 48
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 156,
                "column": 2
            },
            "endPos": {
                "line": 156,
                "column": 22
            },
            "data": "tactic 'apply' failed, failed to unify\n  ?a \u2264 ?b \u2192 (fun x => ?f x + ?g x) ?a \u2264 (fun x => ?f x + ?g x) ?b\nwith\n  Set \u2115\ncase refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115"
        },
        {
            "severity": "error",
            "pos": {
                "line": 160,
                "column": 103
            },
            "endPos": {
                "line": 160,
                "column": 121
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.606974"
        },
        {
            "severity": "error",
            "pos": {
                "line": 161,
                "column": 27
            },
            "endPos": {
                "line": 161,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 162,
                "column": 10
            },
            "endPos": {
                "line": 162,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 168,
                "column": 65
            },
            "endPos": {
                "line": 168,
                "column": 82
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.626180"
        },
        {
            "severity": "error",
            "pos": {
                "line": 174,
                "column": 2
            },
            "endPos": {
                "line": 174,
                "column": 50
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nh : x \u2264 y\na\u271d : 12 + x * 19 + x ^ 2 * 3 + x ^ 4 * 9 > 12 + y * 19 + y ^ 2 * 3 + y ^ 4 * 9\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 176,
                "column": 86
            },
            "endPos": {
                "line": 176,
                "column": 103
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.650207"
        },
        {
            "severity": "error",
            "pos": {
                "line": 179,
                "column": 2
            },
            "endPos": {
                "line": 179,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\na\u271d : 2 * x ^ 7 + x ^ 6 * 14 + 3 * x ^ 3 + x ^ 2 * 20 + x * 13 > 2 * y ^ 7 + y ^ 6 * 14 + 3 * y ^ 3 + y ^ 2 * 20 + y * 13\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 181,
                "column": 68
            },
            "endPos": {
                "line": 181,
                "column": 85
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.692180"
        },
        {
            "severity": "error",
            "pos": {
                "line": 187,
                "column": 65
            },
            "endPos": {
                "line": 187,
                "column": 82
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.703459"
        },
        {
            "severity": "error",
            "pos": {
                "line": 189,
                "column": 2
            },
            "endPos": {
                "line": 189,
                "column": 73
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d : (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) x > (fun x => 15 * x ^ 6 + 6 * x ^ 2 + 12 * x + 4) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 191,
                "column": 66
            },
            "endPos": {
                "line": 191,
                "column": 83
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.731669"
        },
        {
            "severity": "error",
            "pos": {
                "line": 201,
                "column": 2
            },
            "endPos": {
                "line": 201,
                "column": 187
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : 0 \u2264 y - x\na\u271d : x ^ 6 * 8 + x ^ 5 * 11 + x * 19 + 10 > y ^ 6 * 8 + y ^ 5 * 11 + y * 19 + 10\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 203,
                "column": 85
            },
            "endPos": {
                "line": 203,
                "column": 102
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.792247"
        },
        {
            "severity": "error",
            "pos": {
                "line": 208,
                "column": 2
            },
            "endPos": {
                "line": 208,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx y : \u2115\nhxy : x \u2264 y\nhx' : x \u2208 sorry\nhy' : y \u2208 sorry\na\u271d : 15 * x ^ 6 + 18 * x ^ 5 + 9 * x ^ 3 + 4 * x ^ 2 + 3 * x > 15 * y ^ 6 + 18 * y ^ 5 + 9 * y ^ 3 + 4 * y ^ 2 + 3 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 210,
                "column": 83
            },
            "endPos": {
                "line": 210,
                "column": 100
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.834116"
        },
        {
            "severity": "error",
            "pos": {
                "line": 211,
                "column": 27
            },
            "endPos": {
                "line": 211,
                "column": 47
            },
            "data": "unknown identifier 'Icc_subset_Icc_right'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 215,
                "column": 74
            },
            "endPos": {
                "line": 215,
                "column": 85
            },
            "data": "unsolved goals\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.861409"
        },
        {
            "severity": "error",
            "pos": {
                "line": 216,
                "column": 44
            },
            "endPos": {
                "line": 216,
                "column": 55
            },
            "data": "unsolved goals\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.876512"
        },
        {
            "severity": "error",
            "pos": {
                "line": 217,
                "column": 44
            },
            "endPos": {
                "line": 217,
                "column": 55
            },
            "data": "unsolved goals\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.892155"
        },
        {
            "severity": "error",
            "pos": {
                "line": 218,
                "column": 42
            },
            "endPos": {
                "line": 218,
                "column": 53
            },
            "data": "unsolved goals\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.907798"
        },
        {
            "severity": "error",
            "pos": {
                "line": 219,
                "column": 40
            },
            "endPos": {
                "line": 219,
                "column": 51
            },
            "data": "unsolved goals\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 0 \u2264 ?m.923441"
        },
        {
            "severity": "error",
            "pos": {
                "line": 221,
                "column": 100
            },
            "endPos": {
                "line": 221,
                "column": 117
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.948382"
        },
        {
            "severity": "error",
            "pos": {
                "line": 222,
                "column": 26
            },
            "endPos": {
                "line": 222,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Icc_right'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 224,
                "column": 4
            },
            "endPos": {
                "line": 224,
                "column": 36
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 223,
                "column": 2
            },
            "endPos": {
                "line": 225,
                "column": 87
            },
            "data": "type mismatch\n  fun x hx y hy h => ?m.965901\nhas type\n  (x : \u2115) \u2192\n    (hx : ?m.965902 x) \u2192\n      (y : ?m.965903 x hx) \u2192\n        (hy : ?m.965904 x hx y) \u2192\n          (h : ?m.965905 x hx y hy) \u2192\n            ?m.965906 x hx y hy h : Sort (imax 1 ?u.965887 ?u.965890 ?u.965893 ?u.965896 ?u.965899)\nbut is expected to have type\n  Set \u2115 : Type"
        },
        {
            "severity": "error",
            "pos": {
                "line": 227,
                "column": 98
            },
            "endPos": {
                "line": 227,
                "column": 115
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.966726"
        },
        {
            "severity": "error",
            "pos": {
                "line": 229,
                "column": 2
            },
            "endPos": {
                "line": 230,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d :\n  (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) x >\n    (fun x => 15 * x ^ 7 + 7 * x ^ 6 + 17 * x ^ 5 + 9 * x ^ 4 + 9 * x ^ 2 + 16 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 232,
                "column": 102
            },
            "endPos": {
                "line": 232,
                "column": 119
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1012568"
        },
        {
            "severity": "error",
            "pos": {
                "line": 233,
                "column": 29
            },
            "endPos": {
                "line": 233,
                "column": 48
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 235,
                "column": 4
            },
            "endPos": {
                "line": 235,
                "column": 55
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 234,
                "column": 2
            },
            "endPos": {
                "line": 238,
                "column": 67
            },
            "data": "type mismatch\n  fun x hx y hy h => ?m.1031156\nhas type\n  (x : \u2115) \u2192\n    (hx : ?m.1031157 x) \u2192\n      (y : ?m.1031158 x hx) \u2192\n        (hy : ?m.1031159 x hx y) \u2192\n          (h : ?m.1031160 x hx y hy) \u2192\n            ?m.1031161 x hx y hy h : Sort (imax 1 ?u.1031142 ?u.1031145 ?u.1031148 ?u.1031151 ?u.1031154)\nbut is expected to have type\n  Set \u2115 : Type"
        },
        {
            "severity": "error",
            "pos": {
                "line": 240,
                "column": 99
            },
            "endPos": {
                "line": 240,
                "column": 116
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1032004"
        },
        {
            "severity": "error",
            "pos": {
                "line": 241,
                "column": 29
            },
            "endPos": {
                "line": 241,
                "column": 48
            },
            "data": "unknown identifier 'Icc_subset_Icc_left'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 242,
                "column": 10
            },
            "endPos": {
                "line": 242,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\ncase refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 253,
                "column": 79
            },
            "endPos": {
                "line": 253,
                "column": 96
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1049934"
        },
        {
            "severity": "error",
            "pos": {
                "line": 256,
                "column": 2
            },
            "endPos": {
                "line": 256,
                "column": 76
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d : 8 * x ^ 7 + 17 * x ^ 6 + 10 * x ^ 2 + 12 * x > 8 * y ^ 7 + 17 * y ^ 6 + 10 * y ^ 2 + 12 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 258,
                "column": 53
            },
            "endPos": {
                "line": 258,
                "column": 70
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1083871"
        },
        {
            "severity": "error",
            "pos": {
                "line": 260,
                "column": 17
            },
            "endPos": {
                "line": 260,
                "column": 35
            },
            "data": "unknown identifier 'Icc_subset_Icc_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 264,
                "column": 73
            },
            "endPos": {
                "line": 264,
                "column": 90
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1092417"
        },
        {
            "severity": "error",
            "pos": {
                "line": 265,
                "column": 27
            },
            "endPos": {
                "line": 265,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 266,
                "column": 10
            },
            "endPos": {
                "line": 266,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 270,
                "column": 103
            },
            "endPos": {
                "line": 270,
                "column": 120
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1104010"
        },
        {
            "severity": "error",
            "pos": {
                "line": 273,
                "column": 41
            },
            "endPos": {
                "line": 273,
                "column": 53
            },
            "data": "unknown identifier 'true_and_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 273,
                "column": 4
            },
            "endPos": {
                "line": 273,
                "column": 68
            },
            "data": "simp_all made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 276,
                "column": 2
            },
            "endPos": {
                "line": 276,
                "column": 22
            },
            "data": "tactic 'apply' failed, failed to unify\n  ?a \u2264 ?b \u2192 (fun x => ?f x + ?g x) ?a \u2264 (fun x => ?f x + ?g x) ?b\nwith\n  Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115"
        },
        {
            "severity": "error",
            "pos": {
                "line": 305,
                "column": 72
            },
            "endPos": {
                "line": 305,
                "column": 89
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1123657"
        },
        {
            "severity": "error",
            "pos": {
                "line": 307,
                "column": 16
            },
            "endPos": {
                "line": 307,
                "column": 17
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 307,
                "column": 34
            },
            "endPos": {
                "line": 307,
                "column": 36
            },
            "data": "unknown identifier 'hx'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 308,
                "column": 34
            },
            "endPos": {
                "line": 308,
                "column": 36
            },
            "data": "unknown identifier 'hx'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 309,
                "column": 20
            },
            "endPos": {
                "line": 309,
                "column": 21
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 309,
                "column": 32
            },
            "endPos": {
                "line": 309,
                "column": 33
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 309,
                "column": 45
            },
            "endPos": {
                "line": 309,
                "column": 46
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 309,
                "column": 57
            },
            "endPos": {
                "line": 309,
                "column": 58
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 310,
                "column": 30
            },
            "endPos": {
                "line": 310,
                "column": 31
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 313,
                "column": 21
            },
            "endPos": {
                "line": 313,
                "column": 22
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 313,
                "column": 33
            },
            "endPos": {
                "line": 313,
                "column": 34
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 313,
                "column": 46
            },
            "endPos": {
                "line": 313,
                "column": 47
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 313,
                "column": 58
            },
            "endPos": {
                "line": 313,
                "column": 59
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 315,
                "column": 27
            },
            "endPos": {
                "line": 315,
                "column": 28
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 317,
                "column": 61
            },
            "endPos": {
                "line": 317,
                "column": 78
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1220189"
        },
        {
            "severity": "error",
            "pos": {
                "line": 318,
                "column": 27
            },
            "endPos": {
                "line": 318,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 319,
                "column": 10
            },
            "endPos": {
                "line": 319,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 325,
                "column": 65
            },
            "endPos": {
                "line": 325,
                "column": 82
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1228598"
        },
        {
            "severity": "error",
            "pos": {
                "line": 326,
                "column": 27
            },
            "endPos": {
                "line": 326,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 327,
                "column": 2
            },
            "endPos": {
                "line": 327,
                "column": 22
            },
            "data": "tactic 'apply' failed, failed to unify\n  ?a \u2264 ?b \u2192 (fun x => ?f x + ?g x) ?a \u2264 (fun x => ?f x + ?g x) ?b\nwith\n  Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115"
        },
        {
            "severity": "error",
            "pos": {
                "line": 338,
                "column": 90
            },
            "endPos": {
                "line": 338,
                "column": 107
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1238801"
        },
        {
            "severity": "error",
            "pos": {
                "line": 340,
                "column": 8
            },
            "endPos": {
                "line": 340,
                "column": 27
            },
            "data": "unknown identifier 'Icc_subset_Icc_left'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 341,
                "column": 10
            },
            "endPos": {
                "line": 341,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 345,
                "column": 91
            },
            "endPos": {
                "line": 345,
                "column": 108
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1254651"
        },
        {
            "severity": "error",
            "pos": {
                "line": 346,
                "column": 27
            },
            "endPos": {
                "line": 346,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 347,
                "column": 10
            },
            "endPos": {
                "line": 347,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 354,
                "column": 77
            },
            "endPos": {
                "line": 354,
                "column": 94
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1271043"
        },
        {
            "severity": "error",
            "pos": {
                "line": 356,
                "column": 2
            },
            "endPos": {
                "line": 356,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 360,
                "column": 92
            },
            "endPos": {
                "line": 360,
                "column": 109
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1283388"
        },
        {
            "severity": "error",
            "pos": {
                "line": 365,
                "column": 98
            },
            "endPos": {
                "line": 365,
                "column": 115
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1299839"
        },
        {
            "severity": "error",
            "pos": {
                "line": 366,
                "column": 26
            },
            "endPos": {
                "line": 366,
                "column": 45
            },
            "data": "unknown identifier 'Icc_subset_Icc_left'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 367,
                "column": 10
            },
            "endPos": {
                "line": 367,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 377,
                "column": 112
            },
            "endPos": {
                "line": 377,
                "column": 129
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1318202"
        },
        {
            "severity": "error",
            "pos": {
                "line": 379,
                "column": 12
            },
            "endPos": {
                "line": 379,
                "column": 32
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 379,
                "column": 12
            },
            "endPos": {
                "line": 379,
                "column": 32
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 385,
                "column": 103
            },
            "endPos": {
                "line": 385,
                "column": 121
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1342338"
        },
        {
            "severity": "error",
            "pos": {
                "line": 387,
                "column": 2
            },
            "endPos": {
                "line": 387,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 396,
                "column": 103
            },
            "endPos": {
                "line": 396,
                "column": 120
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1362445"
        },
        {
            "severity": "error",
            "pos": {
                "line": 398,
                "column": 13
            },
            "endPos": {
                "line": 398,
                "column": 20
            },
            "data": "unknown identifier 'mem_Icc'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 398,
                "column": 2
            },
            "endPos": {
                "line": 398,
                "column": 30
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 406,
                "column": 65
            },
            "endPos": {
                "line": 406,
                "column": 82
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1382216"
        },
        {
            "severity": "error",
            "pos": {
                "line": 409,
                "column": 2
            },
            "endPos": {
                "line": 409,
                "column": 16
            },
            "data": "ring_nf made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 412,
                "column": 90
            },
            "endPos": {
                "line": 412,
                "column": 107
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1392878"
        },
        {
            "severity": "error",
            "pos": {
                "line": 413,
                "column": 29
            },
            "endPos": {
                "line": 413,
                "column": 48
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 414,
                "column": 2
            },
            "endPos": {
                "line": 414,
                "column": 22
            },
            "data": "tactic 'apply' failed, failed to unify\n  ?a \u2264 ?b \u2192 (fun x => ?f x + ?g x) ?a \u2264 (fun x => ?f x + ?g x) ?b\nwith\n  Set \u2115\ncase refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115"
        },
        {
            "severity": "error",
            "pos": {
                "line": 423,
                "column": 72
            },
            "endPos": {
                "line": 423,
                "column": 89
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1408631"
        },
        {
            "severity": "error",
            "pos": {
                "line": 425,
                "column": 2
            },
            "endPos": {
                "line": 426,
                "column": 68
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d : (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) x > (fun x => 17 * x ^ 4 + 6 * x ^ 3 + 2 * x ^ 2 + 7 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 428,
                "column": 74
            },
            "endPos": {
                "line": 428,
                "column": 91
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1452021"
        },
        {
            "severity": "error",
            "pos": {
                "line": 433,
                "column": 12
            },
            "endPos": {
                "line": 433,
                "column": 15
            },
            "data": "tactic 'introN' failed, insufficient number of binders\ncase h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhx0 : x \u2264 y\n\u22a2 18 * x ^ 7 + 10 * x ^ 5 + 13 * x ^ 4 + 3 * x \u2264 18 * y ^ 7 + 10 * y ^ 5 + 13 * y ^ 4 + 3 * y"
        },
        {
            "severity": "error",
            "pos": {
                "line": 436,
                "column": 86
            },
            "endPos": {
                "line": 436,
                "column": 103
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1463609"
        },
        {
            "severity": "error",
            "pos": {
                "line": 439,
                "column": 2
            },
            "endPos": {
                "line": 439,
                "column": 104
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d :\n  (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) x >\n    (fun x => 7 * x ^ 7 + 12 * x ^ 5 + 14 * x ^ 4 + 12 * x ^ 2 + 7 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 442,
                "column": 69
            },
            "endPos": {
                "line": 442,
                "column": 86
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1507046"
        },
        {
            "severity": "error",
            "pos": {
                "line": 445,
                "column": 26
            },
            "endPos": {
                "line": 445,
                "column": 27
            },
            "data": "unknown identifier 'x'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 442,
                "column": 91
            },
            "endPos": {
                "line": 446,
                "column": 62
            },
            "data": "unsolved goals\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\n\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115"
        },
        {
            "severity": "error",
            "pos": {
                "line": 448,
                "column": 63
            },
            "endPos": {
                "line": 448,
                "column": 80
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1517627"
        },
        {
            "severity": "error",
            "pos": {
                "line": 449,
                "column": 27
            },
            "endPos": {
                "line": 449,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 450,
                "column": 2
            },
            "endPos": {
                "line": 450,
                "column": 22
            },
            "data": "tactic 'apply' failed, failed to unify\n  ?a \u2264 ?b \u2192 (fun x => ?f x + ?g x) ?a \u2264 (fun x => ?f x + ?g x) ?b\nwith\n  Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115"
        },
        {
            "severity": "error",
            "pos": {
                "line": 453,
                "column": 91
            },
            "endPos": {
                "line": 453,
                "column": 109
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1527830"
        },
        {
            "severity": "error",
            "pos": {
                "line": 456,
                "column": 34
            },
            "endPos": {
                "line": 456,
                "column": 52
            },
            "data": "unknown identifier 'Icc_subset_Icc_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 458,
                "column": 2
            },
            "endPos": {
                "line": 458,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d :\n  19 * x ^ 7 + 15 * x ^ 5 + 15 * x ^ 3 + 15 * x ^ 2 + 7 * x > 19 * y ^ 7 + 15 * y ^ 5 + 15 * y ^ 3 + 15 * y ^ 2 + 7 * y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 460,
                "column": 110
            },
            "endPos": {
                "line": 460,
                "column": 127
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1575777"
        },
        {
            "severity": "error",
            "pos": {
                "line": 462,
                "column": 2
            },
            "endPos": {
                "line": 462,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 472,
                "column": 103
            },
            "endPos": {
                "line": 472,
                "column": 120
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1597670"
        },
        {
            "severity": "error",
            "pos": {
                "line": 473,
                "column": 27
            },
            "endPos": {
                "line": 473,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Icc_left'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 474,
                "column": 2
            },
            "endPos": {
                "line": 474,
                "column": 22
            },
            "data": "tactic 'apply' failed, failed to unify\n  ?a \u2264 ?b \u2192 (fun x => ?f x + ?g x) ?a \u2264 (fun x => ?f x + ?g x) ?b\nwith\n  Set \u2115\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115"
        },
        {
            "severity": "error",
            "pos": {
                "line": 482,
                "column": 86
            },
            "endPos": {
                "line": 482,
                "column": 103
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1617275"
        },
        {
            "severity": "error",
            "pos": {
                "line": 484,
                "column": 13
            },
            "endPos": {
                "line": 484,
                "column": 20
            },
            "data": "unknown identifier 'Icc_def'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 484,
                "column": 2
            },
            "endPos": {
                "line": 484,
                "column": 49
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 490,
                "column": 86
            },
            "endPos": {
                "line": 490,
                "column": 103
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1631678"
        },
        {
            "severity": "error",
            "pos": {
                "line": 491,
                "column": 27
            },
            "endPos": {
                "line": 491,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Icc_left'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 492,
                "column": 10
            },
            "endPos": {
                "line": 492,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 495,
                "column": 69
            },
            "endPos": {
                "line": 495,
                "column": 87
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1646176"
        },
        {
            "severity": "error",
            "pos": {
                "line": 497,
                "column": 17
            },
            "endPos": {
                "line": 497,
                "column": 35
            },
            "data": "unknown identifier 'Icc_subset_Icc_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 497,
                "column": 46
            },
            "endPos": {
                "line": 497,
                "column": 58
            },
            "data": "unknown identifier 'true_and_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 498,
                "column": 59
            },
            "endPos": {
                "line": 498,
                "column": 71
            },
            "data": "unknown identifier 'zero_le_five'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 498,
                "column": 73
            },
            "endPos": {
                "line": 498,
                "column": 84
            },
            "data": "unknown identifier 'zero_le_six'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 499,
                "column": 4
            },
            "endPos": {
                "line": 499,
                "column": 17
            },
            "data": "unknown identifier 'zero_le_seven'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 499,
                "column": 19
            },
            "endPos": {
                "line": 499,
                "column": 32
            },
            "data": "unknown identifier 'zero_le_eight'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 499,
                "column": 34
            },
            "endPos": {
                "line": 499,
                "column": 46
            },
            "data": "unknown identifier 'zero_le_nine'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 499,
                "column": 48
            },
            "endPos": {
                "line": 499,
                "column": 59
            },
            "data": "unknown identifier 'zero_le_ten'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 500,
                "column": 2
            },
            "endPos": {
                "line": 500,
                "column": 31
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d : 15 * x ^ 6 + 5 * x ^ 3 + 16 * x ^ 2 + 7 > 15 * y ^ 6 + 5 * y ^ 3 + 16 * y ^ 2 + 7\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 502,
                "column": 79
            },
            "endPos": {
                "line": 502,
                "column": 96
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1669811"
        },
        {
            "severity": "error",
            "pos": {
                "line": 514,
                "column": 73
            },
            "endPos": {
                "line": 514,
                "column": 90
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1682519"
        },
        {
            "severity": "error",
            "pos": {
                "line": 517,
                "column": 4
            },
            "endPos": {
                "line": 517,
                "column": 98
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\na\u271d : x ^ 7 + x ^ 7 + x ^ 5 * 19 + x ^ 3 * 4 + x * 20 > y ^ 7 + y ^ 7 + y ^ 5 * 19 + y ^ 3 * 4 + y * 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 519,
                "column": 90
            },
            "endPos": {
                "line": 519,
                "column": 107
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1717581"
        },
        {
            "severity": "error",
            "pos": {
                "line": 522,
                "column": 2
            },
            "endPos": {
                "line": 522,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d :\n  (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) x >\n    (fun x => 17 * x ^ 7 + 5 * x ^ 6 + 12 * x ^ 5 + 17 * x ^ 4 + 8 * x ^ 3) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 526,
                "column": 104
            },
            "endPos": {
                "line": 526,
                "column": 121
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1760712"
        },
        {
            "severity": "error",
            "pos": {
                "line": 528,
                "column": 2
            },
            "endPos": {
                "line": 528,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 536,
                "column": 73
            },
            "endPos": {
                "line": 536,
                "column": 90
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1779752"
        },
        {
            "severity": "error",
            "pos": {
                "line": 538,
                "column": 13
            },
            "endPos": {
                "line": 538,
                "column": 14
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\n\u22a2 x \u2208 ?m.1790210"
        },
        {
            "severity": "error",
            "pos": {
                "line": 545,
                "column": 77
            },
            "endPos": {
                "line": 545,
                "column": 94
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1791147"
        },
        {
            "severity": "error",
            "pos": {
                "line": 547,
                "column": 13
            },
            "endPos": {
                "line": 547,
                "column": 20
            },
            "data": "unknown identifier 'mem_Icc'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 547,
                "column": 2
            },
            "endPos": {
                "line": 547,
                "column": 30
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 551,
                "column": 66
            },
            "endPos": {
                "line": 551,
                "column": 83
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1803257"
        },
        {
            "severity": "error",
            "pos": {
                "line": 558,
                "column": 97
            },
            "endPos": {
                "line": 558,
                "column": 114
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1813087"
        },
        {
            "severity": "error",
            "pos": {
                "line": 560,
                "column": 13
            },
            "endPos": {
                "line": 560,
                "column": 20
            },
            "data": "unknown identifier 'mem_Icc'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 560,
                "column": 2
            },
            "endPos": {
                "line": 560,
                "column": 30
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 563,
                "column": 53
            },
            "endPos": {
                "line": 563,
                "column": 71
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1830690"
        },
        {
            "severity": "error",
            "pos": {
                "line": 564,
                "column": 27
            },
            "endPos": {
                "line": 564,
                "column": 47
            },
            "data": "unknown identifier 'Icc_subset_Icc_right'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 565,
                "column": 10
            },
            "endPos": {
                "line": 565,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 573,
                "column": 89
            },
            "endPos": {
                "line": 573,
                "column": 106
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1837904"
        },
        {
            "severity": "error",
            "pos": {
                "line": 580,
                "column": 13
            },
            "endPos": {
                "line": 580,
                "column": 17
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  x \u2208 ?s"
        },
        {
            "severity": "error",
            "pos": {
                "line": 580,
                "column": 13
            },
            "endPos": {
                "line": 580,
                "column": 17
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  Set.Mem ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 580,
                "column": 13
            },
            "endPos": {
                "line": 580,
                "column": 17
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  hx\nhas type\n  ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 580,
                "column": 13
            },
            "endPos": {
                "line": 580,
                "column": 17
            },
            "data": "Argument passed to nlinarith has metavariables:\n  ?h"
        },
        {
            "severity": "error",
            "pos": {
                "line": 582,
                "column": 66
            },
            "endPos": {
                "line": 582,
                "column": 83
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1860313"
        },
        {
            "severity": "error",
            "pos": {
                "line": 592,
                "column": 2
            },
            "endPos": {
                "line": 593,
                "column": 30
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\nhx' : 0 \u2264 x\nhy' : 0 \u2264 y\nhxy' : x \u2264 y\na\u271d : (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) x > (fun x => 16 * x ^ 4 + 10 * x ^ 3 + 13 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 595,
                "column": 84
            },
            "endPos": {
                "line": 595,
                "column": 101
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1900693"
        },
        {
            "severity": "error",
            "pos": {
                "line": 597,
                "column": 2
            },
            "endPos": {
                "line": 597,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d :\n  (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) x >\n    (fun x => 4 * x ^ 7 + 6 * x ^ 4 + 7 * x ^ 3 + 12 * x ^ 2 + 6 * x) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 599,
                "column": 85
            },
            "endPos": {
                "line": 599,
                "column": 102
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1942235"
        },
        {
            "severity": "error",
            "pos": {
                "line": 601,
                "column": 13
            },
            "endPos": {
                "line": 601,
                "column": 20
            },
            "data": "unknown identifier 'mem_Icc'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 601,
                "column": 2
            },
            "endPos": {
                "line": 601,
                "column": 30
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 606,
                "column": 68
            },
            "endPos": {
                "line": 606,
                "column": 85
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1956477"
        },
        {
            "severity": "error",
            "pos": {
                "line": 610,
                "column": 2
            },
            "endPos": {
                "line": 610,
                "column": 104
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx y : \u2115\nh : x \u2264 y\nhx' : x \u2208 sorry\nhy' : y \u2208 sorry\na\u271d : 7 * x ^ 6 + 7 * x ^ 4 + 5 * x ^ 2 + 14 > 7 * y ^ 6 + 7 * y ^ 4 + 5 * y ^ 2 + 14\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 612,
                "column": 90
            },
            "endPos": {
                "line": 612,
                "column": 107
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.1991394"
        },
        {
            "severity": "error",
            "pos": {
                "line": 614,
                "column": 2
            },
            "endPos": {
                "line": 614,
                "column": 85
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d :\n  (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) x >\n    (fun x => 5 * x ^ 7 + 3 * x ^ 5 + 6 * x ^ 4 + 20 * x ^ 2 + 14 * x + 20) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 616,
                "column": 77
            },
            "endPos": {
                "line": 616,
                "column": 94
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2034348"
        },
        {
            "severity": "error",
            "pos": {
                "line": 617,
                "column": 27
            },
            "endPos": {
                "line": 617,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 619,
                "column": 4
            },
            "endPos": {
                "line": 620,
                "column": 43
            },
            "data": "linarith failed to find a contradiction\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : ?m.2046761 x\ny : \u2115\nhy : ?m.2046763 x hx y\nhxy : ?m.2046764 x hx y hy\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 618,
                "column": 2
            },
            "endPos": {
                "line": 620,
                "column": 43
            },
            "data": "type mismatch\n  fun x hx y hy hxy => ?m.2046760\nhas type\n  (x : \u2115) \u2192\n    (hx : ?m.2046761 x) \u2192\n      (y : \u2115) \u2192\n        (hy : ?m.2046763 x hx y) \u2192\n          (hxy : ?m.2046764 x hx y hy) \u2192\n            ?m.2046765 x hx y hy hxy : Sort (imax 1 ?u.2046746 1 ?u.2046752 ?u.2046755 ?u.2046758)\nbut is expected to have type\n  Set \u2115 : Type"
        },
        {
            "severity": "error",
            "pos": {
                "line": 622,
                "column": 103
            },
            "endPos": {
                "line": 622,
                "column": 120
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2071162"
        },
        {
            "severity": "error",
            "pos": {
                "line": 623,
                "column": 29
            },
            "endPos": {
                "line": 623,
                "column": 49
            },
            "data": "unknown identifier 'Icc_subset_Icc_right'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 624,
                "column": 10
            },
            "endPos": {
                "line": 624,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 629,
                "column": 85
            },
            "endPos": {
                "line": 629,
                "column": 102
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2090536"
        },
        {
            "severity": "error",
            "pos": {
                "line": 631,
                "column": 12
            },
            "endPos": {
                "line": 631,
                "column": 32
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 631,
                "column": 12
            },
            "endPos": {
                "line": 631,
                "column": 32
            },
            "data": "invalid field notation, function 'Function.const_mul' does not have argument with type (Function ...) that can be used, it must be explicit or implicit with a unique name"
        },
        {
            "severity": "error",
            "pos": {
                "line": 639,
                "column": 77
            },
            "endPos": {
                "line": 639,
                "column": 94
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2107102"
        },
        {
            "severity": "error",
            "pos": {
                "line": 640,
                "column": 26
            },
            "endPos": {
                "line": 640,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Icc_right'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 641,
                "column": 2
            },
            "endPos": {
                "line": 641,
                "column": 28
            },
            "data": "type mismatch\n  MonotoneOn.add ?m.2119014 ?m.2119015\nhas type\n  MonotoneOn (fun x => ?m.2119009 x + ?m.2119010 x) ?m.2119011 : Prop\nbut is expected to have type\n  Set \u2115 : Type"
        },
        {
            "severity": "error",
            "pos": {
                "line": 649,
                "column": 103
            },
            "endPos": {
                "line": 649,
                "column": 120
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2123062"
        },
        {
            "severity": "error",
            "pos": {
                "line": 651,
                "column": 17
            },
            "endPos": {
                "line": 651,
                "column": 35
            },
            "data": "unknown identifier 'Icc_subset_Icc_iff'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 652,
                "column": 2
            },
            "endPos": {
                "line": 653,
                "column": 57
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nh : x \u2264 y\na\u271d :\n  17 * x ^ 7 + 11 * x ^ 5 + 20 * x ^ 4 + 7 * x ^ 3 + 6 * x ^ 2 + 12 * x + 3 >\n    17 * y ^ 7 + 11 * y ^ 5 + 20 * y ^ 4 + 7 * y ^ 3 + 6 * y ^ 2 + 12 * y + 3\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 655,
                "column": 54
            },
            "endPos": {
                "line": 655,
                "column": 71
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2185693"
        },
        {
            "severity": "error",
            "pos": {
                "line": 656,
                "column": 27
            },
            "endPos": {
                "line": 656,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 657,
                "column": 10
            },
            "endPos": {
                "line": 657,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 662,
                "column": 68
            },
            "endPos": {
                "line": 662,
                "column": 85
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2192566"
        },
        {
            "severity": "error",
            "pos": {
                "line": 663,
                "column": 29
            },
            "endPos": {
                "line": 663,
                "column": 48
            },
            "data": "unknown identifier 'Icc_subset_Icc_left'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 664,
                "column": 10
            },
            "endPos": {
                "line": 664,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\ncase refine'_1\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 668,
                "column": 82
            },
            "endPos": {
                "line": 668,
                "column": 100
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2203392"
        },
        {
            "severity": "error",
            "pos": {
                "line": 679,
                "column": 86
            },
            "endPos": {
                "line": 679,
                "column": 103
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2218006"
        },
        {
            "severity": "error",
            "pos": {
                "line": 680,
                "column": 27
            },
            "endPos": {
                "line": 680,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Icc_left'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 681,
                "column": 10
            },
            "endPos": {
                "line": 681,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 687,
                "column": 90
            },
            "endPos": {
                "line": 687,
                "column": 108
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2232680"
        },
        {
            "severity": "error",
            "pos": {
                "line": 688,
                "column": 29
            },
            "endPos": {
                "line": 688,
                "column": 43
            },
            "data": "unknown identifier 'Icc_subset_Icc'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 689,
                "column": 10
            },
            "endPos": {
                "line": 689,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 693,
                "column": 49
            },
            "endPos": {
                "line": 693,
                "column": 66
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2248164"
        },
        {
            "severity": "error",
            "pos": {
                "line": 695,
                "column": 13
            },
            "endPos": {
                "line": 695,
                "column": 20
            },
            "data": "unknown identifier 'Icc_def'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 695,
                "column": 22
            },
            "endPos": {
                "line": 695,
                "column": 34
            },
            "data": "unknown identifier 'mem_setOf_eq'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 695,
                "column": 2
            },
            "endPos": {
                "line": 695,
                "column": 44
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 698,
                "column": 111
            },
            "endPos": {
                "line": 698,
                "column": 128
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2254154"
        },
        {
            "severity": "error",
            "pos": {
                "line": 699,
                "column": 27
            },
            "endPos": {
                "line": 699,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 700,
                "column": 10
            },
            "endPos": {
                "line": 700,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 704,
                "column": 78
            },
            "endPos": {
                "line": 704,
                "column": 95
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2276080"
        },
        {
            "severity": "error",
            "pos": {
                "line": 705,
                "column": 27
            },
            "endPos": {
                "line": 705,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 706,
                "column": 10
            },
            "endPos": {
                "line": 706,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 718,
                "column": 84
            },
            "endPos": {
                "line": 718,
                "column": 101
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2289124"
        },
        {
            "severity": "error",
            "pos": {
                "line": 721,
                "column": 2
            },
            "endPos": {
                "line": 722,
                "column": 76
            },
            "data": "linarith failed to find a contradiction\ncase hf.a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\na\u271d :\n  (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) x >\n    (fun x => 7 * x ^ 7 + 8 * x ^ 5 + 3 * x ^ 3 + 18 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 738,
                "column": 4
            },
            "endPos": null,
            "data": "expected '{' or indented tactic sequence"
        },
        {
            "severity": "error",
            "pos": {
                "line": 731,
                "column": 75
            },
            "endPos": {
                "line": 731,
                "column": 92
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2344637"
        },
        {
            "severity": "error",
            "pos": {
                "line": 736,
                "column": 4
            },
            "endPos": {
                "line": 736,
                "column": 87
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nhxy : x \u2264 y\na\u271d : 4 * x ^ 7 + x ^ 6 * 7 + x ^ 2 * 3 + x * 8 > 4 * y ^ 7 + y ^ 6 * 7 + y ^ 2 * 3 + y * 8\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 735,
                "column": 4
            },
            "endPos": {
                "line": 735,
                "column": 50
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 731,
                "column": 97
            },
            "endPos": {
                "line": 737,
                "column": 35
            },
            "data": "unsolved goals\ncase h'\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 sorry \u2286 ?s\n\ncase s\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 Set \u2115"
        },
        {
            "severity": "error",
            "pos": {
                "line": 747,
                "column": 108
            },
            "endPos": {
                "line": 747,
                "column": 125
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2384423"
        },
        {
            "severity": "error",
            "pos": {
                "line": 753,
                "column": 2
            },
            "endPos": {
                "line": 754,
                "column": 84
            },
            "data": "linarith failed to find a contradiction\ncase h.a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\ny : \u2115\nhy : y \u2208 ?s\nh : x \u2264 y\na\u271d :\n  13 * x ^ 7 + 4 * x ^ 6 + 16 * x ^ 5 + 11 * x ^ 4 + 5 * x ^ 3 + 15 * x ^ 2 + 20 >\n    13 * y ^ 7 + 4 * y ^ 6 + 16 * y ^ 5 + 11 * y ^ 4 + 5 * y ^ 3 + 15 * y ^ 2 + 20\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 756,
                "column": 79
            },
            "endPos": {
                "line": 756,
                "column": 96
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2442405"
        },
        {
            "severity": "error",
            "pos": {
                "line": 757,
                "column": 27
            },
            "endPos": {
                "line": 757,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Icc_left'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 759,
                "column": 4
            },
            "endPos": {
                "line": 775,
                "column": 9
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  MonotoneOn\nhas type\n  (?m.2454307 \u2192 ?m.2454308) \u2192 Set ?m.2454307 \u2192 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 756,
                "column": 101
            },
            "endPos": {
                "line": 775,
                "column": 9
            },
            "data": "unsolved goals\nx\u271d : Sort u_1\nIcc : x\u271d\n\u22a2 MonotoneOn (fun x => 18 * x ^ 4 + 14 * x ^ 3 + 8 * x ^ 2 + 13 * x + 11) sorry"
        },
        {
            "severity": "error",
            "pos": {
                "line": 777,
                "column": 83
            },
            "endPos": {
                "line": 777,
                "column": 100
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2455702"
        },
        {
            "severity": "error",
            "pos": {
                "line": 780,
                "column": 30
            },
            "endPos": {
                "line": 780,
                "column": 34
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  x \u2208 ?s"
        },
        {
            "severity": "error",
            "pos": {
                "line": 780,
                "column": 30
            },
            "endPos": {
                "line": 780,
                "column": 34
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  Set.Mem ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 780,
                "column": 30
            },
            "endPos": {
                "line": 780,
                "column": 34
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  hx\nhas type\n  ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 781,
                "column": 30
            },
            "endPos": {
                "line": 781,
                "column": 34
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  x \u2208 ?s"
        },
        {
            "severity": "error",
            "pos": {
                "line": 781,
                "column": 30
            },
            "endPos": {
                "line": 781,
                "column": 34
            },
            "data": "invalid projection, structure expected\n  hx\nhas type\n  Set.Mem ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 781,
                "column": 30
            },
            "endPos": {
                "line": 781,
                "column": 34
            },
            "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  hx\nhas type\n  ?s x"
        },
        {
            "severity": "error",
            "pos": {
                "line": 782,
                "column": 2
            },
            "endPos": {
                "line": 782,
                "column": 80
            },
            "data": "linarith failed to find a contradiction\ncase h\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 ?s\nh1 : 0 \u2264 x\nh2 : x \u2264 1\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 784,
                "column": 90
            },
            "endPos": {
                "line": 784,
                "column": 107
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2475479"
        },
        {
            "severity": "error",
            "pos": {
                "line": 788,
                "column": 2
            },
            "endPos": {
                "line": 789,
                "column": 41
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry ()\ny : \u2115\nhy : y \u2208 sorry ()\nh : x \u2264 y\na\u271d :\n  10 + x * 2 + x ^ 2 * 6 + x ^ 5 * 12 + x ^ 6 * 17 + x ^ 7 * 5 >\n    10 + y * 2 + y ^ 2 * 6 + y ^ 5 * 12 + y ^ 6 * 17 + y ^ 7 * 5\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 791,
                "column": 66
            },
            "endPos": {
                "line": 791,
                "column": 83
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2520850"
        },
        {
            "severity": "error",
            "pos": {
                "line": 793,
                "column": 2
            },
            "endPos": {
                "line": 793,
                "column": 124
            },
            "data": "linarith failed to find a contradiction\ncase a\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\na\u271d : (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) x > (fun x => 10 * x ^ 6 + 12 * x ^ 5 + 20 * x ^ 2) y\n\u22a2 False failed"
        },
        {
            "severity": "error",
            "pos": {
                "line": 795,
                "column": 109
            },
            "endPos": {
                "line": 795,
                "column": 126
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2567243"
        },
        {
            "severity": "error",
            "pos": {
                "line": 797,
                "column": 2
            },
            "endPos": {
                "line": 797,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 801,
                "column": 73
            },
            "endPos": {
                "line": 801,
                "column": 90
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2588885"
        },
        {
            "severity": "error",
            "pos": {
                "line": 803,
                "column": 2
            },
            "endPos": {
                "line": 803,
                "column": 34
            },
            "data": "simp made no progress"
        },
        {
            "severity": "error",
            "pos": {
                "line": 807,
                "column": 77
            },
            "endPos": {
                "line": 807,
                "column": 94
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2600035"
        },
        {
            "severity": "error",
            "pos": {
                "line": 808,
                "column": 27
            },
            "endPos": {
                "line": 808,
                "column": 46
            },
            "data": "unknown identifier 'Icc_subset_Ici_self'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 809,
                "column": 10
            },
            "endPos": {
                "line": 809,
                "column": 12
            },
            "data": "tactic 'introN' failed, insufficient number of binders\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\n\u22a2 Prop"
        },
        {
            "severity": "error",
            "pos": {
                "line": 813,
                "column": 93
            },
            "endPos": {
                "line": 813,
                "column": 110
            },
            "data": "function expected at\n  Icc\nterm has type\n  ?m.2613108"
        },
        {
            "severity": "error",
            "pos": {
                "line": 815,
                "column": 12
            },
            "endPos": {
                "line": 815,
                "column": 22
            },
            "data": "unknown identifier 'mvt_on_Icc'"
        },
        {
            "severity": "error",
            "pos": {
                "line": 813,
                "column": 115
            },
            "endPos": {
                "line": 817,
                "column": 9
            },
            "data": "unsolved goals\nx\u271d : Sort u_1\nIcc : x\u271d\nx : \u2115\nhx : x \u2208 sorry\ny : \u2115\nhy : y \u2208 sorry\nhxy : x \u2264 y\n\u22a2 (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) x \u2264\n    (fun x => 20 * x ^ 7 + 11 * x ^ 6 + 16 * x ^ 3 + 17 * x ^ 2 + 18 * x + 11) y"
        }
    ],
    "env": 0
}