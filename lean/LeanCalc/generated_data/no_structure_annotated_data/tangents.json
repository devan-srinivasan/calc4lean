[
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1 - p.2 ^ 3 - p.2 ^ 2 - 3 * p.2 - c) ((-1:\u211d), (6:\u211d)) (x-(-1), y-6) = 0) \u2192 ((x-(-1)) * (-4) - (y-6) * (123) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1) ((-1:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) ((-1:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1 - p.2 ^ 3 - p.2 ^ 2 - 3 * p.2) ((-1:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1) ((-1:\u211d), (6:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) ((-1:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1) ((-1:\u211d), (6:\u211d))) (x - (-1), y - 6) = (x-(-1)) * (-4)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1) = (fun x => x ^ 3 + 2 * x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) ((-1:\u211d), (6:\u211d))) (x - (-1), y - 6) = (y-6) * (123)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) = (fun x => x ^ 3 + x ^ 2 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (6:\u211d)) (x - (-1), y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_snd.pow _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve x\u00b3 + 2x\u00b2 \u2212 3x \u2212 y\u00b3 \u2212 y\u00b2 \u2212 3y \u2212 c = 0 at the point (\u22121, 6) can be written as (x+1)(\u22124) \u2212 (y\u22126)(123) = 0. The overall approach is to compute the gradient of the function f(x, y) = x\u00b3 + 2x\u00b2 \u2212 3x \u2212 y\u00b3 \u2212 y\u00b2 \u2212 3y \u2212 c at (\u22121, 6), interpret the directional derivative as the dot product with the vector (x+1, y\u22126), set that to zero, and show that this is equivalent to the desired tangent equation. Introduce the main hypothesis: that the derivative at (\u22121, 6) acting on the vector (x+1, y\u22126) equals zero. Rewrite the total derivative by splitting out the constant c via the linearity property for subtraction in derivatives. State and prove a lemma that splits the derivative as a difference between two derivatives: one in x and one in y (with signs adjusted as appropriate). Assume differentiability of each part. Use the above splitting to express the total derivative in terms of component functions, and apply the action of the continuous linear maps accordingly. Show that the x-component (the derivative with respect to x of x\u00b3 + 2x\u00b2 \u2212 3x at (\u22121, 6)) acting on (x+1, y\u22126) gives (x+1)(\u22124). Express the function as a composition to isolate the x variable. Expand the derivative using standard sum, difference, power, and constant rules. Apply the resulting linear map to the (x+1, y\u22126) vector. Evaluate and simplify at the particular point to extract the coefficient (\u22124). Justify differentiability of each summand. Show that the y-component (the derivative with respect to y of y\u00b3 + y\u00b2 + 3y at (\u22121, 6)) acting on (x+1, y\u22126) gives (y\u22126)(123). Isolate the y-variable via composition. Expand the derivative using sum, power, and constant rules. Apply the result to the shift vector, picking out the coefficient of (y\u22126). Evaluate and simplify at y=6 to get 123. Prove differentiability of each summand. Show that differentiating a constant yields zero when applied to the direction vector. Substitute the above computations back into the main equation, combine terms, and simplify to obtain the required tangent line equation. Ensure that all required differentiability assumptions stated earlier are satisfied for the functions at (\u22121, 6)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 + 4 * p.1 - 2 * p.2 ^ 2 - 4 * p.2 - c) ((4:\u211d), (4:\u211d)) (x-4, y-4) = 0) \u2192 ((x-4) * (28) - (y-4) * (20) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 + 4 * p.1) ((4:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 2 + 4 * p.2) ((4:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 + 4 * p.1 - 2 * p.2 ^ 2 - 4 * p.2) ((4:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 + 4 * p.1) ((4:\u211d), (4:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 2 + 4 * p.2) ((4:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 + 4 * p.1) ((4:\u211d), (4:\u211d))) (x - 4, y - 4) = (x-4) * (28)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 + 4 * p.1) = (fun x => 3 * x ^ 2 + 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 2 + 4 * p.2) ((4:\u211d), (4:\u211d))) (x - 4, y - 4) = (y-4) * (20)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 2 + 4 * p.2) = (fun x => 2 * x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (4:\u211d)) (x - 4, y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve 3 * x^2 + 4 * x - 2 * y^2 - 4 * y - c = 0 at the point (4,4) is (x-4) * (28) - (y-4) * (20) = 0. The method is to compute the gradient (\u2207) of the function f(x, y) = 3 * x^2 + 4 * x - 2 * y^2 - 4 * y - c at (4, 4), then take the dot product with the shifted position vector (x-4, y-4). Setting this equal to 0 gives the tangent equation, which we demonstrate is equivalent to the desired equation. Introduce the hypothesis, which asserts that the dot product of the gradient at (4,4) with (x-4, y-4) is zero. Apply the rule for the derivative of a subtraction to split \u2207(3 * x^2 + 4 * x - 2 * y^2 - 4 * y - c) as \u2207(3 * x^2 + 4 * x - 2 * y^2 - 4 * y) minus \u2207(c). Introduce a hypothesis splitting the function into the sum/difference of functions of x and functions of y: \u2207(3 * x^2 + 4 * x - 2 * y^2 - 4 * y) = \u2207(3 * x^2 + 4 * x) - \u2207(2 * y^2 + 4 * y), assuming differentiability at each piece. Use linearity of the gradient to rewrite the expression accordingly. Show that \u2207(3 * x^2 + 4 * x) at (4,4) dotted with (x-4, y-4) yields (x-4)*28. Rewrite this as a composition of functions to reduce to a one-variable function in x. Compute the derivative of 3 * x^2 + 4 * x with respect to x at x = 4. Expand the gradient action and verify the arithmetic. Check differentiability of 3 * x^2 + 4 * x. Show that \u2207(2 * y^2 + 4 * y) at (4,4) dotted with (x-4, y-4) yields (y-4)*20. Rewrite as a function in y and compute the relevant derivative at y = 4. Simplify using the action of the gradient. Perform arithmetic to ensure you get 20 as the coefficient. Check differentiability of 2 * y^2 + 4 * y. Show that the derivative of a constant (\u2207(c)) vanishes. Combine the results from the previous steps to construct the final equation of the tangent line, and rearrange as needed. Confirm all differentiability conditions hold for the functions used."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 - 4 * p.2 ^ 2 - c) ((0:\u211d), (-1:\u211d)) (x-0, y-(-1)) = 0) \u2192 ((x-0) * (0) - (y-(-1)) * (-8) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2) ((0:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2) ((0:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 - 4 * p.2 ^ 2) ((0:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2) ((0:\u211d), (-1:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 2) ((0:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2) ((0:\u211d), (-1:\u211d))) (x - 0, y - (-1)) = (x-0) * (0)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2) = (fun x => 5 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2) ((0:\u211d), (-1:\u211d))) (x - 0, y - (-1)) = (y-(-1)) * (-8)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2) = (fun x => 4 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (-1:\u211d)) (x - 0, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 - 4 * y^2 - c = 0 at the point (0,-1) is (x-0) * 0 - (y-(-1)) * (-8) = 0. The approach is to compute the gradient (\u2207) of f(x,y) = 5 * x^2 - 4 * y^2 - c at (0,-1), and evaluate its dot product with the shifted positional vector (x-0, y-(-1)), set this to zero, and simplify to get the required equation. Introduce the hypothesis: the directional derivative (expressed as the dot product of the gradient at (0,-1) with (x-0, y-(-1))) is zero. Use the rule for the derivative of a subtraction to split \u2207(5 * x^2 - 4 * y^2 - c) into \u2207(5 * x^2 - 4 * y^2) - \u2207(c). Establish an intermediate result splitting \u2207(5 * x^2 - 4 * y^2) as \u2207(5 * x^2) - \u2207(4 * y^2), assuming differentiability for both functions at the given point. Substitute this split into the hypothesis, and apply linear map properties to rearrange the directional derivatives. Compute \u2207(5 * x^2) at (0,-1) dotted with (x-0, y-(-1)) = (x-0) * 0: Use composition rules to reduce to the single-variable derivative. Compute the relevant partial derivative with respect to x, evaluate at x=0. Substitute into the linear map expression and simplify. Justify differentiability of 5 * x^2. Compute \u2207(4 * y^2) at (0,-1) dotted with (x-0, y-(-1)) = (y-(-1)) * (-8): Use composition rules so that the gradient component with respect to y can be handled as a single-variable derivative. Compute and evaluate the y-partial at y = -1. Insert into the expression and simplify, paying attention to the sign. Justify differentiability of 4 * y^2. Show that the gradient of the constant term \u2207(c) at (0,-1) applied to (x-0, y-(-1)) is zero. Substitute these computations back into your original hypothesis, and perform arithmetic simplification to derive the final equation. Justify differentiability at all needed steps for the constituent functions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 + 2 * p.2 ^ 4 - c) ((4:\u211d), (1:\u211d)) (x-4, y-1) = 0) \u2192 ((x-4) * (48) + (y-1) * (8) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3) ((4:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 4) ((4:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 + 2 * p.2 ^ 4) ((4:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3) ((4:\u211d), (1:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 4) ((4:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3) ((4:\u211d), (1:\u211d))) (x - 4, y - 1) = (x-4) * (48)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3) = (fun x => x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 4) ((4:\u211d), (1:\u211d))) (x - 4, y - 1) = (y-1) * (8)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 4) = (fun x => 2 * x ^ 4) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (1:\u211d)) (x - 4, y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst.pow _\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 + 2*y^4 - c = 0 at the point (4,1) is (x-4) * (48) + (y-1) * (8) = 0. The key idea is to calculate the gradient (\u2207) of the function f(x, y) = x^3 + 2*y^4 - c at the point (4, 1), and then take its dot product with the shifted vector (x-4, y-1). Setting this to zero gives the equation of the tangent line at this point. Introduce the hypothesis, which states that the dot product of the gradient at (4,1) with the shifted vector (x-4, y-1) is zero. Apply the derivative rule of subtraction to split the gradient: \u2207(x^3 + 2*y^4 - c) = \u2207(x^3 + 2*y^4) - \u2207(c). Define a hypothesis splitting the sum: \u2207(x^3 + 2*y^4) = \u2207(x^3) + \u2207(2*y^4), assuming both terms are differentiable at the relevant point. Use the above splits and the rules for linear maps to express the total gradient as a sum/difference of the partial gradients. Compute \u2207(x^3) at (4,1) applied to (x-4, y-1), and show this equals (x-4) * 48: Use function composition: write x^3 in terms of a function of one variable. Use the chain rule and single-variable derivative to relate the partial derivative to the usual derivative. Show using basic differentiation rules that d/dx (x^3) at x=4 is 48. Use the properties of linear maps to conclude the dot product value. Demonstrate the differentiability of x^3. Compute \u2207(2*y^4) at (4,1) applied to (x-4, y-1), and show this equals (y-1) * 8: Use function composition to express 2*y^4 in terms of a single variable. Use the chain rule as before to relate to single-variable differentiation. Show using differentiation rules that the partial derivative with respect to y at y=1 is 8. Use properties of linear maps and differentiability of 2*y^4 to justify the result. Evaluate the gradient of the constant term c at (4,1) applied to any vector, and show that it is zero. Substitute the results from (5), (6), and (7) back into the original equation, obtaining a sum which simplifies directly to (x-4) * 48 + (y-1) * 8 = 0. Confirm differentiability where required for all component functions and their sums."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 4 + p.1 + p.2 ^ 2 + 4 * p.2 - c) ((-4:\u211d), (5:\u211d)) (x-(-4), y-5) = 0) \u2192 ((x-(-4)) * (-767) + (y-5) * (14) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 4 + p.1) ((-4:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 + 4 * p.2) ((-4:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 4 + p.1 + p.2 ^ 2 + 4 * p.2) ((-4:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 4 + p.1) ((-4:\u211d), (5:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 + 4 * p.2) ((-4:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 4 + p.1) ((-4:\u211d), (5:\u211d))) (x - (-4), y - 5) = (x-(-4)) * (-767)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 4 + p.1) = (fun x => 3 * x ^ 4 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 + 4 * p.2) ((-4:\u211d), (5:\u211d))) (x - (-4), y - 5) = (y-5) * (14)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 + 4 * p.2) = (fun x => x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (5:\u211d)) (x - (-4), y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^4 + x + y^2 + 4 * y - c = 0 at the point (-4, 5) is (x-(-4)) * (-767) + (y-5) * (14) = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = 3 * x^4 + x + y^2 + 4 * y - c at the point (-4, 5), then take the dot product of this gradient with the vector (x-(-4), y-5), yielding the equation of the tangent line, and show this is equivalent to the form required. Introduce the hypothesis, namely, that the dot product of the gradient at (-4, 5) with (x-(-4), y-5) is 0. Apply the derivative rule for subtraction to split the derivative: \u2207(3 * x^4 + x + y^2 + 4 * y - c) = \u2207(3 * x^4 + x + y^2 + 4 * y) - \u2207(c) Define an auxiliary hypothesis splitting \u2207(3 * x^4 + x + y^2 + 4 * y) = \u2207(3 * x^4 + x) + \u2207(y^2 + 4 * y). Assume differentiability at the corresponding points. Use this splitting and linearity properties to rewrite and reduce the tangent equation using the above gradients. Show that the directional derivative of \u2207(3 * x^4 + x) at (-4, 5) in direction (x-(-4), y-5) is (x-(-4)) * (-767) Express the function of x as composition, and apply the chain rule. Compute the gradient in x using appropriate differentiation rules. Evaluate the result at (-4, 5), then show the corresponding scalar multiplication results. Check that the function is differentiable at the required point. Show that the directional derivative of \u2207(y^2 + 4 * y) at (-4, 5) in direction (x-(-4), y-5) is (y-5) * (14) Similarly, express the function of y as a composition, and apply the chain rule. Compute the gradient in y using appropriate differentiation rules. Evaluate at (-4, 5), obtaining the appropriate scalar value. Confirm differentiability at the required point. Show that the derivative of any constant function (such as \u2207(c)) in any direction is 0. Substitute the above into the original tangent equation, simplify, and reduce to the required form. Prove differentiability of all needed intermediary functions at the specified points."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 + p.2 ^ 4 + 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 4 * p.2 - c) ((-2:\u211d), (-6:\u211d)) (x-(-2), y-(-6)) = 0) \u2192 ((x-(-2)) * (1) + (y-(-6)) * (-568) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1) ((-2:\u211d), (-6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 4 * p.2) ((-2:\u211d), (-6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 + p.2 ^ 4 + 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 4 * p.2) ((-2:\u211d), (-6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1) ((-2:\u211d), (-6:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 4 * p.2) ((-2:\u211d), (-6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1) ((-2:\u211d), (-6:\u211d))) (x - (-2), y - (-6)) = (x-(-2)) * (1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1) = (fun x => x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 4 * p.2) ((-2:\u211d), (-6:\u211d))) (x - (-2), y - (-6)) = (y-(-6)) * (-568)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 4 * p.2) = (fun x => x ^ 4 + 3 * x ^ 3 + 2 * x ^ 2 - 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (-6:\u211d)) (x - (-2), y - (-6)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x + y\u2074 + 3y\u00b3 + 2y\u00b2 - 4y - c = 0 at the point (-2, -6) is (x-(-2)) * (1) + (y-(-6)) * (-568) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = x + y\u2074 + 3y\u00b3 + 2y\u00b2 - 4y - c at the point (-2, -6), then take its dot product with the shifted positional vector (x-(-2), y-(-6)). Setting this to zero yields the tangent equation, which we want to rewrite in the form given. Introduce the hypothesis, which is the vanishing of the linear approximation (the directional derivative along (x-(-2), y-(-6)), given by the gradient dot the shift vector). Use the differentiation rule for subtraction to write the derivative of the sum-minus-c as the derivative of the curve expression minus the derivative of the constant function c. Define a hypothesis that splits the derivative of x + y\u2074 + 3y\u00b3 + 2y\u00b2 - 4y as the sum of the derivatives of x and y\u2074 + 3y\u00b3 + 2y\u00b2 - 4y, assuming sufficient differentiability at the relevant points. Use this to write the full derivative as \u2207(x) + \u2207(y\u2074 + 3y\u00b3 + 2y\u00b2 - 4y) - \u2207(c). Compute the effect of \u2207(x) at the point, evaluated in the direction (x-(-2), y-(-6)), and show this is (x-(-2)) * (1): Use function composition and differentiation rules to argue that the gradient with respect to x is just the partial, and evaluate appropriately. Argue differentiability of the function x. Compute the effect of \u2207(y\u2074 + 3y\u00b3 + 2y\u00b2 - 4y) at (-2, -6) and direction (x-(-2), y-(-6)), and establish this is (y-(-6)) * (-568): Use function composition and univariate derivative computation to obtain the partial with respect to y. Use the standard rules to compute and substitute the appropriate values of the derivatives at y = -6. Argue differentiability of y\u2074 + 3y\u00b3 + 2y\u00b2 - 4y at the relevant point. Show that the derivative of the constant function c is 0 (since it's constant, all partials vanish). Substitute the computed values into the main expression, and simplify using basic algebra. Ensure that all differentiability assumptions made throughout the proof are justified."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 - 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + 5 * p.2 - c) ((-5:\u211d), (3:\u211d)) (x-(-5), y-3) = 0) \u2192 ((x-(-5)) * (-30) - (y-3) * (88) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2) ((-5:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 5 * p.2) ((-5:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 - 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + 5 * p.2) ((-5:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2) ((-5:\u211d), (3:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 5 * p.2) ((-5:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2) ((-5:\u211d), (3:\u211d))) (x - (-5), y - 3) = (x-(-5)) * (-30)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2) = (fun x => 3 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 5 * p.2) ((-5:\u211d), (3:\u211d))) (x - (-5), y - 3) = (y-3) * (88)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 5 * p.2) = (fun x => 3 * x ^ 3 + 2 * x ^ 2 - 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (3:\u211d)) (x - (-5), y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 - 3 * y^3 - 2 * y^2 + 5 * y - c = 0 at the point (-5,3) is (x-(-5)) * (-30) - (y-3) * (88) = 0. The idea is to compute the gradient (\u2207) of the function f(x,y) = 3 * x^2 - 3 * y^3 - 2 * y^2 + 5 * y - c at the point (-5,3), then take the dot product of this gradient with the vector (x-(-5), y-3), and show the result is equivalent to the desired tangent equation. Introduce the given hypothesis: the directional derivative (the gradient applied to the shifted vector) equals zero. Use the derivative rule for subtraction to split \u2207(3 * x^2 - 3 * y^3 - 2 * y^2 + 5 * y - c) as \u2207(3 * x^2 - 3 * y^3 - 2 * y^2 + 5 * y) - \u2207(c). Define a hypothesis that expresses \u2207(3 * x^2 - 3 * y^3 - 2 * y^2 + 5 * y) as \u2207(3 * x^2) - \u2207(3 * y^3 + 2 * y^2 - 5 * y), assuming differentiability of both parts. Rewrite the original gradient at the point as the sum/difference of its components, using linearity of the differential and properties of linear maps. Show that \u2207(3 * x^2) at the point (-5,3) applied to (x-(-5), y-3) yields (x-(-5)) * (-30): Use composition rules and the chain rule to reduce the computation to a one-variable derivative. Compute the derivative with respect to x, evaluate at the given point, and check the action on (x-(-5), y-3). Use properties of linear maps and simplify to see the resulting multiple. Confirm differentiability of 3 * x^2. Show that \u2207(3 * y^3 + 2 * y^2 - 5 * y) at the point (-5,3) applied to (x-(-5), y-3) gives (y-3) * (88): Similarly, use composition and chain rules to reduce to a one-variable derivative in y. Compute and simplify the derivative at y=3, apply to the vector. Justify the use of linear map rules and algebraic manipulation for the result. Prove differentiability of 3*y^3 + 2*y^2 - 5*y. Show that the gradient of the constant c at this point applied to (x-(-5), y-3) is 0. Substitute the computed values into the original equation and simplify. Prove the differentiability of all component functions at the relevant point to justify each previous step."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + 5 * p.1 + 5 * p.2 ^ 3 + p.2 ^ 2 - c) ((-1:\u211d), (2:\u211d)) (x-(-1), y-2) = 0) \u2192 ((x-(-1)) * (10) + (y-2) * (64) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + 5 * p.1) ((-1:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3 + p.2 ^ 2) ((-1:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 + 5 * p.1 ^ 2 + 5 * p.1 + 5 * p.2 ^ 3 + p.2 ^ 2) ((-1:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + 5 * p.1) ((-1:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 3 + p.2 ^ 2) ((-1:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + 5 * p.1) ((-1:\u211d), (2:\u211d))) (x - (-1), y - 2) = (x-(-1)) * (10)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + 5 * p.1) = (fun x => 5 * x ^ 3 + 5 * x ^ 2 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3 + p.2 ^ 2) ((-1:\u211d), (2:\u211d))) (x - (-1), y - 2) = (y-2) * (64)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3 + p.2 ^ 2) = (fun x => 5 * x ^ 3 + x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (2:\u211d)) (x - (-1), y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^3 + 5 * x^2 + 5 * x + 5 * y^3 + y^2 - c = 0 at the point (-1,2) is (x-(-1)) * (10) + (y-2) * (64) = 0. The strategy is to compute the gradient (\u2207) of f(x, y) = 5 * x^3 + 5 * x^2 + 5 * x + 5 * y^3 + y^2 - c at (-1,2), then use the dot product with (x-(-1), y-2), and check that the result is as desired. Introduce the hypothesis: the dot product of the gradient at the point with the shifted vector is 0. Apply the rule of differentiation for subtraction to break up the gradient as \u2207(original function) = \u2207(sum polynomial) - \u2207(c). Further split \u2207(5 * x^3 + 5 * x^2 + 5 * x + 5 * y^3 + y^2) into \u2207(terms in x) + \u2207(terms in y), assuming differentiability of each part. Apply this decomposition to the hypothesis, using linearity of the derivative, so the equation splits into parts involving x, y, and the constant c. Compute the directional derivative for the x terms at (-1,2) in the (x-(-1), y-2) direction, showing it is (x-(-1)) * 10. Use the composition rule to express the x part as a function of one variable. Apply derivative rules: linearity and power rule. Simplify the resulting expression by evaluating the derivatives at x = -1. Ensure differentiability of all terms. Compute the directional derivative for the y terms at (-1,2) in the (x-(-1), y-2) direction, showing it is (y-2) * 64. Use the composition rule to express the y part as a function of one variable. Apply derivative rules: linearity and power rule. Simplify the resulting expression by evaluating the derivatives at y = 2. Ensure differentiability of all terms. Show that the derivative of the constant term c in any direction is zero. Substitute the results for all three parts back into the original equation to obtain the desired tangent equation. Prove differentiability of all constituent functions as needed for previous steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 - p.2 ^ 2 + p.2 - c) ((0:\u211d), (4:\u211d)) (x-0, y-4) = 0) \u2192 ((x-0) * (0) - (y-4) * (7) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2) ((0:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 - p.2) ((0:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 - p.2 ^ 2 + p.2) ((0:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2) ((0:\u211d), (4:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 2 - p.2) ((0:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2) ((0:\u211d), (4:\u211d))) (x - 0, y - 4) = (x-0) * (0)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2) = (fun x => 4 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 - p.2) ((0:\u211d), (4:\u211d))) (x - 0, y - 4) = (y-4) * (7)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 - p.2) = (fun x => x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (4:\u211d)) (x - 0, y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^2 - y^2 + y - c = 0 at the point (0,4) is (x-0) * 0 - (y-4) * 7 = 0. The strategy is to calculate the gradient (\u2207) of f(x,y) = 4x^2 - y^2 + y - c at the point (0,4), take the dot product with the vector (x-0, y-4), set this to zero, and show this is equivalent to (x-0)*0 - (y-4)*7=0.  Introduce the hypothesis, which is the statement that the dot product of the gradient at (0,4) with the vector (x-0, y-4) is zero. Use the linearity of the derivative to split the derivative of a sum/subtraction: \u2207(4x^2 - y^2 + y - c) = \u2207(4x^2) - \u2207(y^2 - y) - \u2207(c). Construct a hypothesis splitting \u2207(4x^2 - y^2 + y) = \u2207(4x^2) - \u2207(y^2 - y), assuming differentiability of both parts. Apply the split and linearity to separately treat the terms in the gradient expression. Show that \u2207(4x^2) at (0,4), when applied to (x-0, y-4), yields (x-0) * 0. Use composition and product rules to express the gradient as a derivative with respect to x. Compute the derivative, evaluate at the point in question, apply necessary linear and algebraic simplifications. Justify differentiability of 4x^2. Show that \u2207(y^2 - y) at (0,4), when applied to (x-0, y-4), yields (y-4) * 7. Use composition and difference rules to express the gradient as a derivative with respect to y. Compute the derivative, evaluate at the given point, apply necessary linear and algebraic simplifications. Justify differentiability of y^2 - y. Show that the derivative of the constant c, applied at the point, gives zero. Substitute the evaluated gradients back, simplify the equation, and rearrange to match the desired result. Justify differentiability of each individual function and of the total expression for completeness."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 - 4 * p.2 ^ 4 + 5 * p.2 ^ 3 - 4 * p.2 - c) ((1:\u211d), (-4:\u211d)) (x-1, y-(-4)) = 0) \u2192 ((x-1) * (5) - (y-(-4)) * (-1260) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1) ((1:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 + 4 * p.2) ((1:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 - 4 * p.2 ^ 4 + 5 * p.2 ^ 3 - 4 * p.2) ((1:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1) ((1:\u211d), (-4:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 + 4 * p.2) ((1:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1) ((1:\u211d), (-4:\u211d))) (x - 1, y - (-4)) = (x-1) * (5)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1) = (fun x => 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 + 4 * p.2) ((1:\u211d), (-4:\u211d))) (x - 1, y - (-4)) = (y-(-4)) * (-1260)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 + 4 * p.2) = (fun x => 4 * x ^ 4 - 5 * x ^ 3 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (-4:\u211d)) (x - 1, y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5*x - 4*y^4 + 5*y^3 - 4*y - c = 0 at the point (1, -4) is (x-1) * 5 - (y-(-4)) * (-1260) = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = 5*x - 4*y^4 + 5*y^3 - 4*y - c at the point (1, -4); then, form its dot product with the shifted position vector (x-1, y-(-4)). Setting that equal to 0 gives the equation of the tangent at the point, and we show this is equivalent to the given equation. Introduce the main hypothesis, which states that the dot product of the gradient at (1, -4) with (x-1, y-(-4)) is zero. Apply the derivative rule for subtraction to split \u2207(5*x - 4*y^4 + 5*y^3 - 4*y - c) as \u2207(5*x - 4*y^4 + 5*y^3 - 4*y) minus \u2207(c). Introduce a hypothesis splitting \u2207(5*x - 4*y^4 + 5*y^3 - 4*y) as \u2207(5*x) minus \u2207(4*y^4 - 5*y^3 + 4*y). Assume differentiability of (5*x) and (4*y^4 - 5*y^3 + 4*y) at the point. Use the hypothesis to rewrite the main gradient as the difference of the two component gradients, applying the rules for linear maps (including dot products). Show that \u2207(5*x) at (1, -4) dotted with (x-1, y-(-4)) yields (x-1)*5: Use composition and differentiation rules to reduce the calculation to the single-variable derivative. Take the derivative with respect to x. Use the properties of linear maps and scalar multiplication to complete this calculation. Prove differentiability of 5*x. Show that \u2207(4*y^4 - 5*y^3 + 4*y) at (1, -4) dotted with (x-1, y-(-4)) gives (y-(-4)) * (-1260): Use composition and differentiation rules to reduce to a single-variable calculation in y. Compute the derivative with respect to y at y = -4. Evaluate the resulting expression using properties of linear maps and algebra. Prove differentiability of 4*y^4 - 5*y^3 + 4*y. Show that the derivative of the constant c term dotted with the position vector is zero. Substitute the results of the previous computations back into the expression for the tangent equation. Use algebraic simplification to show equivalence to (x-1) * 5 - (y-(-4)) * (-1260) = 0. 10) Throughout, justify the differentiability of the respective functions as required."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 + 2 * p.1 + 5 * p.2 - c) ((-3:\u211d), (-5:\u211d)) (x-(-3), y-(-5)) = 0) \u2192 ((x-(-3)) * (-16) + (y-(-5)) * (5) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 + 2 * p.1) ((-3:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2) ((-3:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 + 2 * p.1 + 5 * p.2) ((-3:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 + 2 * p.1) ((-3:\u211d), (-5:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2) ((-3:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 + 2 * p.1) ((-3:\u211d), (-5:\u211d))) (x - (-3), y - (-5)) = (x-(-3)) * (-16)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 + 2 * p.1) = (fun x => 3 * x ^ 2 + 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2) ((-3:\u211d), (-5:\u211d))) (x - (-3), y - (-5)) = (y-(-5)) * (5)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2) = (fun x => 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-5:\u211d)) (x - (-3), y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 + 2 * x + 5 * y - c = 0 at the point (-3, -5) is (x-(-3)) * (-16) + (y-(-5)) * (5) = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = 3 * x^2 + 2 * x + 5 * y - c at the given point, evaluate the differential along the vector (x-(-3), y-(-5)), and then recognize that this gives the equation of the tangent line, as desired. Introduce the hypothesis: fderiv (gradient) applied to the vector from the base point equals zero. Apply the differentiation rule of subtraction to split the derivative: \u2207(3 * x^2 + 2 * x + 5 * y - c) = \u2207(3 * x^2 + 2 * x + 5 * y) - \u2207(c). State and use a splitting lemma: \u2207(3 * x^2 + 2 * x + 5 * y) = \u2207(3 * x^2 + 2 * x) + \u2207(5 * y), provided both functions are differentiable at that point. Use the linearity properties to rewrite the full fderiv of the sum in terms of the two subparts and the constant. Show that \u2207(3 * x^2 + 2 * x) at (-3, -5) evaluated on (x-(-3), y-(-5)) yields (x-(-3)) * (-16): Express this as a composition, so the gradient with respect to the first variable is the same as the usual derivative, composed with projection. Compute the relevant derivatives by applying rules for sums and products. Unfold the linear maps and use algebraic simplification to obtain the final result. Argue or recall the differentiability of 3 * x^2 + 2 * x. Show that \u2207(5 * y) at (-3, -5) evaluated on (x-(-3), y-(-5)) yields (y-(-5)) * 5: Again, write as a composition, reduce to the univariate case, and compute the derivative. Use simplification and linear map properties to reach the result. Note the differentiability of 5 * y. Show that \u2207(c) at (-3, -5) evaluated on any vector is zero since c is constant. Substitute the parts back into the expression, using the previously calculated results to reduce \u2207(3 * x^2 + 2 * x + 5 * y - c) to the explicit form. Justify differentiability of all the function pieces involved: \u2207(3 * x^2 + 2 * x), \u2207(5 * y), the sum, and the constant function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 + 5 * p.1 ^ 2 + 2 * p.2 - c) ((-4:\u211d), (3:\u211d)) (x-(-4), y-3) = 0) \u2192 ((x-(-4)) * (8) + (y-3) * (2) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 + 5 * p.1 ^ 2) ((-4:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2) ((-4:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 + 5 * p.1 ^ 2 + 2 * p.2) ((-4:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 + 5 * p.1 ^ 2) ((-4:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2) ((-4:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 + 5 * p.1 ^ 2) ((-4:\u211d), (3:\u211d))) (x - (-4), y - 3) = (x-(-4)) * (8)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 + 5 * p.1 ^ 2) = (fun x => x ^ 3 + 5 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2) ((-4:\u211d), (3:\u211d))) (x - (-4), y - 3) = (y-3) * (2)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2) = (fun x => 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (3:\u211d)) (x - (-4), y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 + 5x^2 + 2y - c = 0 at the point (-4,3) is (x-(-4)) * 8 + (y-3) * 2 = 0. The idea is to compute the gradient (\u2207) of the function f(x,y) = x^3 + 5x^2 + 2y - c at the point (-4,3), then take the dot product of this gradient with the vector (x-(-4), y-3). Setting this equal to zero gives us the tangent equation, which we then show is equivalent to the required form. Introduce the hypothesis, stating that the dot product of the gradient with (x-(-4), y-3) equals zero. Apply the rule for the derivative of subtraction to split \u2207(x^3 + 5x^2 + 2y - c) into \u2207(x^3 + 5x^2 + 2y) - \u2207(c). Define an intermediate hypothesis which expresses \u2207(x^3 + 5x^2 + 2y) as \u2207(x^3 + 5x^2) + \u2207(2y), assuming differentiability for these parts. Use this split and rules of linear maps to expand the calculation for the gradient of the full function at the specified point. Show that the gradient of x^3 + 5x^2 at (-4,3), applied to (x-(-4), y-3), yields (x-(-4)) * 8. Express x^3 + 5x^2 as a function of x and use composition and derivative rules to reduce the multivariable derivative to a simple derivative. Compute the actual derivative with respect to x and evaluate at x = -4. Apply the appropriate properties of linear maps to get the final result. Indicate differentiability of x^3 + 5x^2. Show that the gradient of 2y at (-4,3), applied to (x-(-4), y-3), gives (y-3) * 2. Write 2y as a function of y and reduce the derivative calculation accordingly. Compute the derivative with respect to y and evaluate at y = 3. Use linearity to conclude the result. Prove differentiability of 2y with respect to y. Show that the gradient of the constant c vanishes when applied to (x-(-4), y-3). Substitute all computed results back into the hypothesis and simplify. Prove differentiability wherever assumed previously, to justify application of the splitting and calculation steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 + p.2 ^ 3 + p.2 - c) ((1:\u211d), (2:\u211d)) (x-1, y-2) = 0) \u2192 ((x-1) * (5) + (y-2) * (13) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1) ((1:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 + p.2) ((1:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 + p.2 ^ 3 + p.2) ((1:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1) ((1:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 3 + p.2) ((1:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1) ((1:\u211d), (2:\u211d))) (x - 1, y - 2) = (x-1) * (5)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1) = (fun x => 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 + p.2) ((1:\u211d), (2:\u211d))) (x - 1, y - 2) = (y-2) * (13)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 + p.2) = (fun x => x ^ 3 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (2:\u211d)) (x - 1, y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x + y^3 + y - c = 0 at the point (1,2) is (x-1) * 5 + (y-2) * 13 = 0. The idea is to calculate the gradient (\u2207) of the function f(x,y) = 5x + y^3 + y - c at the point (1,2), then take the dot product of this gradient with the vector (x-1, y-2). Setting this equal to 0 gives the equation of the tangent, which should match (x-1) * 5 + (y-2) * 13 = 0.  Introduce the hypothesis, which is that the dot product of the gradient with (x-1, y-2) is 0. Apply the rule for the derivative of a subtraction to split \u2207(5x + y^3 + y - c) = \u2207(5x + y^3 + y) - \u2207(c). Define a hypothesis splitting the gradient of 5x + y^3 + y as \u2207(5x) + \u2207(y^3 + y), assuming differentiability of both components at (1,2). Substitute this split and use linearity of the derivative to organize the terms as the sum and difference of gradients. Show that the gradient of 5x at (1,2) dotted with (x-1, y-2) yields (x-1) * 5: Write 5x as a composition, apply the chain rule, and reduce to a univariate derivative. Calculate the partial derivative with respect to x. Use properties of linear maps to simplify. Establish differentiability of 5x at (1,2). Show that the gradient of y^3 + y at (1,2) dotted with (x-1, y-2) gives (y-2) * 13: Write y^3 + y as a composition, apply the chain rule, and reduce to a univariate derivative. Calculate the partial derivative with respect to y. Use properties of linear maps to simplify. Establish differentiability of y^3 + y at (1,2). Show that the gradient of c is 0 everywhere, so the dot product gives 0. Substitute the simplified results back into the original hypothesis and simplify to match the required tangent equation. Justify all differentiability assumptions for 5x, y^3 + y, and c at (1,2)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 + p.1 + p.2 - c) ((-3:\u211d), (2:\u211d)) (x-(-3), y-2) = 0) \u2192 ((x-(-3)) * (-23) + (y-2) * (1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2 + p.1) ((-3:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2) ((-3:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 + p.1 + p.2) ((-3:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2 + p.1) ((-3:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => p.2) ((-3:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2 + p.1) ((-3:\u211d), (2:\u211d))) (x - (-3), y - 2) = (x-(-3)) * (-23)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2 + p.1) = (fun x => 4 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2) ((-3:\u211d), (2:\u211d))) (x - (-3), y - 2) = (y-2) * (1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2) = (fun x => x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (2:\u211d)) (x - (-3), y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact differentiableAt_snd\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^2 + x + y - c = 0 at the point (-3,2) is (x-(-3)) * (-23) + (y-2) * (1) = 0. The strategy is to compute the gradient (\u2207) of f(x, y) = 4 * x^2 + x + y - c at the point (-3,2), take its dot product with the vector (x-(-3), y-2), and show that this equation is equivalent to the desired form.  Introduce the hypothesis, i.e., assume that the dot product of the gradient at (-3,2) with (x-(-3), y-2), is zero. Use the rule for the derivative of a subtraction to separate the computations into \u2207(4 * x^2 + x + y) - \u2207(c). Introduce a hypothesis splitting the gradient of 4 * x^2 + x + y into \u2207(4 * x^2 + x) + \u2207(y), assuming differentiability at both pieces. Apply this splitting and use the rules for linear maps to organize the computation into a sum and subtraction of the corresponding directional derivatives. Compute the directional derivative for \u2207(4 * x^2 + x) at the point (-3,2): Use composition and chain rules to reduce to ordinary derivatives in x. Explicitly calculate the derivative of 4 * x^2 + x at x = -3. Carry out linear map algebra to confirm the value is (x-(-3))*(-23). Justify differentiability of the function in x. Compute the directional derivative for \u2207(y) at the point (-3,2): Observe that derivative with respect to y is constant; handle via composition. Evaluate the derivative at y = 2. Use linear map properties to verify this gives (y-2)*(1). Justify differentiability of the function in y. Show that the derivative of the constant term (c) at any point, applied to any vector, is zero. Substitute all pieces back and simplify using algebraic manipulation to show it matches the desired tangent equation. Justify the differentiability of the full function from the differentiability of its components."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1 + p.2 ^ 3 - p.2 ^ 2 + 4 * p.2 - c) ((-5:\u211d), (-2:\u211d)) (x-(-5), y-(-2)) = 0) \u2192 ((x-(-5)) * (421) + (y-(-2)) * (20) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1 + p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (-2:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (-2:\u211d))) (x - (-5), y - (-2)) = (x-(-5)) * (421)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1) = (fun x => 5 * x ^ 3 - 5 * x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-2:\u211d))) (x - (-5), y - (-2)) = (y-(-2)) * (20)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) = (fun x => x ^ 3 - x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (-2:\u211d)) (x - (-5), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_snd.pow _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^3 - 5 * x^2 - 4 * x + y^3 - y^2 + 4 * y - c = 0 at the point (-5, -2) is (x-(-5)) * (421) + (y-(-2)) * (20) = 0. The plan is to compute the gradient (\u2207) of the function f(x, y) = 5 * x^3 - 5 * x^2 - 4 * x + y^3 - y^2 + 4 * y - c at (-5, -2), take the dot product of \u2207f evaluated at that point with the shifted vector (x-(-5), y-(-2)), and set it to 0 to get the tangent equation. Then show this is equivalent to (x-(-5)) * 421 + (y-(-2)) * 20 = 0.  Introduce the hypothesis: the dot product of the gradient and (x-(-5), y-(-2)) at (-5, -2) is 0. Apply the rule for the derivative of a difference to split the derivative of the whole function as the derivative of everything except c minus the derivative of c. Create a hypothesis splitting the gradient of (5 * x^3 - 5 * x^2 - 4 * x + y^3 - y^2 + 4 * y) into a sum of gradients in the x and y parts. Assume differentiability at the relevant points. Use the above split and properties of the linear map to rewrite the gradient in terms of the x part and y part, minus the constant term. Show that the contribution from the x-part is (x-(-5)) * 421: Represent the x-contribution as a function of one variable by composition. Use chain rule and differentiation rules (sum, subtraction, power, constant multiple) to compute the derivative with respect to x. Pull the result through the linear map and evaluate at (x-(-5), y-(-2)), simplifying as needed and confirming the numeric coefficient. Prove differentiability of the x-part. Show that the contribution from the y-part is (y-(-2)) * 20: Represent the y-contribution as a function of one variable through composition. Use chain rule and differentiation rules (sum, subtraction, power, constant multiple) to compute the derivative with respect to y. Pull the result through the linear map and evaluate at (x-(-5), y-(-2)), simplifying as needed and confirming the numeric coefficient. Prove differentiability of the y-part. Show that the gradient of the constant c, when dotted with the shifted vector, yields zero. Substitute these computations back into the original hypothesis and simplify. Prove the differentiability of all relevant pieces: the x-part, y-part, the original full function (sum of both), and the constant term."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 + p.2 ^ 2 + 5 * p.2 - c) ((-5:\u211d), (-4:\u211d)) (x-(-5), y-(-4)) = 0) \u2192 ((x-(-5)) * (3) + (y-(-4)) * (-3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1) ((-5:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 + 5 * p.2) ((-5:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 + p.2 ^ 2 + 5 * p.2) ((-5:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1) ((-5:\u211d), (-4:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 + 5 * p.2) ((-5:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1) ((-5:\u211d), (-4:\u211d))) (x - (-5), y - (-4)) = (x-(-5)) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1) = (fun x => 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 + 5 * p.2) ((-5:\u211d), (-4:\u211d))) (x - (-5), y - (-4)) = (y-(-4)) * (-3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 + 5 * p.2) = (fun x => x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (-4:\u211d)) (x - (-5), y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve 3 * x + y^2 + 5 * y - c = 0 at the point (-5,-4) can be written as (x-(-5)) * 3 + (y-(-4)) * (-3) = 0. The core idea is to compute the gradient of f(x, y) = 3 * x + y^2 + 5 * y - c at this point, then set its dot product with (x-(-5), y-(-4)) to zero, and then show this results in the claimed tangent equation. Introduce the hypothesis that the dot product of the gradient at the base point with the positional vector (x-(-5), y-(-4)) is zero. Apply the derivative rule for subtraction to split the total gradient: \u2207(3x + y^2 + 5y - c) = \u2207(3x + y^2 + 5y) - \u2207(c). Define an auxiliary result to split the gradient further: \u2207(3x + y^2 + 5y) = \u2207(3x) + \u2207(y^2 + 5y), assuming differentiability for both parts. Substitute this split into the main hypothesis and expand the linear maps corresponding to the addition and subtraction. Show that the directional derivative (fderiv) of 3x at (-5, -4) along (x-(-5), y-(-4)) is (x-(-5)) * 3. Represent 3x as a composition and use the chain rule for differentiation. Compute the one-dimensional derivative. Simplify the resulting linear map and perform necessary algebraic manipulations. Justify differentiability of 3x at the point. Show the directional derivative (fderiv) of y^2 + 5y at (-5, -4) along (x-(-5), y-(-4)) is (y-(-4)) * (-3). Represent y^2 + 5y as a composition and use the chain rule. Compute the one-dimensional derivative. Verify using linear map rules and numeric simplification. Justify differentiability of y^2 + 5y. Show that the directional derivative (fderiv) of the constant function c is zero. Substitute the above component results into the original hypothesis to reduce the equation. Finish by applying algebraic simplification to match with the desired tangent equation. 10) At the end, ensure that differentiability is established for each required function (3x, y^2 + 5y, and the sum with c)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 3 + p.2 - c) ((4:\u211d), (2:\u211d)) (x-4, y-2) = 0) \u2192 ((x-4) * (144) + (y-2) * (1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 3) ((4:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2) ((4:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 3 + p.2) ((4:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 3) ((4:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => p.2) ((4:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 3) ((4:\u211d), (2:\u211d))) (x - 4, y - 2) = (x-4) * (144)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 3) = (fun x => 3 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2) ((4:\u211d), (2:\u211d))) (x - 4, y - 2) = (y-2) * (1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2) = (fun x => x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (2:\u211d)) (x - 4, y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact differentiableAt_snd\n  \n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^3 + y - c = 0 at the point (4,2) is (x-4) * 144 + (y-2) * 1 = 0. The strategy is to calculate the gradient (\u2207) of f(x,y)=3 * x^3 + y - c at the point (4,2), then take its dot product with the vector (x-4, y-2). Setting this equal to 0 gives the tangent equation, which we need to show matches the desired expression. Introduce the hypothesis that the dot product of the gradient at (4,2) with the vector (x-4, y-2) is zero. Apply the rule for differentiating a difference to split the derivative of (3 * x^3 + y - c) into the derivative of (3 * x^3 + y) minus the derivative of c. Break up the derivative of (3 * x^3 + y) further into the derivative of (3 * x^3) plus the derivative of y, provided both are differentiable at the chosen point. Use the structure of linear maps to reflect the split of the function into the sum and difference of components. Show that the gradient of (3 * x^3) at (4,2) dotted with (x-4, y-2) becomes (x-4) * 144: Recognize that this is a function of x only, use composition and differentiation rules to connect partial and total derivatives. Compute the derivative of 3 * x^3 at x = 4. Express the dot product in terms of the appropriate variable. Justify differentiability of 3 * x^3 with respect to x. Show that the gradient of y at (4,2) dotted with (x-4, y-2) is (y-2): Recognize this is a function of y only, use corresponding composition and differentiation rules. Compute the derivative with respect to y. Express the result of the dot product in terms of y. Justify differentiability of y with respect to y. Show that the gradient of the constant c at (4,2) dotted with (x-4, y-2) is 0. Substitute the above results into the original hypothesis to get (x-4) * 144 + (y-2) * 1 = 0. Make sure to establish differentiability for all involved component functions: (3 * x^3), y, their sum, and c."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 + 2 * p.1 ^ 2 + 3 * p.1 - 5 * p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2 - c) ((-3:\u211d), (-2:\u211d)) (x-(-3), y-(-2)) = 0) \u2192 ((x-(-3)) * (99) - (y-(-2)) * (-216) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3 + 2 * p.1 ^ 2 + 3 * p.1) ((-3:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 4 - 5 * p.2 ^ 3 - p.2 ^ 2) ((-3:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 + 2 * p.1 ^ 2 + 3 * p.1 - 5 * p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2) ((-3:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3 + 2 * p.1 ^ 2 + 3 * p.1) ((-3:\u211d), (-2:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 4 - 5 * p.2 ^ 3 - p.2 ^ 2) ((-3:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3 + 2 * p.1 ^ 2 + 3 * p.1) ((-3:\u211d), (-2:\u211d))) (x - (-3), y - (-2)) = (x-(-3)) * (99)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3 + 2 * p.1 ^ 2 + 3 * p.1) = (fun x => 4 * x ^ 3 + 2 * x ^ 2 + 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 4 - 5 * p.2 ^ 3 - p.2 ^ 2) ((-3:\u211d), (-2:\u211d))) (x - (-3), y - (-2)) = (y-(-2)) * (-216)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 4 - 5 * p.2 ^ 3 - p.2 ^ 2) = (fun x => 5 * x ^ 4 - 5 * x ^ 3 - x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-2:\u211d)) (x - (-3), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 + 2 * x^2 + 3 * x - 5 * y^4 + 5 * y^3 + y^2 - c = 0 at the point (-3,-2) is (x-(-3)) * (99) - (y-(-2)) * (-216) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 4 * x^3 + 2 * x^2 + 3 * x - 5 * y^4 + 5 * y^3 + y^2 - c at the point (-3, -2), then take the dot product of this gradient with the positional vector (x-(-3), y-(-2)). Setting this equation equal to zero gives the tangent equation, and your job is to show this is equivalent to the form above.  Introduce the hypothesis, which asserts the dot product of the gradient at (-3, -2) with the shifted positional vector (x-(-3), y-(-2)) equals zero. Use the linearity of the derivative to split the gradient of the sum/difference: \u2207(4 * x^3 + 2 * x^2 + 3 * x - 5 * y^4 + 5 * y^3 + y^2 - c) = \u2207(4 * x^3 + 2 * x^2 + 3 * x - 5 * y^4 + 5 * y^3 + y^2) - \u2207(c) Define an intermediate result splitting the gradient with respect to x and y: \u2207(4 * x^3 + 2 * x^2 + 3 * x - 5 * y^4 + 5 * y^3 + y^2) = \u2207(4 * x^3 + 2 * x^2 + 3 * x) - \u2207(5 * y^4 - 5 * y^3 - y^2), provided relevant differentiability. Prove this by algebraic manipulation and using differentiability at the point. Apply the splitting above to rewrite the main gradient expression in the hypothesis and use the properties of linear maps accordingly. Show that evaluating the gradient \u2207(4 * x^3 + 2 * x^2 + 3 * x) at the point (-3, -2), then applying it to (x-(-3), y-(-2)), gives (x-(-3)) * (99): Use the chain rule and composition to focus the derivative with respect to x. Calculate the derivative at the specified point. Use properties of linear maps and algebraic simplification to establish the result. Justify the necessary differentiability. Show that the gradient \u2207(5 * y^4 - 5 * y^3 - y^2) at the point (-3, -2), applied to (x-(-3), y-(-2)), equals (y-(-2)) * (-216): Use composition and the chain rule to focus on the derivative with respect to y. Calculate this derivative at (-3, -2). Use properties of linear maps and explicit calculation to get the result. Establish relevant differentiability. Show that the gradient of the constant c at any point applied to (x-(-3), y-(-2)) is 0. Substitute your results for each gradient component into the original hypothesis and simplify. Confirm differentiability for each function composed in the chain of derivative rules applied for both x- and y-dependent parts and their combination."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 + 5 * p.1 - p.2 ^ 3 - 5 * p.2 ^ 2 + p.2 - c) ((-2:\u211d), (-4:\u211d)) (x-(-2), y-(-4)) = 0) \u2192 ((x-(-2)) * (-15) - (y-(-4)) * (7) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((-2:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 + 5 * p.2 ^ 2 - p.2) ((-2:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 + 5 * p.1 - p.2 ^ 3 - 5 * p.2 ^ 2 + p.2) ((-2:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((-2:\u211d), (-4:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 3 + 5 * p.2 ^ 2 - p.2) ((-2:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((-2:\u211d), (-4:\u211d))) (x - (-2), y - (-4)) = (x-(-2)) * (-15)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 + 5 * p.1) = (fun x => 5 * x ^ 2 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 + 5 * p.2 ^ 2 - p.2) ((-2:\u211d), (-4:\u211d))) (x - (-2), y - (-4)) = (y-(-4)) * (7)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 + 5 * p.2 ^ 2 - p.2) = (fun x => x ^ 3 + 5 * x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (-4:\u211d)) (x - (-2), y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5x^2 + 5x - y^3 - 5y^2 + y - c = 0 at the point (-2, -4) is (x-(-2)) * (-15) - (y-(-4)) * (7) = 0. The general idea is to compute the gradient of the function f(x, y) = 5x^2 + 5x - y^3 - 5y^2 + y - c at the point (-2, -4), take the dot product with the vector (x-(-2), y-(-4)), set that equal to zero, and show this is equivalent to the required tangent equation. Introduce the assumption: the dot product of the gradient at the given point with the shifted vector is 0. Use the subtraction rule to write the gradient of the whole expression as the gradient of (5x^2 + 5x - y^3 - 5y^2 + y) minus the gradient of the constant c. Define a step for splitting the gradient of (5x^2 + 5x - y^3 - 5y^2 + y) into the gradient with respect to x (5x^2 + 5x) and the gradient with respect to y (y^3 + 5y^2 - y); assume differentiability at these points. Use this splitting and properties of linear maps to organize the computation of the gradient as a sum and then a subtraction. Show that the gradient of (5x^2 + 5x) at (-2, -4) dotted with (x-(-2), y-(-4)) gives (x-(-2)) * (-15) Express the single-variable part as a composition, moving from \u211d\u00d7\u211d to \u211d, using projection. Use differentiation rules to compute the derivative of 5x^2 + 5x at x = -2. Correctly apply the linear maps and the dot product to obtain the factor -15. Justify differentiability at the required point. Show that the gradient of (y^3 + 5y^2 - y) at (-2, -4) dotted with (x-(-2), y-(-4)) gives (y-(-4)) * (7) Reduce to differentiating a single-variable function by composing with the y-projection. Compute the derivative of y^3 + 5y^2 - y at y = -4. Apply map properties and dot product to extract the coefficient of 7. Justify differentiability at the required point. Show that the gradient of the constant c at (-2, -4), dotted with (x-(-2), y-(-4)), is 0. Substitute these results into the equation and simplify to show the equivalence with the desired tangent equation. Throughout, check and state differentiability of the component functions and the combinations used, as required."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 4 + p.1 ^ 3 - p.1 ^ 2 - 2 * p.1 - 3 * p.2 ^ 4 - p.2 ^ 2 - c) ((-5:\u211d), (5:\u211d)) (x-(-5), y-5) = 0) \u2192 ((x-(-5)) * (-2417) - (y-5) * (1510) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 - p.1 ^ 2 - 2 * p.1) ((-5:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 4 + p.2 ^ 2) ((-5:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 4 + p.1 ^ 3 - p.1 ^ 2 - 2 * p.1 - 3 * p.2 ^ 4 - p.2 ^ 2) ((-5:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 - p.1 ^ 2 - 2 * p.1) ((-5:\u211d), (5:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 4 + p.2 ^ 2) ((-5:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 - p.1 ^ 2 - 2 * p.1) ((-5:\u211d), (5:\u211d))) (x - (-5), y - 5) = (x-(-5)) * (-2417)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 4 + p.1 ^ 3 - p.1 ^ 2 - 2 * p.1) = (fun x => 5 * x ^ 4 + x ^ 3 - x ^ 2 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 4 + p.2 ^ 2) ((-5:\u211d), (5:\u211d))) (x - (-5), y - 5) = (y-5) * (1510)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 4 + p.2 ^ 2) = (fun x => 3 * x ^ 4 + x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (5:\u211d)) (x - (-5), y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^4 + x^3 - x^2 - 2x - 3y^4 - y^2 - c = 0 at the point (-5, 5) is (x-(-5)) * (-2417) - (y-5) * (1510) = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = 5 * x^4 + x^3 - x^2 - 2x - 3y^4 - y^2 - c at the point (-5, 5), take its dot product with the shift vector (x-(-5), y-5), and equate this to 0. This then gives the tangent equation, to be shown equal to (x-(-5)) * (-2417) - (y-5) * (1510) = 0.  Introduce the hypothesis: the dot product of the gradient with (x-(-5), y-5) is zero. Use the subtraction rule for derivatives to split the gradient \u2207(5x^4 + x^3 - x^2 - 2x - 3y^4 - y^2 - c) as \u2207(5x^4 + x^3 - x^2 - 2x - 3y^4 - y^2) - \u2207(c). Define a hypothesis splitting \u2207(5x^4 + x^3 - x^2 - 2x - 3y^4 - y^2) as the difference of the gradients: \u2207(5x^4 + x^3 - x^2 - 2x) - \u2207(3y^4 + y^2). Assume differentiability at both parts. Use this split and properties of linear maps to further write the gradient at the relevant point and apply it to (x-(-5), y-5). Show that the evaluation of the gradient of (5x^4 + x^3 - x^2 - 2x) at (-5, 5), in the direction (x-(-5), y-5), yields (x-(-5)) * (-2417): Express the function as a composition with the projection to the first coordinate and apply composition and differentiation rules. Compute the derivative of the polynomial in x, substitute x = -5, and apply linear map rules to obtain the result. Establish differentiability of the polynomial part with respect to x. Show that the evaluation of the gradient of (3y^4 + y^2) at (-5, 5), in the direction (x-(-5), y-5), yields (y-5) * (1510): Express the function as a composition with the projection to the second coordinate and apply differentiation rules accordingly. Compute the derivative of the polynomial in y, substitute y = 5, and apply linear map rules to get the value. Show differentiability for the relevant function of y. Show that the constant term \u2207(c) applied at any point is zero. Substitute the results for the gradients/evaluations above into the hypothesis, simplify, and deduce that (x-(-5)) * (-2417) - (y-5) * (1510) = 0. Justify differentiability of all relevant component functions and combinations at the point of interest."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 - 4 * p.1 + p.2 ^ 4 - 2 * p.2 ^ 3 - 2 * p.2 ^ 2 - 2 * p.2 - c) ((1:\u211d), (-5:\u211d)) (x-1, y-(-5)) = 0) \u2192 ((x-1) * (4) + (y-(-5)) * (-632) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2 - 4 * p.1) ((1:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 - 2 * p.2 ^ 3 - 2 * p.2 ^ 2 - 2 * p.2) ((1:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 - 4 * p.1 + p.2 ^ 4 - 2 * p.2 ^ 3 - 2 * p.2 ^ 2 - 2 * p.2) ((1:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2 - 4 * p.1) ((1:\u211d), (-5:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 - 2 * p.2 ^ 3 - 2 * p.2 ^ 2 - 2 * p.2) ((1:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2 - 4 * p.1) ((1:\u211d), (-5:\u211d))) (x - 1, y - (-5)) = (x-1) * (4)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2 - 4 * p.1) = (fun x => 4 * x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 - 2 * p.2 ^ 3 - 2 * p.2 ^ 2 - 2 * p.2) ((1:\u211d), (-5:\u211d))) (x - 1, y - (-5)) = (y-(-5)) * (-632)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 - 2 * p.2 ^ 3 - 2 * p.2 ^ 2 - 2 * p.2) = (fun x => x ^ 4 - 2 * x ^ 3 - 2 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (-5:\u211d)) (x - 1, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4x\u00b2 - 4x + y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y - c = 0 at the point (1, -5) is (x-1) * 4 + (y-(-5)) * (-632) = 0. The general method is to calculate the gradient (\u2207) of the function f(x, y) = 4x\u00b2 - 4x + y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y - c at (1, -5), take the dot product with the vector (x-1, y-(-5)), and set the result to zero\u2014this gives the tangent\u2019s equation, which you must show matches the given result.  Introduce the hypothesis that the dot product of the gradient of f at (1, -5) with the vector (x-1, y-(-5)) equals zero. Rewrite the function as a sum and difference: split \u2207(4x\u00b2 - 4x + y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y - c) as \u2207(4x\u00b2 - 4x + y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y) - \u2207(c). Formulate a hypothesis that allows you to express the gradient of 4x\u00b2 - 4x + y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y as the sum of gradients: \u2207(4x\u00b2 - 4x) + \u2207(y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y), and assume differentiability at the relevant points. Apply this split and use properties of linear maps to further separate the gradients and apply them to (x-1, y-(-5)). Show that \u2207(4x\u00b2 - 4x) at (1, -5) applied to (x-1, y-(-5)) equals (x-1) * 4: Use composition and univariate derivative rules to reduce to scalar derivatives. Compute the derivative of 4x\u00b2 - 4x with respect to x and evaluate at x=1. Apply linear map properties and simplify. Justify differentiability of 4x\u00b2 - 4x. Show that \u2207(y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y) at (1, -5) applied to (x-1, y-(-5)) equals (y-(-5)) * (-632): Use composition and reduce gradient to scalar derivatives. Compute the derivative of y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y with respect to y, evaluate at y = -5. Apply linear map properties and simplify to the required value. Justify differentiability of y\u2074 - 2y\u00b3 - 2y\u00b2 - 2y. Show that the gradient of the constant term c, applied to (x-1, y-(-5)), is zero. Substitute all results back and simplify the tangent equation accordingly. Ensure all differentiability hypotheses for the required pieces (and their sums/differences) are satisfied."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1 + 2 * p.2 ^ 2 - c) ((1:\u211d), (-1:\u211d)) (x-1, y-(-1)) = 0) \u2192 ((x-1) * (-11) + (y-(-1)) * (-4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1) ((1:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 2) ((1:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1 + 2 * p.2 ^ 2) ((1:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1) ((1:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 2) ((1:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1) ((1:\u211d), (-1:\u211d))) (x - 1, y - (-1)) = (x-1) * (-11)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - 5 * p.1 ^ 2 - 4 * p.1) = (fun x => x ^ 3 - 5 * x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 2) ((1:\u211d), (-1:\u211d))) (x - 1, y - (-1)) = (y-(-1)) * (-4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 2) = (fun x => 2 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (-1:\u211d)) (x - 1, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve x^3 - 5x^2 - 4x + 2y^2 - c = 0 at the point (1, -1) can be written as (x-1) * (-11) + (y-(-1)) * (-4) = 0. The idea is to compute the gradient of f(x, y) = x^3 - 5x^2 - 4x + 2y^2 - c at (1, -1), take its dot product with the shifted vector (x-1, y-(-1)), and show this equation is equivalent to the tangent form given. Introduce the hypothesis, which says the dot product of the gradient with the shifted vector equals zero. Apply the rule for differentiating a difference to rewrite the gradient of (x^3 - 5x^2 - 4x + 2y^2 - c) as the gradient of (x^3 - 5x^2 - 4x + 2y^2) minus the gradient of c. Define a hypothesis that splits the gradient of (x^3 - 5x^2 - 4x + 2y^2) as the sum of the gradient of (x^3 - 5x^2 - 4x) and the gradient of (2y^2). Assume differentiability at the relevant points for each term. Substitute these splits into the main equation, using rules for linear maps to rewrite. Show that the gradient of (x^3 - 5x^2 - 4x) at (1, -1) applied to the shifted vector (x-1, y-(-1)) produces the factor (x-1) * (-11). Apply composition and differentiation rules to reduce to the one-variable derivative. Compute the derivative with respect to x. Use linear map application and simplify. Argue differentiability as required for this part. Show that the gradient of (2y^2) at (1, -1) applied to the shifted vector yields the (y-(-1)) * (-4) factor. Use composition and differentiation rules as before. Differentiate with respect to y and evaluate at the point. Apply simplification. Argue differentiability of 2y^2 as needed. Show that the gradient of c, being constant, applied to the shifted vector gives 0. Substitute all these results into the hypothesis and simplify the resulting equality to reach (x-1) * (-11) + (y-(-1)) * (-4) = 0. Ensure that differentiability is established for each function involved, as justified at the required steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 - 4 * p.2 ^ 3 + 4 * p.2 ^ 2 + 3 * p.2 - c) ((5:\u211d), (-4:\u211d)) (x-5, y-(-4)) = 0) \u2192 ((x-5) * (20) - (y-(-4)) * (221) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2) ((5:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2 - 3 * p.2) ((5:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 - 4 * p.2 ^ 3 + 4 * p.2 ^ 2 + 3 * p.2) ((5:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2) ((5:\u211d), (-4:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2 - 3 * p.2) ((5:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2) ((5:\u211d), (-4:\u211d))) (x - 5, y - (-4)) = (x-5) * (20)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2) = (fun x => 2 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2 - 3 * p.2) ((5:\u211d), (-4:\u211d))) (x - 5, y - (-4)) = (y-(-4)) * (221)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 - 4 * p.2 ^ 2 - 3 * p.2) = (fun x => 4 * x ^ 3 - 4 * x ^ 2 - 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (-4:\u211d)) (x - 5, y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x^2 - 4y^3 + 4y^2 + 3y - c = 0 at the point (5, -4) is (x-5) * 20 - (y-(-4)) * 221 = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 2x^2 - 4y^3 + 4y^2 + 3y - c at point (5, -4), then evaluate its dot product with the shifted vector (x-5, y-(-4)). Setting this equal to 0 gives the equation of the tangent, which we need to show is equivalent to the explicit expression provided.  Introduce the hypothesis, stating that the dot product of the gradient at (5, -4) with the shifted vector (x-5, y-(-4)) is zero. Apply the rule for the derivative of a difference to split \u2207(2x^2 - 4y^3 + 4y^2 + 3y - c) into \u2207(2x^2 - 4y^3 + 4y^2 + 3y) - \u2207(c). Introduce a hypothesis expressing that \u2207(2x^2 - 4y^3 + 4y^2 + 3y) = \u2207(2x^2) - \u2207(4y^3 - 4y^2 - 3y), assuming the necessary differentiability at the relevant points. Use this splitting and properties of linear maps to rewrite the total gradient expression accordingly. Show that the directional derivative of 2x^2 at (5, -4) in the direction (x-5, y-(-4)) is (x-5) * 20. Use function composition and the rules for differentiating compositions, reducing the multivariable differentiation of 2x^2 to a one-variable derivative. Compute the required partial derivative with respect to x. Apply the directional derivative and linear map properties to obtain the explicit result. Justify the differentiability of 2x^2 as needed. Show that the directional derivative of (4y^3 - 4y^2 - 3y) at (5, -4), in the direction (x-5, y-(-4)), is (y-(-4)) * 221. Express the function in terms of a composition to isolate the y-dependence. Calculate the necessary partial derivative with respect to y. Use directional derivative and linear map properties to rewrite the result in the required form. Justify the differentiability of 4y^3 - 4y^2 - 3y as necessary. Show that the derivative of the constant term c in any direction is 0. Substitute the intermediate results back into the hypothesis and simplify to reach the required conclusion about the equation of the tangent. Ensure all relevant differentiability statements for the involved components are justified."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 - 2 * p.2 ^ 3 + 5 * p.2 ^ 2 + 2 * p.2 - c) ((-4:\u211d), (-3:\u211d)) (x-(-4), y-(-3)) = 0) \u2192 ((x-(-4)) * (240) - (y-(-3)) * (82) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3) ((-4:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3 - 5 * p.2 ^ 2 - 2 * p.2) ((-4:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 - 2 * p.2 ^ 3 + 5 * p.2 ^ 2 + 2 * p.2) ((-4:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3) ((-4:\u211d), (-3:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 3 - 5 * p.2 ^ 2 - 2 * p.2) ((-4:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3) ((-4:\u211d), (-3:\u211d))) (x - (-4), y - (-3)) = (x-(-4)) * (240)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3) = (fun x => 5 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3 - 5 * p.2 ^ 2 - 2 * p.2) ((-4:\u211d), (-3:\u211d))) (x - (-4), y - (-3)) = (y-(-3)) * (82)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3 - 5 * p.2 ^ 2 - 2 * p.2) = (fun x => 2 * x ^ 3 - 5 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (-3:\u211d)) (x - (-4), y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^3 - 2 * y^3 + 5 * y^2 + 2 * y - c = 0 at the point (-4,-3) is (x-(-4)) * 240 - (y-(-3)) * 82 = 0. The strategy is to compute the gradient (\u2207) of f(x, y) = 5 * x^3 - 2 * y^3 + 5 * y^2 + 2 * y - c at the point (-4, -3), then take its dot product with the shifted vector (x-(-4), y-(-3)), and equate it to 0. We must show this tangent equation is equivalent to (x-(-4)) * 240 - (y-(-3)) * 82 = 0.  Introduce the hypothesis, stating that the directional derivative of f at (-4, -3) along (x-(-4), y-(-3)) is zero. Apply the differentiation rule for subtraction to split the derivative: \u2207(5 * x^3 - 2 * y^3 + 5 * y^2 + 2 * y - c) = \u2207(5 * x^3 - 2 * y^3 + 5 * y^2 + 2 * y) - \u2207(c) Further split the inner function using differentiability: \u2207(5 * x^3 - 2 * y^3 + 5 * y^2 + 2 * y) = \u2207(5 * x^3) - \u2207(2 * y^3 - 5 * y^2 - 2 * y) - Assume the relevant components are differentiable at the point. Substitute the gradient splits into the hypothesis, and use properties of linear maps to separate the expressions. Compute the explicit value of the directional derivative of 5 * x^3 at (-4, -3), applied to (x-(-4), y-(-3)): Recognize that this is a composition, so apply the chain rule. Compute the gradient for the first variable, obtaining the coefficient at (-4). Simplify algebraically to get (x-(-4)) * 240. Verify differentiability of 5 * x^3 as a function of x at the point. Compute the value of the directional derivative for 2 * y^3 - 5 * y^2 - 2 * y at (-4, -3) along (x-(-4), y-(-3)): Recognize this depends only on y, so again the gradient components reduce. Compute the derivative in the y-direction at y = -3. Simplify algebraically to obtain (y-(-3)) * 82. Justify differentiability of 2 * y^3 - 5 * y^2 - 2 * y at the point. Show that the directional derivative of the constant c along (x-(-4), y-(-3)) is zero. Substitute all computed directional derivatives into the original hypothesis, and simplify using field/tactic simplifications. Prove all functions involved are indeed differentiable at the required points."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - 4 * p.1 ^ 2 + p.1 - p.2 ^ 3 + 3 * p.2 ^ 2 - 4 * p.2 - c) ((-1:\u211d), (-2:\u211d)) (x-(-1), y-(-2)) = 0) \u2192 ((x-(-1)) * (12) - (y-(-2)) * (28) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + p.1) ((-1:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) ((-1:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - 4 * p.1 ^ 2 + p.1 - p.2 ^ 3 + 3 * p.2 ^ 2 - 4 * p.2) ((-1:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + p.1) ((-1:\u211d), (-2:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) ((-1:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + p.1) ((-1:\u211d), (-2:\u211d))) (x - (-1), y - (-2)) = (x-(-1)) * (12)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - 4 * p.1 ^ 2 + p.1) = (fun x => x ^ 3 - 4 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) ((-1:\u211d), (-2:\u211d))) (x - (-1), y - (-2)) = (y-(-2)) * (28)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) = (fun x => x ^ 3 - 3 * x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (-2:\u211d)) (x - (-1), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 - 4x^2 + x - y^3 + 3y^2 - 4y - c = 0 at the point (-1,-2) is (x-(-1)) * 12 - (y-(-2)) * 28 = 0. The main idea is to compute the gradient (\u2207) of the function f(x,y) = x^3 - 4x^2 + x - y^3 + 3y^2 - 4y - c at the point (-1, -2), take the dot product with the shifted position vector (x-(-1), y-(-2)), and set this equal to 0 to describe the tangent. We need to show that this tangent equation simplifies to (x-(-1)) * 12 - (y-(-2)) * 28 = 0. Introduce the hypothesis, representing the dot product of the gradient of the function with the shifted position vector, equated to 0. Use the derivative rule for subtraction to split \u2207(x^3 - 4x^2 + x - y^3 + 3y^2 - 4y - c) = \u2207(x^3 - 4x^2 + x - y^3 + 3y^2 - 4y) - \u2207(c). Define a hypothesis that splits the gradient further as \u2207(x^3 - 4x^2 + x - y^3 + 3y^2 - 4y) = \u2207(x^3 - 4x^2 + x) - \u2207(y^3 - 3y^2 + 4y), using differentiability at each component. Apply the above splitting and rules of linear maps to rewrite the gradient as \u2207(x^3 - 4x^2 + x) - \u2207(y^3 - 3y^2 + 4y) - \u2207(c). Compute the value of \u2207(x^3 - 4x^2 + x) at (-1,-2) applied to (x-(-1), y-(-2)), and show it is (x-(-1)) * 12. Express the function as a composition to focus on partial derivatives with respect to x. Use the chain and sum rules to compute the derivative with respect to x and evaluate at x = -1. Use properties of linear maps and algebraic simplification to derive the required equality. Justify differentiability for x^3 - 4x^2 + x. Compute the value of \u2207(y^3 - 3y^2 + 4y) at (-1,-2) applied to (x-(-1), y-(-2)), and show it is (y-(-2)) * 28. Write the function as a composition to isolate partial derivatives with respect to y. Use the sum and chain rules to compute the derivative with respect to y and evaluate at y = -2. Use properties of linear maps and algebraic simplification to arrive at the required form. Justify differentiability for y^3 - 3y^2 + 4y. Show that the gradient of the constant term c applied to the vector is zero. Substitute all previous calculations back to simplify the original gradient equation, yielding the tangent form. Provide the necessary differentiability arguments for all used functions and their combinations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 - 3 * p.2 - c) ((-5:\u211d), (-3:\u211d)) (x-(-5), y-(-3)) = 0) \u2192 ((x-(-5)) * (-10) - (y-(-3)) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2) ((-5:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2) ((-5:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 - 3 * p.2) ((-5:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2) ((-5:\u211d), (-3:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2) ((-5:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2) ((-5:\u211d), (-3:\u211d))) (x - (-5), y - (-3)) = (x-(-5)) * (-10)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2) = (fun x => x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2) ((-5:\u211d), (-3:\u211d))) (x - (-5), y - (-3)) = (y-(-3)) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2) = (fun x => 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (-3:\u211d)) (x - (-5), y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst.pow _\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x ^ 2 - 3 * y - c = 0 at the point (-5, -3) is (x-(-5)) * (-10) - (y-(-3)) * (3) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = x^2 - 3y - c at the point (-5, -3), then take the dot product of this gradient with the shifted vector (x - (-5), y - (-3)). Setting this equal to 0 gives the equation of the tangent, which needs to be shown equivalent to (x-(-5)) * (-10) - (y-(-3)) * (3) = 0. Introduce the hypothesis that (the dot product of the gradient and the shifted positional vector) equals 0. Use the derivative rule for subtraction to split the gradient of (x^2 - 3y - c) into \u2207(x^2 - 3y) - \u2207(c). State and prove that \u2207(x^2 - 3y) = \u2207(x^2) - \u2207(3y), assuming differentiability of the relevant parts at the point. Use this decomposition and the linear map rules to express \u2207(x^2 - 3y - c) in terms of \u2207(x^2), \u2207(3y), and \u2207(c). Show that \u2207(x^2) at (-5, -3) dot (x-(-5), y-(-3)) = (x-(-5)) * (-10). Express the map as a composition suitable for applying the chain rule. Apply differentiation rules (power rule for x^2) to get the derivative at x = -5. Apply the action of the continuous linear map and simplify. Prove differentiability of x^2 at (-5, -3). Show that \u2207(3y) at (-5, -3) dot (x-(-5), y-(-3)) = (y-(-3)) * (3). Express the map as a composition. Apply differentiation rules (product/constant multiple rule for 3y) to get the derivative at y = -3. Apply the action of the continuous linear map and simplify. Prove differentiability of 3y at (-5, -3). Show that \u2207(c) at (-5, -3) dot (x-(-5), y-(-3)) = 0. Substitute the results above into the original hypothesis to obtain the required tangent equation. Justify differentiability of all relevant component functions at the point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 3 + 3 * p.1 ^ 2 + 3 * p.2 - c) ((1:\u211d), (1:\u211d)) (x-1, y-1) = 0) \u2192 ((x-1) * (15) + (y-1) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2) ((1:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2) ((1:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 3 + 3 * p.1 ^ 2 + 3 * p.2) ((1:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2) ((1:\u211d), (1:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2) ((1:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2) ((1:\u211d), (1:\u211d))) (x - 1, y - 1) = (x-1) * (15)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 3 + 3 * p.1 ^ 2) = (fun x => 3 * x ^ 3 + 3 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2) ((1:\u211d), (1:\u211d))) (x - 1, y - 1) = (y-1) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2) = (fun x => 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (1:\u211d)) (x - 1, y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^3 + 3 * x^2 + 3 * y - c = 0 at the point (1,1) is (x-1) * (15) + (y-1) * (3) = 0. The approach is to compute the gradient (\u2207) of f(x, y) = 3 * x^3 + 3 * x^2 + 3 * y - c at (1,1), then take the dot product with the shift (x-1, y-1), set this equal to zero, and show this reduces to the explicit tangent equation.  Introduce the hypothesis: the dot product of the gradient at (1,1) with the vector (x-1, y-1) is zero. Apply the rule for the derivative of a subtraction to split the gradient of 3 * x^3 + 3 * x^2 + 3 * y - c as the gradient of 3 * x^3 + 3 * x^2 + 3 * y minus the gradient of c. Further split the sum into two parts: the gradient of (3 * x^3 + 3 * x^2) and the gradient of (3 * y), and assume each is differentiable at the point. Use the above splitting and properties of linear maps to write the gradient of the original function as \u2207(3 * x^3 + 3 * x^2) + \u2207(3 * y) - \u2207(c). Compute the gradient \u2207(3 * x^3 + 3 * x^2) at (1,1), acting on (x-1, y-1), and show this equals (x-1) * (15). Use chain and product/composition rules to see that the total derivative with respect to x corresponds to the single-variable derivative. Calculate the derivatives of the relevant terms at x = 1, sum the contributions, and show the linear map evaluation produces 15 * (x-1). Show the function is differentiable at (1,1). Compute the gradient \u2207(3 * y) at (1,1), acting on (x-1, y-1), and show this equals (y-1) * 3. Use relevant rules to reduce this to a derivative with respect to y. Compute the necessary derivative and apply the corresponding linear map. Show the function is differentiable at (1,1). Show the gradient of c at any point, acting on any vector, gives 0. Substitute these expressions back and simplify to obtain the equation (x-1) * 15 + (y-1) * 3 = 0 for the tangent. Confirm all differentiability hypotheses required for the above decompositions and calculations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 4 - 3 * p.1 ^ 3 + 2 * p.1 ^ 2 - 5 * p.1 - p.2 ^ 4 - c) ((-6:\u211d), (-4:\u211d)) (x-(-6), y-(-4)) = 0) \u2192 ((x-(-6)) * (-2081) - (y-(-4)) * (-256) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 4 - 3 * p.1 ^ 3 + 2 * p.1 ^ 2 - 5 * p.1) ((-6:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4) ((-6:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 4 - 3 * p.1 ^ 3 + 2 * p.1 ^ 2 - 5 * p.1 - p.2 ^ 4) ((-6:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 4 - 3 * p.1 ^ 3 + 2 * p.1 ^ 2 - 5 * p.1) ((-6:\u211d), (-4:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 4) ((-6:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 4 - 3 * p.1 ^ 3 + 2 * p.1 ^ 2 - 5 * p.1) ((-6:\u211d), (-4:\u211d))) (x - (-6), y - (-4)) = (x-(-6)) * (-2081)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 4 - 3 * p.1 ^ 3 + 2 * p.1 ^ 2 - 5 * p.1) = (fun x => 2 * x ^ 4 - 3 * x ^ 3 + 2 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4) ((-6:\u211d), (-4:\u211d))) (x - (-6), y - (-4)) = (y-(-4)) * (-256)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4) = (fun x => x ^ 4) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (-4:\u211d)) (x - (-6), y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact differentiableAt_snd.pow _\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^4 - 3 * x^3 + 2 * x^2 - 5 * x - y^4 - c = 0 at the point (-6, -4) is (x-(-6)) * (-2081) - (y-(-4)) * (-256) = 0. The plan is to compute the gradient (\u2207) of the function f(x, y) = 2 * x^4 - 3 * x^3 + 2 * x^2 - 5 * x - y^4 - c at (-6, -4), then form the dot product with the direction vector (x-(-6), y-(-4)). Setting this to zero yields the tangent's equation, which we then show matches the desired result. Introduce the hypothesis, which asserts that the dot product of the gradient at (-6, -4) with (x-(-6), y-(-4)) equals 0. Apply the rule for the derivative of a difference to break up \u2207(2 * x^4 - 3 * x^3 + 2 * x^2 - 5 * x - y^4) into \u2207(2 * x^4 - 3 * x^3 + 2 * x^2 - 5 * x) minus \u2207(y^4). Explicitly define a hypothesis capturing this split, and require differentiability of the relevant parts at the point in question. Use linearity of the derivative to express the gradient at (-6, -4) as the difference of the gradients of the component functions. Calculate: Show that the gradient of 2 * x^4 - 3 * x^3 + 2 * x^2 - 5 * x, applied as above, gives (x-(-6)) * (-2081). 5.1.1) Show this function only depends on x; thus, apply the chain rule and univariate derivative inside a composition. 5.1.2) Compute the derivative with respect to x at x = -6 using rules for powers and sums (be careful with coefficients). 5.1.3) Substitute and simplify; also show this function is differentiable. Show that the gradient of y^4, applied as above, gives (y-(-4)) * (-256). 5.2.1) Argue that this function only depends on y, so use the appropriate projection and chain rule. 5.2.2) Compute the derivative with respect to y at y = -4. 5.2.3) Substitute and show the function is differentiable. Show that the derivative of the constant c with respect to (x, y) is zero when applied to any vector. Substitute these results into the original equation and simplify the resulting algebraic expression. Collect final differentiability statements for each component function as needed to justify the previous arguments."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 + p.2 ^ 3 - 3 * p.2 ^ 2 - 5 * p.2 - c) ((6:\u211d), (-2:\u211d)) (x-6, y-(-2)) = 0) \u2192 ((x-6) * (4) + (y-(-2)) * (19) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1) ((6:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 - 3 * p.2 ^ 2 - 5 * p.2) ((6:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 + p.2 ^ 3 - 3 * p.2 ^ 2 - 5 * p.2) ((6:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1) ((6:\u211d), (-2:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 3 - 3 * p.2 ^ 2 - 5 * p.2) ((6:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1) ((6:\u211d), (-2:\u211d))) (x - 6, y - (-2)) = (x-6) * (4)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1) = (fun x => 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 - 3 * p.2 ^ 2 - 5 * p.2) ((6:\u211d), (-2:\u211d))) (x - 6, y - (-2)) = (y-(-2)) * (19)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 - 3 * p.2 ^ 2 - 5 * p.2) = (fun x => x ^ 3 - 3 * x ^ 2 - 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (-2:\u211d)) (x - 6, y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x + y^3 - 3 * y^2 - 5 * y - c = 0 at the point (6, -2) is (x-6) * 4 + (y-(-2)) * 19 = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = 4 * x + y^3 - 3 * y^2 - 5 * y - c at the point (6, -2), evaluate its dot product with (x-6, y-(-2)), and equate to 0 to recover the tangent line equation. The steps are as follows:  Introduce the hypothesis, which states that the dot product of the gradient evaluated at (6, -2) with (x-6, y-(-2)) is 0.  Apply the rule for the derivative of a subtraction to split \u2207(4 * x + y^3 - 3 * y^2 - 5 * y - c) into \u2207(4 * x + y^3 - 3 * y^2 - 5 * y) minus the gradient of the constant term.  Introduce a hypothesis to further split \u2207(4 * x + y^3 - 3 * y^2 - 5 * y) as the sum of \u2207(4 * x) and \u2207(y^3 - 3 * y^2 - 5 * y), assuming both functions are differentiable at (6, -2).  Substitute these splits back into the original equation, using linearity of the differential and apply corresponding linear map rules to expand out the expression for the dot product.  Show that \u2207(4 * x) at (6, -2) dotted with (x-6, y-(-2)) yields (x-6) * 4: Use composition rules to rewrite 4 * p.1 as a composition with the first coordinate. Calculate the derivative with respect to x. Prove the equality using properties of linear maps and algebraic simplification. Justify differentiability at the given point.  Show that \u2207(y^3 - 3 * y^2 - 5 * y) at (6, -2) dotted with (x-6, y-(-2)) equals (y-(-2)) * 19: Use composition rules to write y^3 - 3*y^2 - 5*y as a function of the second coordinate. Calculate the derivative with respect to y. Use linear maps and algebra to arrive at the result. Justify differentiability at the given point.  Show that the gradient of the constant term (with respect to (x, y)) at (6, -2) dotted with (x-6, y-(-2)) equals 0.  Substitute the results from steps 5-7 into the original equation, and simplify to show that (x-6) * 4 + (y-(-2)) * 19 = 0.  Verify differentiability of all intermediate functions used in the splitting steps, to justify all applications of the rules above."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 + p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + p.2 - c) ((-3:\u211d), (6:\u211d)) (x-(-3), y-6) = 0) \u2192 ((x-(-3)) * (5) + (y-6) * (1393) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1) ((-3:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + p.2) ((-3:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 + p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + p.2) ((-3:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1) ((-3:\u211d), (6:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + p.2) ((-3:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1) ((-3:\u211d), (6:\u211d))) (x - (-3), y - 6) = (x-(-3)) * (5)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1) = (fun x => 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + p.2) ((-3:\u211d), (6:\u211d))) (x - (-3), y - 6) = (y-6) * (1393)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + p.2) = (fun x => x ^ 4 + 5 * x ^ 3 - x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (6:\u211d)) (x - (-3), y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x + y^4 + 5 * y^3 - y^2 + y - c = 0 at the point (-3,6) is (x-(-3)) * (5) + (y-6) * (1393) = 0. The approach is to compute the gradient (\u2207) of f(x, y) = 5x + y^4 + 5y^3 - y^2 + y - c at the point (-3, 6), take its dot product with the vector (x - (-3), y - 6), set it equal to zero, and show this yields the tangent equation given. Introduce the main hypothesis: the dot product of the gradient at (-3, 6) with (x-(-3), y-6) is zero. Use the derivative rule for subtraction to split the gradient of the full function into \u2207(5x + y^4 + 5y^3 - y^2 + y) minus \u2207(c). Define a hypothesis splitting further: show that the gradient of 5x + y^4 + 5y^3 - y^2 + y equals the sum of the gradients for 5x and y^4 + 5y^3 - y^2 + y, assuming differentiability at these parts. Apply this split, and use rules of linear maps to rewrite the overall gradient as \u2207(5x) plus \u2207(y^4 + 5y^3 - y^2 + y), minus \u2207(c). Show that the gradient of 5x at (-3, 6) dot (x-(-3), y-6) is (x-(-3)) * 5. Use chain rule and product rule for differentiation with respect to x. Compute the derivative of 5x with respect to x. Use properties of linear maps and simplify algebraically. Establish differentiability of 5x as a function of (x, y). Show that the gradient of y^4 + 5y^3 - y^2 + y at (-3, 6) dot (x-(-3), y-6) is (y-6) * 1393. Use chain rule and sum rule for differentiation with respect to y. Compute the derivative with respect to y, combine terms appropriately. Apply linear map rules and algebraic manipulation to reach the final form. Establish differentiability of y^4 + 5y^3 - y^2 + y as a function of (x, y). Show that the gradient of the constant c at (-3, 6) dot (x-(-3), y-6) is 0. Substitute the results from these steps back into the original equation and simplify. Fill in differentiability assumptions for all components used in the derivation, as required by the previous steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - 4 * p.1 ^ 2 + 3 * p.1 + p.2 ^ 2 - p.2 - c) ((6:\u211d), (-2:\u211d)) (x-6, y-(-2)) = 0) \u2192 ((x-6) * (63) + (y-(-2)) * (-5) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + 3 * p.1) ((6:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 - p.2) ((6:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - 4 * p.1 ^ 2 + 3 * p.1 + p.2 ^ 2 - p.2) ((6:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + 3 * p.1) ((6:\u211d), (-2:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 - p.2) ((6:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + 3 * p.1) ((6:\u211d), (-2:\u211d))) (x - 6, y - (-2)) = (x-6) * (63)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - 4 * p.1 ^ 2 + 3 * p.1) = (fun x => x ^ 3 - 4 * x ^ 2 + 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 - p.2) ((6:\u211d), (-2:\u211d))) (x - 6, y - (-2)) = (y-(-2)) * (-5)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 - p.2) = (fun x => x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (-2:\u211d)) (x - 6, y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 - 4x^2 + 3x + y^2 - y - c = 0 at the point (6, -2) is (x-6) * 63 + (y-(-2)) * (-5) = 0. The method is to compute the gradient (\u2207) of f(x, y) = x^3 - 4x^2 + 3x + y^2 - y - c at (6, -2), take its dot product with (x-6, y-(-2)), and set this to zero; this yields the tangent equation, which we match to the desired result. Introduce the hypothesis, stating the dot product of the gradient at (6, -2) with (x-6, y-(-2)) equals 0. Use the derivative rule for subtraction to rewrite \u2207(x^3 - 4x^2 + 3x + y^2 - y - c) as \u2207(x^3 - 4x^2 + 3x + y^2 - y) - \u2207(c). State and prove a hypothesis splitting the gradient of (x^3 - 4x^2 + 3x + y^2 - y) as the sum of \u2207(x^3 - 4x^2 + 3x) and \u2207(y^2 - y), provided these functions are differentiable at the relevant point. Substitute this split and use linearity to write the expression as \u2207(x^3 - 4x^2 + 3x) + \u2207(y^2 - y) - \u2207(c). Prove that \u2207(x^3 - 4x^2 + 3x) at (6, -2) dotted with (x-6, y-(-2)) is (x-6) * 63. Show the gradient in the x-direction via function composition and single-variable differentiation. Take appropriate derivatives to compute this explicitly. Use properties of the linear map, plug in the values, and simplify to get the stated result. Justify differentiability of x^3 - 4x^2 + 3x at the point. Show that \u2207(y^2 - y) at (6, -2) dotted with (x-6, y-(-2)) is (y-(-2)) * (-5). Show the gradient in the y-direction via function composition and single-variable differentiation. Take appropriate derivatives to compute this explicitly. Use properties of the linear map, plug in the values, and simplify. Justify differentiability of y^2 - y at the point. Show that the gradient of the constant c is always zero and its dot product term vanishes. Substitute all previous results back into the main hypothesis to obtain the explicit tangent equation. Prove differentiability at each step for all required functions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 4 + p.1 ^ 3 + 4 * p.1 ^ 2 + 2 * p.1 + 2 * p.2 ^ 3 - 3 * p.2 ^ 2 - c) ((2:\u211d), (-3:\u211d)) (x-2, y-(-3)) = 0) \u2192 ((x-2) * (190) + (y-(-3)) * (72) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 + 4 * p.1 ^ 2 + 2 * p.1) ((2:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3 - 3 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 4 + p.1 ^ 3 + 4 * p.1 ^ 2 + 2 * p.1 + 2 * p.2 ^ 3 - 3 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 + 4 * p.1 ^ 2 + 2 * p.1) ((2:\u211d), (-3:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 3 - 3 * p.2 ^ 2) ((2:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 + 4 * p.1 ^ 2 + 2 * p.1) ((2:\u211d), (-3:\u211d))) (x - 2, y - (-3)) = (x-2) * (190)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 4 + p.1 ^ 3 + 4 * p.1 ^ 2 + 2 * p.1) = (fun x => 5 * x ^ 4 + x ^ 3 + 4 * x ^ 2 + 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3 - 3 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))) (x - 2, y - (-3)) = (y-(-3)) * (72)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3 - 3 * p.2 ^ 2) = (fun x => 2 * x ^ 3 - 3 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (-3:\u211d)) (x - 2, y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve f(x, y) = 5 * x^4 + x^3 + 4 * x^2 + 2 * x + 2 * y^3 - 3 * y^2 - c = 0 at the point (2, -3) is (x-2) * 190 + (y-(-3)) * 72 = 0. The idea is to compute the gradient (\u2207) of the function at the point (2, -3), take its dot product with the vector (x-2, y-(-3)), and set it equal to 0 to recover the tangent line equation. Introduce the hypothesis, which asserts the dot product of the gradient with the shifted vector (x-2, y-(-3)) is 0. Apply the derivative rule of subtraction to split \u2207(f) = \u2207(g) - \u2207(c), where g is the sum of all terms except the constant c. Define a hypothesis that splits \u2207(g) = \u2207(h\u2081) + \u2207(h\u2082), where h\u2081 is the sum of terms involving only x (5 * x^4 + x^3 + 4 * x^2 + 2 * x), and h\u2082 is the sum of terms involving only y (2 * y^3 - 3 * y^2). Assume these subfunctions are differentiable at the point. Use this splitting as well as properties of linear maps to express the gradient as a sum of two gradients minus the constant part. Show that \u2207(h\u2081) evaluated at (2, -3) and applied to (x-2, y-(-3)) equals (x-2) * 190. Use composition and derivative rules to reduce the gradient with respect to the first variable to a regular single-variable derivative of 5 * x^4 + x^3 + 4 * x^2 + 2 * x at x = 2. Compute this derivative at x = 2 and check differentiability. Apply linear map simplifications and algebraic manipulations to show the relation. Show that \u2207(h\u2082) evaluated at (2, -3) and applied to (x-2, y-(-3)) equals (y-(-3)) * 72. Similarly, reduce to the derivative of 2 * y^3 - 3 * y^2 with respect to y at y = -3. Compute this derivative and check differentiability. Use properties of linear maps and algebra to show the result. Show that the gradient of the constant c evaluated at any vector is 0. Substitute all these results back into the hypothesis, and simplify the equation using algebraic manipulations. Justify all differentiability assumptions needed for the above calculations for h\u2081, h\u2082, the full function, and the constant."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 4 - 3 * p.1 ^ 3 - 2 * p.1 - 3 * p.2 ^ 3 - c) ((-4:\u211d), (0:\u211d)) (x-(-4), y-0) = 0) \u2192 ((x-(-4)) * (-914) - (y-0) * (0) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 4 - 3 * p.1 ^ 3 - 2 * p.1) ((-4:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3) ((-4:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 4 - 3 * p.1 ^ 3 - 2 * p.1 - 3 * p.2 ^ 3) ((-4:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 4 - 3 * p.1 ^ 3 - 2 * p.1) ((-4:\u211d), (0:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 3) ((-4:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 4 - 3 * p.1 ^ 3 - 2 * p.1) ((-4:\u211d), (0:\u211d))) (x - (-4), y - 0) = (x-(-4)) * (-914)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 4 - 3 * p.1 ^ 3 - 2 * p.1) = (fun x => 3 * x ^ 4 - 3 * x ^ 3 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3) ((-4:\u211d), (0:\u211d))) (x - (-4), y - 0) = (y-0) * (0)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3) = (fun x => 3 * x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (0:\u211d)) (x - (-4), y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^4 - 3 * x^3 - 2 * x - 3 * y^3 - c = 0 at the point (-4, 0) is (x - (-4)) * (-914) - (y-0) * 0 = 0. The idea is to compute the gradient (denoted by \u2207) of the function f(x, y) = 3 * x^4 - 3 * x^3 - 2 * x - 3 * y^3 - c at the point (-4, 0), and then take the dot product of this gradient with the shifted positional vector (x - (-4), y - 0). Setting this equal to 0 yields the equation of the tangent, which must be shown to be equivalent to (x - (-4)) * (-914) - (y-0) * 0 = 0.  Introduce the hypothesis, representing the dot product of the gradient at the point with (x - (-4), y - 0) being equal to 0. Use the rule for differentiating a subtraction to rewrite the gradient as: \u2207(3 * x^4 - 3 * x^3 - 2 * x - 3 * y^3 - c) = \u2207(3 * x^4 - 3 * x^3 - 2 * x - 3 * y^3) - \u2207(c). Define a hypothesis that splits the gradient of 3 * x^4 - 3 * x^3 - 2 * x - 3 * y^3 into a difference between functions of x and of y. Assume differentiability for both components. Use the previous splitting and properties of linear maps to expand the gradient expression into: \u2207(3 * x^4 - 3 * x^3 - 2 * x) - \u2207(3 * y^3) - \u2207(c). Compute the directional derivative for the x-component: Use composition and variable selection rules to reduce to a one-variable function. Differentiate with respect to x using the product, sum, and chain rules of calculus. Apply linear map rules and substitute the value at the point (-4, 0), showing that it yields (x - (-4)) * (-914). Justify the differentiability of 3 * x^4 - 3 * x^3 - 2 * x. Compute the directional derivative for the y-component: Similarly, reduce to a one-variable function in y. Differentiate 3 * y^3 with respect to y. Substitute the point (0 for y) and show that this term gives (y-0) * 0. Justify the differentiability of 3 * y^3. Show that the gradient of the constant c at this point applied to (x-(-4), y-0) yields 0. Substitute the previous findings into the hypothesis, and simplify the resulting linear equation. Prove differentiability for all function components considered, including each term and the full expression."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 - 2 * p.1 ^ 2 - 4 * p.1 - 2 * p.2 ^ 4 - 5 * p.2 ^ 3 + p.2 ^ 2 - 4 * p.2 - c) ((-6:\u211d), (0:\u211d)) (x-(-6), y-0) = 0) \u2192 ((x-(-6)) * (236) - (y-0) * (4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3 - 2 * p.1 ^ 2 - 4 * p.1) ((-6:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) ((-6:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 - 2 * p.1 ^ 2 - 4 * p.1 - 2 * p.2 ^ 4 - 5 * p.2 ^ 3 + p.2 ^ 2 - 4 * p.2) ((-6:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3 - 2 * p.1 ^ 2 - 4 * p.1) ((-6:\u211d), (0:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) ((-6:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3 - 2 * p.1 ^ 2 - 4 * p.1) ((-6:\u211d), (0:\u211d))) (x - (-6), y - 0) = (x-(-6)) * (236)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3 - 2 * p.1 ^ 2 - 4 * p.1) = (fun x => 2 * x ^ 3 - 2 * x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) ((-6:\u211d), (0:\u211d))) (x - (-6), y - 0) = (y-0) * (4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 4 + 5 * p.2 ^ 3 - p.2 ^ 2 + 4 * p.2) = (fun x => 2 * x ^ 4 + 5 * x ^ 3 - x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (0:\u211d)) (x - (-6), y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x\u00b3 - 2x\u00b2 - 4x - 2y\u2074 - 5y\u00b3 + y\u00b2 - 4y - c = 0 at the point (-6, 0) is (x-(-6)) * 236 - (y-0) * 4 = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 2x\u00b3 - 2x\u00b2 - 4x - 2y\u2074 - 5y\u00b3 + y\u00b2 - 4y - c at the point (-6,0), then take the dot product of this gradient with the vector (x-(-6), y-0). Setting that result equal to 0, we show that this yields the desired tangent equation. Introduce the hypothesis: the dot product of the gradient at the base point with the vector (x-(-6), y-0) is 0. Apply the derivative rule for subtraction to separate the gradient of the sum into \u2207(remaining expression) - \u2207(c). Define a hypothesis to split the gradient of the remaining expression into two parts: \u2207(2x\u00b3 - 2x\u00b2 - 4x - 2y\u2074 - 5y\u00b3 + y\u00b2 - 4y) = \u2207(2x\u00b3 - 2x\u00b2 - 4x) - \u2207(2y\u2074 + 5y\u00b3 - y\u00b2 + 4y), provided the inner parts are differentiable. Use the above to further split, using properties of linear maps, so the overall gradient is written as the difference of two gradients, minus \u2207(c). Show that \u2207(2x\u00b3 - 2x\u00b2 - 4x) at (-6,0) dotted with (x-(-6), y-0) equals (x-(-6)) * 236. Write the expression as a composition, so you can use the chain rule. Differentiate the function 2x\u00b3 - 2x\u00b2 - 4x with respect to x. Use algebra and properties of linear maps to conclude the claimed value. Justify differentiability at the point. Show that \u2207(2y\u2074 + 5y\u00b3 - y\u00b2 + 4y) at (-6,0) dotted with (x-(-6), y-0) equals (y-0) * 4. Write as a composition and use rules for the partial y derivative. Differentiate the function 2y\u2074 + 5y\u00b3 - y\u00b2 + 4y with respect to y. Simplify to get the claimed value. Justify differentiability. Show the gradient of the constant function c dotted with (x-(-6), y-0) is 0. Substitute the calculations of steps 5-7 back into the main hypothesis and simplify. Justify differentiability for all involved functions to ensure the correctness of all previous steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 - p.1 + 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - 2 * p.2 - c) ((-1:\u211d), (-1:\u211d)) (x-(-1), y-(-1)) = 0) \u2192 ((x-(-1)) * (-3) + (y-(-1)) * (-33) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 - p.1) ((-1:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - 2 * p.2) ((-1:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 - p.1 + 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - 2 * p.2) ((-1:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 - p.1) ((-1:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - 2 * p.2) ((-1:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 - p.1) ((-1:\u211d), (-1:\u211d))) (x - (-1), y - (-1)) = (x-(-1)) * (-3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 - p.1) = (fun x => x ^ 2 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - 2 * p.2) ((-1:\u211d), (-1:\u211d))) (x - (-1), y - (-1)) = (y-(-1)) * (-33)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - 2 * p.2) = (fun x => 4 * x ^ 4 - 5 * x ^ 3 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (-1:\u211d)) (x - (-1), y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 - x + 4y^4 - 5y^3 - 2y - c = 0 at the point (-1, -1) is (x-(-1)) * (-3) + (y-(-1)) * (-33) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = x^2 - x + 4y^4 - 5y^3 - 2y - c at the point (-1, -1), then take the dot product with the shifted position vector (x-(-1), y-(-1)), and set this equal to zero to get the tangent's equation, then show it matches the required form. Introduce the hypothesis: the directional derivative (dot product of the gradient at the point with the shifted position vector) equals 0. Apply the derivative rule for subtraction to split \u2207(x^2 - x + 4y^4 - 5y^3 - 2y - c) = \u2207(x^2 - x + 4y^4 - 5y^3 - 2y) - \u2207(c). Introduce a hypothesis that splits the gradient further: \u2207(x^2 - x + 4y^4 - 5y^3 - 2y) = \u2207(x^2 - x) + \u2207(4y^4 - 5y^3 - 2y). Assume differentiability for the two subfunctions. Substitute this split, using properties of linear maps, so that the entire gradient becomes \u2207(x^2 - x) + \u2207(4y^4 - 5y^3 - 2y) - \u2207(c). Show that \u2207(x^2 - x) at (-1, -1) and its dot product with (x-(-1), y-(-1)) yields (x-(-1)) * (-3). Use the fact that this function depends only on x and compute the partial derivative with respect to x. Evaluate the derivative at x = -1. Show that the dot product with the shifted vector in the x-direction leads to the claimed expression. Verify differentiability of x^2 - x at (-1, -1). Show that \u2207(4y^4 - 5y^3 - 2y) at (-1, -1) and its dot product with (x-(-1), y-(-1)) yields (y-(-1)) * (-33). Use the fact that this function depends only on y and compute the partial derivative with respect to y. Evaluate at y = -1. Show that the dot product with the shifted vector in the y-direction leads to the claimed value. Prove differentiability of 4y^4 - 5y^3 - 2y at (-1, -1). Show that the directional derivative for \u2207(c), as a constant, is zero when evaluating at any direction. Substitute all these computed results back into the original equation to simplify the expression. Confirm differentiability assumptions: 9.1) For \u2207(x^2 - x) 9.2) For \u2207(4y^4 - 5y^3 - 2y) 9.3) For their sum and the subtraction of the constant term."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 - 5 * p.1 + 4 * p.2 ^ 3 - 4 * p.2 - c) ((-3:\u211d), (3:\u211d)) (x-(-3), y-3) = 0) \u2192 ((x-(-3)) * (-35) + (y-3) * (104) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 - 5 * p.1) ((-3:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2) ((-3:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 - 5 * p.1 + 4 * p.2 ^ 3 - 4 * p.2) ((-3:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 - 5 * p.1) ((-3:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2) ((-3:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 - 5 * p.1) ((-3:\u211d), (3:\u211d))) (x - (-3), y - 3) = (x-(-3)) * (-35)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 - 5 * p.1) = (fun x => 5 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2) ((-3:\u211d), (3:\u211d))) (x - (-3), y - 3) = (y-3) * (104)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 - 4 * p.2) = (fun x => 4 * x ^ 3 - 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (3:\u211d)) (x - (-3), y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 - 5 * x + 4 * y^3 - 4 * y - c = 0 at the point (-3,3) is (x-(-3)) * (-35) + (y-3) * (104) = 0. The idea is to calculate the gradient (\u2207) of f(x, y) = 5 * x^2 - 5 * x + 4 * y^3 - 4 * y - c at the point (-3, 3), then take the dot product with the shifted position vector (x-(-3), y-3). Setting this equal to 0 gives the tangent equation, which we need to show matches (x-(-3)) * (-35) + (y-3) * (104) = 0.  Introduce the hypothesis that the dot product of the gradient at (-3,3) with the shifted positional vector is zero. Apply the derivative rule for subtraction to split \u2207(5 * x^2 - 5 * x + 4 * y^3 - 4 * y - c) into \u2207(5 * x^2 - 5 * x + 4 * y^3 - 4 * y) - \u2207(c). Define a hypothesis to split the sum \u2207(5 * x^2 - 5 * x + 4 * y^3 - 4 * y) = \u2207(5 * x^2 - 5 * x) + \u2207(4 * y^3 - 4 * y), given differentiability at those points. Substitute this split into the main equation and apply the properties of the involved continuous linear maps to separate the contributions. Show that \u2207(5 * x^2 - 5 * x) at (-3,3), applied to (x-(-3), y-3), simplifies to (x-(-3)) * (-35). Use composition and differentiation rules to focus on the x variable. Explicitly compute the derivative of 5 * x^2 - 5 * x at x = -3. Use linear map properties and algebraic simplification to identify the final expression. Justify differentiability of 5 * x^2 - 5 * x as needed. Show that \u2207(4 * y^3 - 4 * y) at (-3,3), applied to (x-(-3), y-3), results in (y-3) * (104). Use composition and differentiation rules to focus on the y variable. Explicitly compute the derivative of 4 * y^3 - 4 * y at y = 3. Use linear map properties and algebraic simplification to identify the expression. Justify differentiability of 4 * y^3 - 4 * y as needed. Show that the derivative of the constant term c is zero in this context. Substitute the results of the previous steps into the original hypothesis and simplify to arrive at the desired tangent equation. Ensure all differentiability conditions assumed earlier are verified in your reasoning."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 3 - 5 * p.1 ^ 2 - 2 * p.2 ^ 2 - c) ((2:\u211d), (-3:\u211d)) (x-2, y-(-3)) = 0) \u2192 ((x-2) * (16) - (y-(-3)) * (-12) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 3 - 5 * p.1 ^ 2) ((2:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 3 - 5 * p.1 ^ 2 - 2 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 3 - 5 * p.1 ^ 2) ((2:\u211d), (-3:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 2) ((2:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 3 - 5 * p.1 ^ 2) ((2:\u211d), (-3:\u211d))) (x - 2, y - (-3)) = (x-2) * (16)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 3 - 5 * p.1 ^ 2) = (fun x => 3 * x ^ 3 - 5 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))) (x - 2, y - (-3)) = (y-(-3)) * (-12)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 2) = (fun x => 2 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (-3:\u211d)) (x - 2, y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^3 - 5 * x^2 - 2 * y^2 - c = 0 at the point (2, -3) is (x-2) * (16) - (y-(-3)) * (-12) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 3 * x^3 - 5 * x^2 - 2 * y^2 - c at the point (2, -3), then take its dot product with the shifted position vector (x-2, y-(-3)). Setting this equal to zero gives the tangent equation, and we want to show it results in the given expression. Introduce the hypothesis, which states that the dot product of the gradient at the point (2, -3) with the shifted vector (x-2, y-(-3)) equals 0. Apply the derivative rule for subtraction to split the gradient: \u2207(3 * x^3 - 5 * x^2 - 2 * y^2 - c) = \u2207(3 * x^3 - 5 * x^2 - 2 * y^2) - \u2207(c). Define an intermediate result that splits further: \u2207(3 * x^3 - 5 * x^2 - 2 * y^2) = \u2207(3 * x^3 - 5 * x^2) - \u2207(2 * y^2). Assume differentiability at (3 * x^3 - 5 * x^2) and (2 * y^2). Use linearity and rules of linear maps to write \u2207(3 * x^3 - 5 * x^2 - 2 * y^2 - c) = \u2207(3 * x^3 - 5 * x^2) - \u2207(2 * y^2) - \u2207(c). Show that \u2207(3 * x^3 - 5 * x^2) at (2, -3) dot (x-2, y-(-3)) = (x-2) * 16. Use composition and differentiation rules to rewrite the partial derivative with respect to x. Compute the relevant derivatives at x = 2. Use the linear map structure to evaluate this directional derivative. Argue differentiability of 3 * x^3 - 5 * x^2 at x = 2. Show that \u2207(2 * y^2) at (2, -3) dot (x-2, y-(-3)) = (y-(-3)) * (-12). Use composition and differentiation rules for the partial derivative with respect to y. Compute the relevant derivatives at y = -3. Use the linear map structure to evaluate this directional derivative. Argue differentiability of 2 * y^2 at y = -3. Show that \u2207(c) at (2, -3) dot (x-2, y-(-3)) = 0, since c is constant. Substitute these equalities into the hypothesis, simplifying the gradient expression and thus the tangent equation. Give justifications for differentiability of each component function and of the sum/difference as required."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 + 2 * p.1 ^ 3 - 3 * p.1 ^ 2 + 2 * p.1 - 3 * p.2 ^ 3 - 4 * p.2 - c) ((-1:\u211d), (3:\u211d)) (x-(-1), y-3) = 0) \u2192 ((x-(-1)) * (10) - (y-3) * (85) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 3 - 3 * p.1 ^ 2 + 2 * p.1) ((-1:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3 + 4 * p.2) ((-1:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 + 2 * p.1 ^ 3 - 3 * p.1 ^ 2 + 2 * p.1 - 3 * p.2 ^ 3 - 4 * p.2) ((-1:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 3 - 3 * p.1 ^ 2 + 2 * p.1) ((-1:\u211d), (3:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 3 + 4 * p.2) ((-1:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 3 - 3 * p.1 ^ 2 + 2 * p.1) ((-1:\u211d), (3:\u211d))) (x - (-1), y - 3) = (x-(-1)) * (10)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 + 2 * p.1 ^ 3 - 3 * p.1 ^ 2 + 2 * p.1) = (fun x => x ^ 4 + 2 * x ^ 3 - 3 * x ^ 2 + 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3 + 4 * p.2) ((-1:\u211d), (3:\u211d))) (x - (-1), y - 3) = (y-3) * (85)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3 + 4 * p.2) = (fun x => 3 * x ^ 3 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (3:\u211d)) (x - (-1), y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 + 2x^3 - 3x^2 + 2x - 3y^3 - 4y - c = 0 at the point (-1,3) is (x-(-1)) * (10) - (y-3) * (85) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = x^4 + 2x^3 - 3x^2 + 2x - 3y^3 - 4y - c at the point (-1, 3), then take the dot product of it with (x-(-1), y-3). Setting this equal to 0 gives the tangent equation, which we must show is equivalent to the given formula.  Introduce the hypothesis: Given that the dot product of the gradient at ((-1, 3)) with the vector (x-(-1), y-3) is 0. Apply the rule for the derivative of a difference to split \u2207(x^4 + 2x^3 - 3x^2 + 2x - 3y^3 - 4y - c) as \u2207(x^4 + 2x^3 - 3x^2 + 2x - 3y^3 - 4y) - \u2207(c). Define a hypothesis splitting the gradient further as \u2207(x^4 + 2x^3 - 3x^2 + 2x - 3y^3 - 4y) = \u2207(x^4 + 2x^3 - 3x^2 + 2x) - \u2207(3y^3 + 4y). Assume differentiability at each step. Use the linearity properties of the gradient and linear map rules to split the computation of the dot product. Show that \u2207(x^4 + 2x^3 - 3x^2 + 2x) at (-1, 3) acting on (x-(-1), y-3) reduces to (x-(-1)) * (10). Express the function as a composition with the first component for differentiation. Apply the rules for the derivatives of sums, powers, and products to compute the partial derivative with respect to x. Substitute numerically at the given point, and simplify so only (x-(-1)) remains in the final expression. Ensure each function in the sum is differentiable at the appropriate point. Show that \u2207(3y^3 + 4y) at (-1, 3) acting on (x-(-1), y-3) reduces to (y-3) * (85). Set up the appropriate composition for differentiation in y. Take the partial derivatives using the sum and product/power rules, evaluate at y = 3, and simplify to the desired form. Verify differentiability at each step for these functions. Show that the gradient of the constant term c at any point is 0 when acting on any vector (i.e., this term vanishes). Substitute the results from steps 5\u20137 into the original hypothesis, and simplify to obtain the form (x-(-1)) * (10) - (y-3) * (85) = 0. Check and supply differentiability requirements for all functions at the required points."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 - 3 * p.1 ^ 2 - 5 * p.1 + p.2 ^ 2 - c) ((-6:\u211d), (-4:\u211d)) (x-(-6), y-(-4)) = 0) \u2192 ((x-(-6)) * (463) + (y-(-4)) * (-8) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3 - 3 * p.1 ^ 2 - 5 * p.1) ((-6:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2) ((-6:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 - 3 * p.1 ^ 2 - 5 * p.1 + p.2 ^ 2) ((-6:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3 - 3 * p.1 ^ 2 - 5 * p.1) ((-6:\u211d), (-4:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2) ((-6:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3 - 3 * p.1 ^ 2 - 5 * p.1) ((-6:\u211d), (-4:\u211d))) (x - (-6), y - (-4)) = (x-(-6)) * (463)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3 - 3 * p.1 ^ 2 - 5 * p.1) = (fun x => 4 * x ^ 3 - 3 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2) ((-6:\u211d), (-4:\u211d))) (x - (-6), y - (-4)) = (y-(-4)) * (-8)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2) = (fun x => x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (-4:\u211d)) (x - (-6), y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact differentiableAt_snd.pow _\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 - 3 * x^2 - 5 * x + y^2 - c = 0 at the point (-6, -4) is (x-(-6)) * 463 + (y-(-4)) * (-8) = 0. The strategy is to compute the gradient (\u2207) of f(x, y) = 4 * x^3 - 3 * x^2 - 5 * x + y^2 - c at the point (-6, -4), then form the dot product with the vector (x-(-6), y-(-4)), set this equal to zero, and thereby obtain the equation of the tangent. We show this yields the desired form. Introduce the hypothesis: the dot product of the gradient at the point with (x-(-6), y-(-4)) is 0. Use the derivative rule for subtraction to split \u2207(4 * x^3 - 3 * x^2 - 5 * x + y^2 - c) as \u2207(4 * x^3 - 3 * x^2 - 5 * x + y^2) - \u2207(c). Define a hypothesis to split \u2207(4 * x^3 - 3 * x^2 - 5 * x + y^2) into \u2207(4 * x^3 - 3 * x^2 - 5 * x) + \u2207(y^2), assuming differentiability at the given point. Substitute this split into the hypothesis and use linearity to write the overall expression as the sum of gradients minus the constant term\u2019s gradient. Show that \u2207(4 * x^3 - 3 * x^2 - 5 * x) at (-6, -4) contracted with (x-(-6), y-(-4)) equals (x-(-6)) * 463: Use composition and single-variable calculus: the gradient with respect to x is just the x-derivative, the y-part vanishes. Compute the derivative at -6: 12 * x^2 - 6 * x - 5 at x = -6. Use linearity and algebraic simplification to conclude the result. Justify differentiability at the point for this function. Show that \u2207(y^2) at (-6, -4) contracted with (x-(-6), y-(-4)) equals (y-(-4)) * (-8): The x-part vanishes, the y-derivative is 2 * y, evaluated at y = -4. Simplify the contraction using linear maps. Justify differentiability at the point for this function. Show that the gradient of the constant term, \u2207(c), always gives zero when contracted with any vector. Substitute all computed values back, obtaining the equation (x-(-6)) * 463 + (y-(-4)) * (-8) = 0. Conclude by giving differentiability justifications at the relevant points for each sub-function involved."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 + p.1 ^ 2 - 3 * p.2 ^ 3 - 4 * p.2 ^ 2 + 4 * p.2 - c) ((5:\u211d), (3:\u211d)) (x-5, y-3) = 0) \u2192 ((x-5) * (385) - (y-3) * (101) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3 + p.1 ^ 2) ((5:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3 + 4 * p.2 ^ 2 - 4 * p.2) ((5:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 + p.1 ^ 2 - 3 * p.2 ^ 3 - 4 * p.2 ^ 2 + 4 * p.2) ((5:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3 + p.1 ^ 2) ((5:\u211d), (3:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 3 + 4 * p.2 ^ 2 - 4 * p.2) ((5:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3 + p.1 ^ 2) ((5:\u211d), (3:\u211d))) (x - 5, y - 3) = (x-5) * (385)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3 + p.1 ^ 2) = (fun x => 5 * x ^ 3 + x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3 + 4 * p.2 ^ 2 - 4 * p.2) ((5:\u211d), (3:\u211d))) (x - 5, y - 3) = (y-3) * (101)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3 + 4 * p.2 ^ 2 - 4 * p.2) = (fun x => 3 * x ^ 3 + 4 * x ^ 2 - 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (3:\u211d)) (x - 5, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^3 + x^2 - 3 * y^3 - 4 * y^2 + 4 * y - c = 0 at the point (5,3) is (x-5) * 385 - (y-3) * 101 = 0. The general strategy is to compute the gradient (\u2207) of f(x, y) = 5 * x^3 + x^2 - 3 * y^3 - 4 * y^2 + 4 * y - c at (5,3), then to take its dot product with (x-5, y-3), set that equal to 0 (the tangent equation), and show that this yields (x-5) * 385 - (y-3) * 101 = 0. Introduce the original hypothesis, which is that the directional derivative of f at (5,3) in the direction (x-5, y-3) is 0. Apply the derivative rule for subtraction, splitting \u2207(5*x^3 + x^2 - 3*y^3 - 4*y^2 + 4*y - c) as \u2207(5*x^3 + x^2 - 3*y^3 - 4*y^2 + 4*y) - \u2207c. Define a hypothesis splitting the gradient: \u2207(5*x^3 + x^2 - 3*y^3 - 4*y^2 + 4*y) = \u2207(5*x^3 + x^2) - \u2207(3*y^3 + 4*y^2 - 4*y). Assume differentiability for these pieces. Rewrite the previous gradient split using the linearity of the derivative and apply the linear map rules, giving an expression for the total derivative in terms of pieces in x and in y. Show that evaluating \u2207(5*x^3 + x^2) at (5,3), on the vector (x-5, y-3), yields (x-5) * 385: Write 5*x^3 + x^2 as a function of x only, via a composition with the projection onto the first coordinate. Use the chain rule and rules for monomials to compute the partial derivative with respect to x. Compute this gradient at x=5 and simplify. Confirm differentiability at the required point. Show that evaluating \u2207(3*y^3 + 4*y^2 - 4*y) at (5,3), on (x-5, y-3), is (y-3) * 101: Write 3*y^3 + 4*y^2 - 4*y as a function of y only, composed with the projection onto the second coordinate. Use chain rule and product rule to differentiate with respect to y. Evaluate the gradient at y=3 and simplify. Check differentiability. Show that the gradient of the constant term c is zero on any vector. Substitute back the results from 5), 6), 7) into the main equation, and simplify to obtain the final tangent line equation. Justify differentiability of \u2207(5*x^3 + x^2), \u2207(3*y^3 + 4*y^2 - 4*y), their sum/difference, and the constant function, at (5,3)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 4 - 5 * p.1 - 5 * p.2 ^ 2 - 5 * p.2 - c) ((1:\u211d), (2:\u211d)) (x-1, y-2) = 0) \u2192 ((x-1) * (3) - (y-2) * (25) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 4 - 5 * p.1) ((1:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2 + 5 * p.2) ((1:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 4 - 5 * p.1 - 5 * p.2 ^ 2 - 5 * p.2) ((1:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 4 - 5 * p.1) ((1:\u211d), (2:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 2 + 5 * p.2) ((1:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 4 - 5 * p.1) ((1:\u211d), (2:\u211d))) (x - 1, y - 2) = (x-1) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 4 - 5 * p.1) = (fun x => 2 * x ^ 4 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2 + 5 * p.2) ((1:\u211d), (2:\u211d))) (x - 1, y - 2) = (y-2) * (25)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2 + 5 * p.2) = (fun x => 5 * x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (2:\u211d)) (x - 1, y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^4 - 5 * x - 5 * y^2 - 5 * y - c = 0 at the point (1,2) is (x-1) * (3) - (y-2) * (25) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 2 * x^4 - 5 * x - 5 * y^2 - 5 * y - c at the point (1,2), then take its dot product with the shifted positional vector (x-1, y-2), and set this equal to zero to get the equation of the tangent, which should simplify to the target equation. Introduce the hypothesis that the dot product of the gradient with the shifted vector is equal to 0. Use the property of the derivative of sums and differences to split \u2207(2 * x^4 - 5 * x - 5 * y^2 - 5 * y - c) as \u2207(2 * x^4 - 5 * x - 5 * y^2 - 5 * y) - \u2207(c). Define a hypothesis that shows \u2207(2 * x^4 - 5 * x - 5 * y^2 - 5 * y) = \u2207(2 * x^4 - 5 * x) - \u2207(5 * y^2 + 5 * y). Assume differentiability at the relevant points. Use linear map rules to expand the gradient and apply the splitting above: \u2207(2 * x^4 - 5 * x - 5 * y^2 - 5 * y - c) = \u2207(2 * x^4 - 5 * x) - \u2207(5 * y^2 + 5 * y) - \u2207(c). Show that \u2207(2 * x^4 - 5 * x) at (1,2) dot (x-1, y-2) equals (x-1) * (3) Write the function as a composition so the gradient with respect to the first variable (x) reduces to an ordinary derivative. Compute the derivative with respect to x, plug in the value at x = 1. Use linear map evaluation on the direction vector to identify the coefficient. Justify differentiability of the function in x. Show that \u2207(5 * y^2 + 5 * y) at (1,2) dot (x-1, y-2) equals (y-2) * (25) Similarly, write as a composition with respect to the second variable. Compute the derivative with respect to y, evaluate at y = 2. Use linear map evaluation on the direction vector to get the result. Justify differentiability of the function in y. Show that \u2207(c) at (1,2) dot (x-1, y-2) = 0, since c is a constant. Substitute results from prior steps into the equation from the hypothesis, simplifying the expression. Prove the differentiability required for all split steps and justifications for calculations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 - 3 * p.1 + p.2 ^ 3 + p.2 ^ 2 - p.2 - c) ((-6:\u211d), (2:\u211d)) (x-(-6), y-2) = 0) \u2192 ((x-(-6)) * (-27) + (y-2) * (15) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2 - 3 * p.1) ((-6:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 + p.2 ^ 2 - p.2) ((-6:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 - 3 * p.1 + p.2 ^ 3 + p.2 ^ 2 - p.2) ((-6:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2 - 3 * p.1) ((-6:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 3 + p.2 ^ 2 - p.2) ((-6:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2 - 3 * p.1) ((-6:\u211d), (2:\u211d))) (x - (-6), y - 2) = (x-(-6)) * (-27)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2 - 3 * p.1) = (fun x => 2 * x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 + p.2 ^ 2 - p.2) ((-6:\u211d), (2:\u211d))) (x - (-6), y - 2) = (y-2) * (15)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 + p.2 ^ 2 - p.2) = (fun x => x ^ 3 + x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (2:\u211d)) (x - (-6), y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve 2x\u00b2\u00a0\u2013\u00a03x\u00a0+\u00a0y\u00b3\u00a0+\u00a0y\u00b2\u00a0\u2013\u00a0y\u00a0\u2013\u00a0c\u00a0=\u00a00 at the point (\u20136,\u00a02) is (x\u00a0+\u00a06)(\u201327)\u00a0+\u00a0(y\u00a0\u2013\u00a02)15\u00a0=\u00a00. Our strategy is to compute the gradient (\u2207f) of f(x,\u00a0y)\u00a0=\u00a02x\u00b2\u00a0\u2013\u00a03x\u00a0+\u00a0y\u00b3\u00a0+\u00a0y\u00b2\u00a0\u2013\u00a0y\u00a0\u2013\u00a0c at (\u20136,\u00a02), then take its dot product with (x\u00a0+\u00a06,\u00a0y\u00a0\u2013\u00a02), set it equal to 0, and show it gives the desired equation.  Introduce the hypothesis, which states that the directional derivative (gradient dot the vector (x\u00a0+\u00a06,\u00a0y\u00a0\u2013\u00a02)) of the function at (\u20136,\u00a02) equals 0. Apply the rule for the derivative of a difference to decompose the gradient of (2x\u00b2\u00a0\u2013\u00a03x\u00a0+\u00a0y\u00b3\u00a0+\u00a0y\u00b2\u00a0\u2013\u00a0y\u00a0\u2013\u00a0c) into the sum of the gradient of (2x\u00b2\u00a0\u2013\u00a03x\u00a0+\u00a0y\u00b3\u00a0+\u00a0y\u00b2\u00a0\u2013\u00a0y) and the negative of the gradient of c. Introduce a hypothesis splitting the gradient of (2x\u00b2\u00a0\u2013\u00a03x\u00a0+\u00a0y\u00b3\u00a0+\u00a0y\u00b2\u00a0\u2013\u00a0y) into the sum of two gradients: one for 2x\u00b2\u00a0\u2013\u00a03x and another for y\u00b3\u00a0+\u00a0y\u00b2\u00a0\u2013\u00a0y, provided each piece is differentiable at (\u20136,\u00a02). Use linearity properties to combine the gradients as needed, applying the above decomposition to the initial hypothesis. Show that the gradient of 2x\u00b2\u00a0\u2013\u00a03x at (\u20136,\u00a02), when dotted with (x\u00a0+\u00a06,\u00a0y\u00a0\u2013\u00a02), gives (x\u00a0+\u00a06)(\u201327). Use the composition rule to reduce the multivariate gradient to a univariate derivative. Compute the derivatives with respect to x. Apply simplification and rules for linear maps to finish the calculation. Argue differentiability of 2x\u00b2\u00a0\u2013\u00a03x at the relevant point. Show that the gradient of y\u00b3\u00a0+\u00a0y\u00b2\u00a0\u2013\u00a0y at (\u20136,\u00a02), when dotted with (x\u00a0+\u00a06,\u00a0y\u00a0\u2013\u00a02), gives (y\u00a0\u2013\u00a02)15. Use the composition rule to reduce the gradient to a univariate derivative. Compute the derivatives with respect to y. Simplify the resulting expression as needed. Argue differentiability of y\u00b3\u00a0+\u00a0y\u00b2\u00a0\u2013\u00a0y at the relevant point. Show that the gradient of c at (\u20136,\u00a02), being a constant, is 0 when applied to any vector. Substitute the results of steps 5, 6, and 7 into the expression derived from the initial hypothesis and simplify. Establish the differentiability of all component functions at the relevant points to justify the use of earlier steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 + 5 * p.2 ^ 2 - p.2 - c) ((1:\u211d), (-2:\u211d)) (x-1, y-(-2)) = 0) \u2192 ((x-1) * (3) + (y-(-2)) * (-21) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1) ((1:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2 - p.2) ((1:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 + 5 * p.2 ^ 2 - p.2) ((1:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1) ((1:\u211d), (-2:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 2 - p.2) ((1:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1) ((1:\u211d), (-2:\u211d))) (x - 1, y - (-2)) = (x-1) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1) = (fun x => 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2 - p.2) ((1:\u211d), (-2:\u211d))) (x - 1, y - (-2)) = (y-(-2)) * (-21)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2 - p.2) = (fun x => 5 * x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (-2:\u211d)) (x - 1, y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x + 5 * y^2 - y - c = 0 at the point (1, -2) is (x-1) * 3 + (y-(-2)) * (-21) = 0. The key idea is to compute the gradient (\u2207) of f(x, y) = 3 * x + 5 * y^2 - y - c at the point (1, -2), then take the dot product of this gradient with the vector (x-1, y-(-2)), and set it equal to zero to obtain the equation of the tangent. We must then show this equation simplifies to the desired explicit form. Introduce the hypothesis: that the dot product of the gradient and the shifted position vector equals zero. Apply the derivative rule for subtraction to split \u2207(3x + 5y^2 - y - c) as \u2207(3x + 5y^2 - y) - \u2207(c). Split \u2207(3x + 5y^2 - y) as \u2207(3x) + \u2207(5y^2 - y): define an intermediate step assuming differentiability of the parts. Use the above splitting and linearity properties to further break down the expression into simpler derivatives. Show that the gradient of 3x at (1, -2), applied to (x-1, y-(-2)), gives (x-1) * 3. Use composition and single variable differentiation rules to extract the x-derivative. Use properties of linear maps to evaluate the result. Establish differentiability of 3x. Show that the gradient of (5y^2 - y) at (1, -2), applied to (x-1, y-(-2)), gives (y-(-2)) * (-21). Use composition and single variable differentiation rules to extract the y-derivative. Perform the derivative evaluation at (1, -2) and apply simplification. Establish differentiability of (5y^2 - y). Show that the gradient of the constant c vanishes when applied to any vector. Substitute these evaluations back into the original equation and simplify, confirming it matches the given tangent line equation. Justify differentiability where required for the function pieces."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 - 2 * p.2 ^ 2 + p.2 - c) ((0:\u211d), (5:\u211d)) (x-0, y-5) = 0) \u2192 ((x-0) * (3) - (y-5) * (19) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1) ((0:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((0:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 - 2 * p.2 ^ 2 + p.2) ((0:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1) ((0:\u211d), (5:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((0:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1) ((0:\u211d), (5:\u211d))) (x - 0, y - 5) = (x-0) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1) = (fun x => 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((0:\u211d), (5:\u211d))) (x - 0, y - 5) = (y-5) * (19)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 2 - p.2) = (fun x => 2 * x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (5:\u211d)) (x - 0, y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x - 2 * y^2 + y - c = 0 at the point (0, 5) is (x-0) * 3 - (y-5) * 19 = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 3 * x - 2 * y^2 + y - c at the point (0, 5), then take its dot product with the shifted vector (x-0, y-5); setting this to 0 gives the tangent line. We need to show this is equivalent to (x-0) * 3 - (y-5) * 19 = 0. Introduce the hypothesis, which states that the dot product of the gradient at the point (0, 5) with the shift vector (x-0, y-5) is zero. Apply the derivative rule for subtraction to break up the gradient: \u2207(3 * x - 2 * y^2 + y - c) = \u2207(3 * x - 2 * y^2 + y) - \u2207(c). Define a splitting hypothesis for the non-constant part of the function, writing \u2207(3 * x - 2 * y^2 + y) as \u2207(3 * x) - \u2207(2 * y^2 - y), assuming differentiability at each function. Use the previous hypothesis and properties of linear maps to write the gradient at (0, 5) in terms of the gradients of the component functions. Show that \u2207(3 * x) at (0, 5) dotted with (x-0, y-5) is (x-0) * 3: Use composition rules to view the function as a function of a single variable composed with the projection to the first coordinate. Take the derivative with respect to x using appropriate differentiation rules. Use properties of linear maps (application and simplification). Prove differentiability of 3 * x. Show that \u2207(2 * y^2 - y) at (0, 5) dotted with (x-0, y-5) is (y-5) * 19: Use composition rules to express this as a function of y composed with the projection to the second coordinate. Take the derivative with respect to y, applying rules for subtraction and the chain rule for powers. Use properties of linear maps and simplifications. Prove differentiability of 2 * y^2 - y. Show that the derivative of the constant function c at (0, 5) applied to (x-0, y-5) is 0. Substitute all results from the above steps into the main equation and simplify to get the result. Confirm differentiability of all component functions and the sum/subtraction as required by the splitting steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 + p.1 ^ 2 + p.1 + p.2 - c) ((2:\u211d), (5:\u211d)) (x-2, y-5) = 0) \u2192 ((x-2) * (53) + (y-5) * (1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3 + p.1 ^ 2 + p.1) ((2:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2) ((2:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 + p.1 ^ 2 + p.1 + p.2) ((2:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3 + p.1 ^ 2 + p.1) ((2:\u211d), (5:\u211d)) +\n      fderiv \u211d (fun p => p.2) ((2:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3 + p.1 ^ 2 + p.1) ((2:\u211d), (5:\u211d))) (x - 2, y - 5) = (x-2) * (53)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3 + p.1 ^ 2 + p.1) = (fun x => 4 * x ^ 3 + x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2) ((2:\u211d), (5:\u211d))) (x - 2, y - 5) = (y-5) * (1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2) = (fun x => x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (5:\u211d)) (x - 2, y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact differentiableAt_snd\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 + x^2 + x + y - c = 0 at the point (2,5) is (x-2) * (53) + (y-5) * (1) = 0. The idea is to compute the gradient (\u2207) of the function f(x,y) = 4 * x^3 + x^2 + x + y - c at (2,5), then take the dot product with the shifted vector (x-2, y-5). Setting this equal to zero gives the tangent equation, which we show matches the required form. Introduce the hypothesis: the directional derivative (gradient dotted with (x-2, y-5)) at (2,5) is 0. Use the rule for the derivative of a subtraction to split \u2207(4 * x^3 + x^2 + x + y - c) = \u2207(4 * x^3 + x^2 + x + y) - \u2207(c). Define a hypothesis that further splits \u2207(4 * x^3 + x^2 + x + y) = \u2207(4 * x^3 + x^2 + x) + \u2207(y), assuming differentiability for both components. Substitute this split and use properties of linear maps to rewrite the overall gradient as \u2207(4 * x^3 + x^2 + x) + \u2207(y) - \u2207(c). Show that \u2207(4 * x^3 + x^2 + x) at (2,5) dotted with (x-2, y-5) yields (x-2) * (53): Identify the function as depending only on the first variable, and compose with the appropriate projection. Use rules for the derivative of sums and powers to compute the derivative with respect to x. Use properties of linear maps for the dot product, simplify, and substitute the point (2,5). Verify differentiability where necessary. Show that \u2207(y) at (2,5) dotted with (x-2, y-5) yields (y-5) * (1): Recognize the function as a composition with the second projection. Compute the derivative with respect to y. Use properties of linear maps, simplify, and evaluate at (2,5). Verify differentiability. Show that \u2207(c) is just the constant function and its directional derivative is zero. Substitute the evaluated directional derivatives into the original equation and simplify. Prove differentiability for all the component functions and their sums as required by prior steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 4 + p.1 ^ 2 + p.1 - p.2 ^ 4 - 2 * p.2 ^ 3 - 3 * p.2 ^ 2 + p.2 - c) ((-2:\u211d), (2:\u211d)) (x-(-2), y-2) = 0) \u2192 ((x-(-2)) * (-99) - (y-2) * (67) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 4 + p.1 ^ 2 + p.1) ((-2:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 3 + 3 * p.2 ^ 2 - p.2) ((-2:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 4 + p.1 ^ 2 + p.1 - p.2 ^ 4 - 2 * p.2 ^ 3 - 3 * p.2 ^ 2 + p.2) ((-2:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 4 + p.1 ^ 2 + p.1) ((-2:\u211d), (2:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 3 + 3 * p.2 ^ 2 - p.2) ((-2:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 4 + p.1 ^ 2 + p.1) ((-2:\u211d), (2:\u211d))) (x - (-2), y - 2) = (x-(-2)) * (-99)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 4 + p.1 ^ 2 + p.1) = (fun x => 3 * x ^ 4 + x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 3 + 3 * p.2 ^ 2 - p.2) ((-2:\u211d), (2:\u211d))) (x - (-2), y - 2) = (y-2) * (67)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 2 * p.2 ^ 3 + 3 * p.2 ^ 2 - p.2) = (fun x => x ^ 4 + 2 * x ^ 3 + 3 * x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (2:\u211d)) (x - (-2), y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^4 + x^2 + x - y^4 - 2*y^3 - 3*y^2 + y - c = 0 at the point (-2,2) is (x-(-2)) * (-99) - (y-2) * (67) = 0. The approach is to compute the gradient (\u2207) of the function f(x,y) = 3 * x^4 + x^2 + x - y^4 - 2*y^3 - 3*y^2 + y - c at the point (-2,2), take the dot product with the shifted positional vector (x-(-2), y-2), and set it to zero. The claim is then to show this equation is (x-(-2)) * (-99) - (y-2) * (67) = 0.  Introduce the given hypothesis, which equates the dot product of the gradient at the point with the shifted vector to zero. Use the derivative rule of subtraction to split the gradient: \u2207(3 * x^4 + x^2 + x - y^4 - 2*y^3 - 3*y^2 + y - c) = \u2207(3 * x^4 + x^2 + x - y^4 - 2*y^3 - 3*y^2 + y) - \u2207(c). Define a hypothesis expressing that \u2207(3 * x^4 + x^2 + x - y^4 - 2*y^3 - 3*y^2 + y) splits further as: \u2207(3 * x^4 + x^2 + x) - \u2207(y^4 + 2*y^3 + 3*y^2 - y). Assume differentiability for these component functions at the given point. Use this splitting and rules for linear maps to rewrite the expression for the gradient accordingly. Show that the gradient of 3 * x^4 + x^2 + x at the point (-2,2) dotted with (x-(-2), y-2) yields (x-(-2)) * (-99). Use composition and single-variable derivative rules to reduce to a simple univariate computation. Compute the value of the derivative at x = -2. Apply linearity and algebraic simplification to match the required form. Justify differentiability of 3 * x^4 + x^2 + x at the point. Show that the gradient of y^4 + 2*y^3 + 3*y^2 - y at the point (2) dotted with (x-(-2), y-2) yields (y-2) * (67). Use composition and single-variable derivative rules as above. Compute the value of the derivative at y = 2. Apply linearity and simplification for the required outcome. Show differentiability of y^4 + 2*y^3 + 3*y^2 - y at the point. Show the derivative of the constant c at the point dotted with (x-(-2), y-2) gives 0. Substitute all these results into the original equation and simplify. Ensure you justify differentiability throughout: of \u2207(3 * x^4 + x^2 + x), \u2207(y^4 + 2*y^3 + 3*y^2 - y), their sum/difference, and of the constant term."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 + 2 * p.2 ^ 4 + 2 * p.2 ^ 2 - c) ((2:\u211d), (1:\u211d)) (x-2, y-1) = 0) \u2192 ((x-2) * (3) + (y-1) * (12) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1) ((2:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 4 + 2 * p.2 ^ 2) ((2:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 + 2 * p.2 ^ 4 + 2 * p.2 ^ 2) ((2:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1) ((2:\u211d), (1:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 4 + 2 * p.2 ^ 2) ((2:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1) ((2:\u211d), (1:\u211d))) (x - 2, y - 1) = (x-2) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1) = (fun x => 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 4 + 2 * p.2 ^ 2) ((2:\u211d), (1:\u211d))) (x - 2, y - 1) = (y-1) * (12)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 4 + 2 * p.2 ^ 2) = (fun x => 2 * x ^ 4 + 2 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (1:\u211d)) (x - 2, y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3x + 2y^4 + 2y^2 - c = 0 at the point (2,1) is (x-2)*3 + (y-1)*12 = 0. The idea is, to calculate the gradient (\u2207) of the function f(x, y) = 3x + 2y^4 + 2y^2 - c at the point (2,1), then take the dot product with the shifted positional vector (x-2, y-1) and set that equal to zero. This results in the tangent equation, which we show is equivalent to the desired form. Introduce the hypothesis, which states the dot product of the gradient at (2,1) with the vector (x-2, y-1) is zero. Apply the derivative rule for subtraction to split \u2207(3x + 2y^4 + 2y^2 - c) = \u2207(3x + 2y^4 + 2y^2) - \u2207(c). Further split \u2207(3x + 2y^4 + 2y^2) using the derivative rule for addition: \u2207(3x + 2y^4 + 2y^2) = \u2207(3x) + \u2207(2y^4 + 2y^2), assuming both component functions are differentiable at (2,1). Use this decomposition and linear map properties to write the gradient as a sum: \u2207(3x) + \u2207(2y^4 + 2y^2) - \u2207(c). Show that \u2207(3x) at (2,1), applied to (x-2, y-1), yields (x-2)*3. Express 3x as a univariate function composed with projection to the x-coordinate. Apply the appropriate differentiation rules for the composition and univariate case. Compute the value explicitly using linear map properties. Establish differentiability of 3x at (2,1). Show that \u2207(2y^4 + 2y^2) at (2,1), applied to (x-2, y-1), yields (y-1)*12. Express 2y^4 + 2y^2 as a univariate function composed with projection to the y-coordinate. Use differentiation rules to compute the partial with respect to y at the point. Use linear map and algebraic simplification to obtain the final value. Establish differentiability of 2y^4 + 2y^2 at (2,1). Show that \u2207(c) at (2,1), applied to (x-2, y-1), is zero. Substitute all the computed results back into the main hypothesis and simplify. Conclude by ensuring all necessary differentiability conditions for the functions involved."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 + 4 * p.1 ^ 3 + 5 * p.2 ^ 3 - 3 * p.2 - c) ((-3:\u211d), (-4:\u211d)) (x-(-3), y-(-4)) = 0) \u2192 ((x-(-3)) * (0) + (y-(-4)) * (237) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 + 4 * p.1 ^ 3) ((-3:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3 - 3 * p.2) ((-3:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 + 4 * p.1 ^ 3 + 5 * p.2 ^ 3 - 3 * p.2) ((-3:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 + 4 * p.1 ^ 3) ((-3:\u211d), (-4:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 3 - 3 * p.2) ((-3:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 + 4 * p.1 ^ 3) ((-3:\u211d), (-4:\u211d))) (x - (-3), y - (-4)) = (x-(-3)) * (0)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 + 4 * p.1 ^ 3) = (fun x => x ^ 4 + 4 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3 - 3 * p.2) ((-3:\u211d), (-4:\u211d))) (x - (-3), y - (-4)) = (y-(-4)) * (237)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3 - 3 * p.2) = (fun x => 5 * x ^ 3 - 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-4:\u211d)) (x - (-3), y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 + 4x^3 + 5y^3 - 3y - c = 0 at the point (-3,-4) is (x-(-3)) * (0) + (y-(-4)) * (237) = 0. The general strategy is to compute the gradient (\u2207) of the function f(x,y) = x^4 + 4x^3 + 5y^3 - 3y - c at the point (-3,-4), then form the tangent line equation by taking the dot product of the gradient with the vector (x-(-3), y-(-4)), and set it equal to 0. Introduce the main hypothesis: that the directional derivative (dot product of the gradient at (-3,-4) with (x-(-3), y-(-4))) is 0. Use the derivative rule for subtraction to split the gradient: \u2207(x^4 + 4x^3 + 5y^3 - 3y - c) = \u2207(x^4 + 4x^3 + 5y^3 - 3y) - \u2207(c) State a hypothesis splitting \u2207(x^4 + 4x^3 + 5y^3 - 3y) = \u2207(x^4 + 4x^3) + \u2207(5y^3 - 3y), assuming differentiability of these components. Use properties of linear maps to decompose the application to the shifted vector: The directional derivative expression becomes a sum involving the gradients of the separate components. Show that the contribution from the x terms is zero: Use composition and single-variable derivative rules to reduce to the usual derivative in x. Compute the derivative of x^4 + 4x^3 at x = -3. Apply the linear map properties to get the directional derivative for this part. Show the differentiability of x^4 + 4x^3 in x. Show that the contribution from the y terms is (y-(-4)) * (237): Use composition and single-variable derivative rules to reduce to the usual derivative in y. Compute the derivative of 5y^3 - 3y at y = -4. Use the linear map properties and calculations to verify the contribution. Show the differentiability of 5y^3 - 3y in y. Show that the contribution from the constant c is zero when applied to (x-(-3), y-(-4)), as the derivative of a constant is zero. Substitute the computed results to finish simplifying the overall expression. Prove the differentiability of \u2207(x^4 + 4x^3), \u2207(5y^3 - 3y), \u2207(x^4 + 4x^3 + 5y^3 - 3y), and \u2207(c), justifying the above steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 + p.2 ^ 2 - 4 * p.2 - c) ((-2:\u211d), (0:\u211d)) (x-(-2), y-0) = 0) \u2192 ((x-(-2)) * (2) + (y-0) * (-4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((-2:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((-2:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 + p.2 ^ 2 - 4 * p.2) ((-2:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((-2:\u211d), (0:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((-2:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((-2:\u211d), (0:\u211d))) (x - (-2), y - 0) = (x-(-2)) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((-2:\u211d), (0:\u211d))) (x - (-2), y - 0) = (y-0) * (-4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 - 4 * p.2) = (fun x => x ^ 2 - 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (0:\u211d)) (x - (-2), y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x + y^2 - 4*y - c = 0 at the point (-2, 0) is (x-(-2)) * (2) + (y-0) * (-4) = 0. The main steps are to compute the gradient of the function f(x, y) = 2x + y^2 - 4y - c at the point (-2, 0), take its dot product with the shifted vector (x-(-2), y-0), and set that to zero to get the tangent equation. Introduce the main hypothesis, which states that the dot product of the gradient with the vector (x-(-2), y-0) is zero. Apply the differentiation rule for subtraction to split the gradient: \u2207(2x + y^2 - 4y - c) = \u2207(2x + y^2 - 4y) - \u2207(c). Construct a hypothesis that splits the gradient of the sum: \u2207(2x + y^2 - 4y) = \u2207(2x) + \u2207(y^2 - 4y), assuming each term is differentiable at the point. Substitute this result to write the full gradient as \u2207(2x) + \u2207(y^2 - 4y) - \u2207(c). Show that \u2207(2x) evaluated at (-2, 0), applied to (x-(-2), y-0), yields (x-(-2)) * 2. Recognize 2x as a function of x only; handle it using composition. Compute the derivative in x. Use the properties of linear maps to evaluate the result and simplify to the desired expression. Confirm differentiability of 2x at the point. Show that \u2207(y^2 - 4y) evaluated at (-2, 0) and applied to (x-(-2), y-0) yields (y-0) * (-4). Recognize y^2 - 4y as a function of y only; argue with composition. Compute the derivative with respect to y. Use the linear map properties and substitute the values to get (y-0) * (-4). Confirm differentiability of y^2 - 4y at the point. Show that the gradient of the constant c vanishes when applied to (x-(-2), y-0). Substitute all these results into the main hypothesis and simplify. Confirm differentiability for all components and combinations involved."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 4 - 4 * p.1 ^ 3 + 5 * p.2 ^ 2 - c) ((-5:\u211d), (3:\u211d)) (x-(-5), y-3) = 0) \u2192 ((x-(-5)) * (-2800) + (y-3) * (30) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 4 - 4 * p.1 ^ 3) ((-5:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2) ((-5:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 4 - 4 * p.1 ^ 3 + 5 * p.2 ^ 2) ((-5:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 4 - 4 * p.1 ^ 3) ((-5:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 2) ((-5:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 4 - 4 * p.1 ^ 3) ((-5:\u211d), (3:\u211d))) (x - (-5), y - 3) = (x-(-5)) * (-2800)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 4 - 4 * p.1 ^ 3) = (fun x => 5 * x ^ 4 - 4 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2) ((-5:\u211d), (3:\u211d))) (x - (-5), y - 3) = (y-3) * (30)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2) = (fun x => 5 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (3:\u211d)) (x - (-5), y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^4 - 4 * x^3 + 5 * y^2 - c = 0 at the point (-5,3) is (x-(-5)) * (-2800) + (y-3) * (30) = 0. The idea is to find the gradient (\u2207) of f(x, y) = 5 * x^4 - 4 * x^3 + 5 * y^2 - c at (-5, 3), then take the dot product of the gradient with the vector (x-(-5), y-3). Setting this equal to zero gives the tangent equation; we must show this is equivalent to the desired statement. Introduce the hypothesis: assume the dot product of the gradient with the positional vector (x-(-5), y-3), evaluated at (-5, 3), is zero. Apply the rule for the derivative of a subtraction to split \u2207(5 * x^4 - 4 * x^3 + 5 * y^2 - c) as \u2207(5 * x^4 - 4 * x^3 + 5 * y^2) - \u2207(c). Further split \u2207(5 * x^4 - 4 * x^3 + 5 * y^2) as the sum of \u2207(5 * x^4 - 4 * x^3) and \u2207(5 * y^2), assuming differentiability at the relevant points. Substitute these splits into the hypothesis using the properties of linear maps, so the total differential splits as the desired sum and subtraction of differentials. Show that \u2207(5 * x^4 - 4 * x^3) evaluated at (-5, 3) and applied to (x-(-5), y-3) is (x-(-5)) * (-2800): Use composition rules to reduce the gradient to the regular derivative with respect to x. Compute the derivative symbolically. Substitute and simplify the result, arriving at (x-(-5)) * (-2800). Confirm differentiability at the required point. Show that \u2207(5 * y^2) evaluated at (-5, 3) and applied to (x-(-5), y-3) is (y-3) * (30): Use composition rules to reduce the gradient to the regular derivative with respect to y. Compute the derivative symbolically. Substitute and simplify, yielding (y-3) * (30). Confirm differentiability at the required point. Show that the derivative of the constant function c with respect to both variables at any point, applied to any vector, is zero. Substitute all the results into the earlier expanded differential, reduce and simplify to the final required equation. Justify all differentiability assumptions made for the partial computations above."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 4 - 4 * p.1 ^ 2 + p.2 ^ 4 + 3 * p.2 ^ 3 - 3 * p.2 ^ 2 - 3 * p.2 - c) ((6:\u211d), (3:\u211d)) (x-6, y-3) = 0) \u2192 ((x-6) * (3408) + (y-3) * (168) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 4 - 4 * p.1 ^ 2) ((6:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 - 3 * p.2 ^ 2 - 3 * p.2) ((6:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 4 - 4 * p.1 ^ 2 + p.2 ^ 4 + 3 * p.2 ^ 3 - 3 * p.2 ^ 2 - 3 * p.2) ((6:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 4 - 4 * p.1 ^ 2) ((6:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 - 3 * p.2 ^ 2 - 3 * p.2) ((6:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 4 - 4 * p.1 ^ 2) ((6:\u211d), (3:\u211d))) (x - 6, y - 3) = (x-6) * (3408)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 4 - 4 * p.1 ^ 2) = (fun x => 4 * x ^ 4 - 4 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 - 3 * p.2 ^ 2 - 3 * p.2) ((6:\u211d), (3:\u211d))) (x - 6, y - 3) = (y-3) * (168)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 3 * p.2 ^ 3 - 3 * p.2 ^ 2 - 3 * p.2) = (fun x => x ^ 4 + 3 * x ^ 3 - 3 * x ^ 2 - 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (3:\u211d)) (x - 6, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4x\u2074 \u2212 4x\u00b2 + y\u2074 + 3y\u00b3 \u2212 3y\u00b2 \u2212 3y \u2212 c = 0 at the point (6, 3) is (x\u22126) * 3408 + (y\u22123) * 168 = 0. The general approach is to compute the gradient (\u2207) of the function f(x, y) = 4x\u2074 \u2212 4x\u00b2 + y\u2074 + 3y\u00b3 \u2212 3y\u00b2 \u2212 3y \u2212 c at (6, 3), and take its dot product with the vector (x\u22126, y\u22123), then set that equal to 0. Expanding this should yield the desired tangent equation. Introduce the hypothesis, which states that the dot product of the gradient at (6,3) with (x\u22126, y\u22123) is zero. Use the derivative rule for subtraction to split \u2207(4x\u2074 \u2212 4x\u00b2 + y\u2074 + 3y\u00b3 \u2212 3y\u00b2 \u2212 3y \u2212 c) as the gradient of the polynomial part minus the gradient of the constant c. Define an intermediate result splitting the polynomial part: \u2207(4x\u2074 \u2212 4x\u00b2 + y\u2074 + 3y\u00b3 \u2212 3y\u00b2 \u2212 3y) = \u2207(4x\u2074 \u2212 4x\u00b2) + \u2207(y\u2074 + 3y\u00b3 \u2212 3y\u00b2 \u2212 3y), after establishing differentiability at the required points. Use this splitting to rewrite the total gradient as \u2207(4x\u2074 \u2212 4x\u00b2) + \u2207(y\u2074 + 3y\u00b3 \u2212 3y\u00b2 \u2212 3y) \u2212 \u2207(c). Show that \u2207(4x\u2074 \u2212 4x\u00b2) (computed at (6, 3)) applied to (x\u22126, y\u22123) gives (x\u22126) * 3408. Use appropriate composition and single-variable derivative rules to compute the partial derivative with respect to x. Compute and simplify the resulting scalar. Show the differentiability of 4x\u2074 \u2212 4x\u00b2. Show that \u2207(y\u2074 + 3y\u00b3 \u2212 3y\u00b2 \u2212 3y) (computed at (6, 3)) applied to (x\u22126, y\u22123) gives (y\u22123) * 168. As above, use composition and single-variable rules for the partial in y. Compute and simplify the scalar multiple. Show the differentiability of y\u2074 + 3y\u00b3 \u2212 3y\u00b2 \u2212 3y. Compute \u2207(c) applied to (x\u22126, y\u22123), which is zero, since the gradient of a constant vanishes. Substitute the results of the above steps back into the original equation and confirm that combining these results gives (x\u22126) * 3408 + (y\u22123) * 168 = 0. At the end, ensure all functions used are shown to be differentiable at the relevant points to support the above computations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 - 4 * p.2 ^ 2 + 2 * p.2 - c) ((-3:\u211d), (-5:\u211d)) (x-(-3), y-(-5)) = 0) \u2192 ((x-(-3)) * (-30) - (y-(-5)) * (-42) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2) ((-3:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2 - 2 * p.2) ((-3:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 - 4 * p.2 ^ 2 + 2 * p.2) ((-3:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2) ((-3:\u211d), (-5:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 2 - 2 * p.2) ((-3:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2) ((-3:\u211d), (-5:\u211d))) (x - (-3), y - (-5)) = (x-(-3)) * (-30)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2) = (fun x => 5 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2 - 2 * p.2) ((-3:\u211d), (-5:\u211d))) (x - (-3), y - (-5)) = (y-(-5)) * (-42)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2 - 2 * p.2) = (fun x => 4 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-5:\u211d)) (x - (-3), y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 - 4 * y^2 + 2 * y - c = 0 at the point (-3, -5) is (x-(-3)) * (-30) - (y-(-5)) * (-42) = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = 5 * x^2 - 4 * y^2 + 2 * y - c at (-3, -5), then take the dot product with the shifted vector (x-(-3), y-(-5)), and show this yields the required tangent equation. Introduce the hypothesis, which sets the directional derivative (i.e., the gradient applied to (x-(-3), y-(-5))) equal to 0. Use the linearity properties of the derivative to split the derivative of the sum/subtraction: \u2207(5 * x^2 - 4 * y^2 + 2 * y - c) = \u2207(5 * x^2 - 4 * y^2 + 2 * y) - \u2207(c). Refine this splitting: Show that \u2207(5 * x^2 - 4 * y^2 + 2 * y) = \u2207(5 * x^2) - \u2207(4 * y^2 - 2 * y). Assume differentiability at the relevant terms. Apply this splitting to rewrite the main hypothesis, and expand the directional derivative in terms of components using linearity. Compute the component for x: Use the chain rule and properties of composition to reduce the x-gradient to the partial derivative with respect to x. Compute the gradient (as a function) of 5 * x^2 at (-3, -5); show that this, when applied to (x-(-3), y-(-5)), gives (x-(-3)) * (-30). Establish differentiability of 5 * x^2 as needed. Compute the component for y: Use the chain rule and decomposition to reduce the y-gradient to the partial derivative with respect to y. Compute the gradient (as a function) of 4 * y^2 - 2 * y at (-3, -5); show that this, when applied to (x-(-3), y-(-5)), gives (y-(-5)) * (-42). Establish differentiability of 4 * y^2 - 2 * y as needed. Show the derivative of the constant c is always zero when applied to any vector. Substitute all previous calculations into the original equation and simplify to obtain the required form for the tangent. Justify all differentiability statements for the composite functions used."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 4 + 2 * p.1 ^ 3 + 4 * p.1 ^ 2 + 3 * p.2 ^ 2 + 4 * p.2 - c) ((-5:\u211d), (1:\u211d)) (x-(-5), y-1) = 0) \u2192 ((x-(-5)) * (-2390) + (y-1) * (10) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 4 + 2 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-5:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 4 + 2 * p.1 ^ 3 + 4 * p.1 ^ 2 + 3 * p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 4 + 2 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-5:\u211d), (1:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 4 + 2 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-5:\u211d), (1:\u211d))) (x - (-5), y - 1) = (x-(-5)) * (-2390)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 4 + 2 * p.1 ^ 3 + 4 * p.1 ^ 2) = (fun x => 5 * x ^ 4 + 2 * x ^ 3 + 4 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (1:\u211d))) (x - (-5), y - 1) = (y-1) * (10)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 2 + 4 * p.2) = (fun x => 3 * x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (1:\u211d)) (x - (-5), y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^4 + 2 * x^3 + 4 * x^2 + 3 * y^2 + 4 * y - c = 0 at the point (-5, 1) is (x-(-5)) * (-2390) + (y-1) * (10) = 0. The general approach is to compute the gradient (\u2207) of f(x, y) = 5 * x^4 + 2 * x^3 + 4 * x^2 + 3 * y^2 + 4 * y - c at the point (-5, 1), take its dot product with the vector (x-(-5), y-1), and set it to zero to get the tangent equation. Introduce the hypothesis, which is that the dot product of the gradient at the point (-5,1) with the vector (x-(-5), y-1) is zero. Apply the derivative rule for subtraction to write the gradient as \u2207(5x^4 + 2x^3 + 4x^2 + 3y^2 + 4y - c) = \u2207(5x^4 + 2x^3 + 4x^2 + 3y^2 + 4y) - \u2207(c). Define an intermediate result that splits the gradient as \u2207(F(x, y)) = \u2207(5x^4 + 2x^3 + 4x^2) + \u2207(3y^2 + 4y), and assume differentiability at each part. Use the above and rules for linear maps to structure the gradient and plug in the shifted vector to get component-wise expressions. Show that \u2207(5x^4 + 2x^3 + 4x^2) at (-5,1) dotted with (x-(-5), y-1) simplifies to (x-(-5)) * (-2390): Express 5x^4 + 2x^3 + 4x^2 as a function of one variable using composition, so the gradient calculation reduces to a one-variable problem. Compute the derivative with respect to x, then evaluate it at x = -5. Use simplification and linear map properties to extract the desired coefficient. Argue differentiability for this part. Show that \u2207(3y^2 + 4y) at (-5,1) dotted with (x-(-5), y-1) gives (y-1) * (10): Use a similar one-variable composition argument for the y part. Compute the derivative with respect to y and evaluate at y = 1. Use simplification and linear map rules to get the coefficient for (y-1). Argue differentiability for this part. Show that the gradient of a constant function c is zero at any point, so the piece involving \u2207(c) vanishes. Substitute all computed pieces back and reduce to the tangent equation form: (x-(-5)) * (-2390) + (y-1) * (10) = 0. Justify the differentiability for all the component expressions to ensure all steps are valid."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 + p.1 - 3 * p.2 - c) ((-4:\u211d), (-3:\u211d)) (x-(-4), y-(-3)) = 0) \u2192 ((x-(-4)) * (-15) - (y-(-3)) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2 + p.1) ((-4:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2) ((-4:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 + p.1 - 3 * p.2) ((-4:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2 + p.1) ((-4:\u211d), (-3:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2) ((-4:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2 + p.1) ((-4:\u211d), (-3:\u211d))) (x - (-4), y - (-3)) = (x-(-4)) * (-15)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2 + p.1) = (fun x => 2 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2) ((-4:\u211d), (-3:\u211d))) (x - (-4), y - (-3)) = (y-(-3)) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2) = (fun x => 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (-3:\u211d)) (x - (-4), y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^2 + x - 3 * y - c = 0 at the point (-4, -3) is (x-(-4)) * (-15) - (y-(-3)) * (3) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 2 * x^2 + x - 3 * y - c at the point (-4, -3), take its dot product with the vector (x-(-4), y-(-3)), set this equal to 0, and simplify to the desired tangent equation. Introduce the initial hypothesis: the dot product of the gradient at the point with the shifted vector equals 0. Use the property of the derivative of a difference to split \u2207(2 * x^2 + x - 3 * y - c) as \u2207(2 * x^2 + x - 3 * y) - \u2207(c). Introduce a hypothesis to split \u2207(2 * x^2 + x - 3 * y) as \u2207(2 * x^2 + x) - \u2207(3 * y), assuming differentiability at these subfunctions. Use this splitting to express and manipulate the gradient applied at the specific point to the shifted vector. Show that \u2207(2 * x^2 + x) at (-4, -3) applied to (x-(-4), y-(-3)) gives (x-(-4)) * (-15). Use composition and linearity rules to reduce the computation to the standard derivative with respect to x. Calculate the derivative with respect to x at the point. Simplify and verify the linear map calculation. Establish differentiability of 2 * x^2 + x. Show that \u2207(3 * y) at (-4, -3) applied to (x-(-4), y-(-3)) yields (y-(-3)) * (3). Use composition and linearity to reduce to the standard derivative with respect to y. Compute this derivative. Simplify and match to the target expression. Establish differentiability of 3 * y. Show that the gradient of the constant c term at the point, applied to any vector, is zero. Substitute previous results into the main equation and simplify to the desired tangent equation. Supply or justify differentiability for all component functions as required for correctness."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 - 3 * p.1 - p.2 - c) ((2:\u211d), (3:\u211d)) (x-2, y-3) = 0) \u2192 ((x-2) * (1) - (y-3) * (1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 - 3 * p.1) ((2:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2) ((2:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 - 3 * p.1 - p.2) ((2:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 - 3 * p.1) ((2:\u211d), (3:\u211d)) -\n      fderiv \u211d (fun p => p.2) ((2:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 - 3 * p.1) ((2:\u211d), (3:\u211d))) (x - 2, y - 3) = (x-2) * (1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 - 3 * p.1) = (fun x => x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2) ((2:\u211d), (3:\u211d))) (x - 2, y - 3) = (y-3) * (1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2) = (fun x => x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (3:\u211d)) (x - 2, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact differentiableAt_snd\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 - 3x - y - c = 0 at the point (2,3) is (x-2) * (1) - (y-3) * (1) = 0. The main approach is to find the gradient (\u2207) of f(x, y) = x^2 - 3x - y - c at the point (2, 3), and then set its dot product with the shifted positional vector (x-2, y-3) to zero, resulting in an explicit equation for the tangent. Introduce the hypothesis: the dot product of the gradient at (2,3) with (x-2, y-3) is zero. Use the derivative rule of subtraction to expand \u2207(x^2 - 3x - y - c) as \u2207(x^2 - 3x - y) - \u2207(c). Provide a further splitting via a hypothesis: \u2207(x^2 - 3x - y) = \u2207(x^2 - 3x) - \u2207(y). Assume differentiability at (x^2 - 3x) and at (y). Substitute this splitting and apply the rules for subtracting linear maps to distribute the dot product. Show that \u2207(x^2 - 3x) at (2, 3) dot (x-2, y-3) equals (x-2) * 1. Use suitable composition and derivative rules to reduce the multidimensional gradient to a single-variable derivative. Compute the derivative with respect to x and evaluate at the point. Use algebraic simplifications with properties of linear maps. Show differentiability of x^2 - 3x at the point. Show that \u2207(y) at (2, 3) dot (x-2, y-3) equals (y-3) * 1. Reduce to a suitable single-variable context using composition rules. Compute the derivative with respect to y and evaluate. Use linear map properties and basic simplification. Prove differentiability of y. Show that the gradient of the constant term c contributes zero to the expression when dotted with the vector. Substitute these calculations into your original equation and simplify. Justify the differentiability of all the necessary component functions and their combinations throughout."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 - 5 * p.2 ^ 2 + 2 * p.2 - c) ((0:\u211d), (-3:\u211d)) (x-0, y-(-3)) = 0) \u2192 ((x-0) * (0) - (y-(-3)) * (-32) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3) ((0:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2 - 2 * p.2) ((0:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 - 5 * p.2 ^ 2 + 2 * p.2) ((0:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3) ((0:\u211d), (-3:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 2 - 2 * p.2) ((0:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3) ((0:\u211d), (-3:\u211d))) (x - 0, y - (-3)) = (x-0) * (0)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3) = (fun x => 2 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2 - 2 * p.2) ((0:\u211d), (-3:\u211d))) (x - 0, y - (-3)) = (y-(-3)) * (-32)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2 - 2 * p.2) = (fun x => 5 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (-3:\u211d)) (x - 0, y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^3 - 5 * y^2 + 2 * y - c = 0 at the point (0, -3) is (x-0) * (0) - (y-(-3)) * (-32) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 2 * x^3 - 5 * y^2 + 2 * y - c at the point (0, -3), then take the dot product of this gradient with the shifted vector (x-0, y-(-3)), and set that to 0. We need to show this results in the claimed tangent equation. Introduce the hypothesis, which is that the dot product of the gradient at (0, -3) with the shifted vector (x-0, y-(-3)) is zero. Apply the rule for the derivative of a subtraction to write \u2207(2 * x^3 - 5 * y^2 + 2 * y - c) as \u2207(2 * x^3 - 5 * y^2 + 2 * y) - \u2207(c). State a hypothesis to split \u2207(2 * x^3 - 5 * y^2 + 2 * y) as \u2207(2 * x^3) - \u2207(5 * y^2 - 2 * y), assuming differentiability of each part at (0, -3). Use this split and linearity properties to write the overall gradient as \u2207(2 * x^3) - \u2207(5 * y^2 - 2 * y) - \u2207(c). Show that the gradient of 2 * x^3 at (0, -3) dotted with (x, y+3) equals (x-0) * (0). Use the chain rule and properties of partial derivatives to reduce to a one-variable derivative. Compute the required derivative at x = 0. Use properties of linear maps and simplify. Argue differentiability of 2 * x^3. Show that the gradient of (5 * y^2 - 2 * y) at (0, -3) dotted with (x, y+3) is (y-(-3)) * (-32). Use chain rule and partial derivatives for y-component. Compute the derivative with respect to y at y = -3. Use properties of linear maps and simplify. Argue differentiability of 5 * y^2 - 2 * y. Show that the gradient of the constant c at (0, -3) dotted with (x, y+3) is 0. Plug the computed values for each component back into the original hypothesis to get the tangent equation. Provide the required differentiability justifications for each sub-expression and the overall function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 + 3 * p.1 + p.2 ^ 4 + p.2 - c) ((2:\u211d), (0:\u211d)) (x-2, y-0) = 0) \u2192 ((x-2) * (15) + (y-0) * (1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 + 3 * p.1) ((2:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + p.2) ((2:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 + 3 * p.1 + p.2 ^ 4 + p.2) ((2:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 + 3 * p.1) ((2:\u211d), (0:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + p.2) ((2:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 + 3 * p.1) ((2:\u211d), (0:\u211d))) (x - 2, y - 0) = (x-2) * (15)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 + 3 * p.1) = (fun x => 3 * x ^ 2 + 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + p.2) ((2:\u211d), (0:\u211d))) (x - 2, y - 0) = (y-0) * (1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + p.2) = (fun x => x ^ 4 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (0:\u211d)) (x - 2, y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 + 3 * x + y^4 + y - c = 0 at the point (2,0) is (x-2) * 15 + (y-0) * 1 = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 3 * x^2 + 3 * x + y^4 + y - c at the point (2, 0), then take the dot product of this gradient with the vector (x-2, y-0). Setting that equal to 0 gives the tangent equation, which we want to show is exactly (x-2) * 15 + (y-0) * 1 = 0.  Introduce the hypothesis: that the directional derivative (gradient, or fderiv) of f at (2, 0), along (x-2, y-0), is 0. Apply a rule to split the derivative of a subtraction, so that \u2207(3 * x^2 + 3 * x + y^4 + y - c) becomes \u2207(3 * x^2 + 3 * x + y^4 + y) - \u2207(c). Prove a further decomposition: that the gradient of 3 * x^2 + 3 * x + y^4 + y can be written as the sum of the gradients of 3 * x^2 + 3 * x (with respect to x) and y^4 + y (with respect to y), assuming both parts are differentiable. Use this decomposition, and properties of linear maps, to expand the main gradient into its two main terms plus the constant. Compute the action of \u2207(3 * x^2 + 3 * x) at (2,0) on (x-2, y-0), showing it\u2019s (x-2) * 15: Use function composition and rules to write as a one-variable function in x, and relate fderiv to the usual derivative. Compute the derivative with respect to x. Use properties of linear maps and arithmetic to complete this calculation. Verify differentiability of 3 * x^2 + 3 * x. Compute the action of \u2207(y^4 + y) at (2,0) on (x-2, y-0), showing it\u2019s (y-0) * 1: Use composition and rules to write as a one-variable function in y, and relate fderiv to the usual derivative. Compute the derivative with respect to y, evaluated at y = 0. Use properties of linear maps and arithmetic to complete the calculation. Verify differentiability of y^4 + y. Show that the constant part \u2207(c), applied to any direction, is zero. Substitute all previous results into the original equation, and simplify. Justify differentiability for all relevant functions at (2,0)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 4 + 5 * p.1 ^ 3 + 4 * p.1 ^ 2 + 2 * p.2 ^ 3 + 5 * p.2 ^ 2 - c) ((-5:\u211d), (3:\u211d)) (x-(-5), y-3) = 0) \u2192 ((x-(-5)) * (-665) + (y-3) * (84) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 4 + 5 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-5:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3 + 5 * p.2 ^ 2) ((-5:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 4 + 5 * p.1 ^ 3 + 4 * p.1 ^ 2 + 2 * p.2 ^ 3 + 5 * p.2 ^ 2) ((-5:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 4 + 5 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-5:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 3 + 5 * p.2 ^ 2) ((-5:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 4 + 5 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-5:\u211d), (3:\u211d))) (x - (-5), y - 3) = (x-(-5)) * (-665)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 4 + 5 * p.1 ^ 3 + 4 * p.1 ^ 2) = (fun x => 2 * x ^ 4 + 5 * x ^ 3 + 4 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3 + 5 * p.2 ^ 2) ((-5:\u211d), (3:\u211d))) (x - (-5), y - 3) = (y-3) * (84)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3 + 5 * p.2 ^ 2) = (fun x => 2 * x ^ 3 + 5 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (3:\u211d)) (x - (-5), y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^4 + 5 * x^3 + 4 * x^2 + 2 * y^3 + 5 * y^2 - c = 0 at the point (-5,3) is (x-(-5)) * (-665) + (y-3) * (84) = 0. The approach is to compute the gradient (\u2207) of the given function at the point (-5,3), take its dot product with the shifted positional vector (x-(-5), y-3), set this dot product equal to zero, and show that this results in the tangent equation as claimed.  Introduce the hypothesis, which is the dot product of the gradient at the point (-5,3), with the shifted vector (x-(-5), y-3), equal to zero. Split the derivative using the subtraction rule: the gradient of (2 * x^4 + 5 * x^3 + 4 * x^2 + 2 * y^3 + 5 * y^2 - c) is the gradient of (2 * x^4 + 5 * x^3 + 4 * x^2 + 2 * y^3 + 5 * y^2) minus the gradient of c. Introduce an intermediate result (h_split) that rewrites the gradient of (2 * x^4 + 5 * x^3 + 4 * x^2 + 2 * y^3 + 5 * y^2) as the sum of the gradients of (2 * x^4 + 5 * x^3 + 4 * x^2) and (2 * y^3 + 5 * y^2), under differentiability assumptions for each subpart. Use properties of linear maps to distribute the application of these gradients to the shifted vector, so the tangent equation is expressed in terms of the two partial gradients and the constant term. Compute the directional derivative corresponding to the x-dependent part at (-5,3), evaluated on (x-(-5), y-3): Use the chain and addition rules to express the gradient with respect to x. Calculate and simplify the expression to show this yields (x-(-5)) * (-665). Justify differentiability of (2 * x^4 + 5 * x^3 + 4 * x^2) at (-5,3). Compute the directional derivative corresponding to the y-dependent part at (-5,3), evaluated on (x-(-5), y-3): Use the composition and addition rules to establish the gradient with respect to y. Calculate and simplify this to (y-3) * (84). Justify differentiability of (2 * y^3 + 5 * y^2) at (-5,3). Show that the gradient of the constant c, evaluated at any point, applied to any vector, will be zero. Substitute all the computed gradients and simplifications back into the main equation, so the tangent equation reduces to (x-(-5)) * (-665) + (y-3) * (84) = 0. Ensure that all functions involved are differentiable at the required points, verifying differentiability for each of the decomposed components and the full function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 - p.1 + 4 * p.2 ^ 2 - c) ((0:\u211d), (0:\u211d)) (x-0, y-0) = 0) \u2192 ((x-0) * (-1) + (y-0) * (0) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 - p.1) ((0:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2) ((0:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 - p.1 + 4 * p.2 ^ 2) ((0:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 - p.1) ((0:\u211d), (0:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 2) ((0:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 - p.1) ((0:\u211d), (0:\u211d))) (x - 0, y - 0) = (x-0) * (-1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 - p.1) = (fun x => x ^ 4 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2) ((0:\u211d), (0:\u211d))) (x - 0, y - 0) = (y-0) * (0)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2) = (fun x => 4 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (0:\u211d)) (x - 0, y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 - x + 4y^2 - c = 0 at the point (0,0) is (x - 0) * (-1) + (y - 0) * (0) = 0. That is, we compute the gradient \u2207f of f(x, y) = x^4 - x + 4y^2 - c at (0, 0), take its dot product with the displacement vector (x - 0, y - 0), set it equal to zero, and show this equation is equivalent to (x - 0) * (-1) + (y - 0) * (0) = 0.  Introduce the hypothesis: The dot product of the gradient of f(x, y) with the shifted positional vector at (0, 0) is zero. Use the rule that the derivative of a difference is the difference of the derivatives to split \u2207(x^4 - x + 4y^2 - c) = \u2207(x^4 - x + 4y^2) - \u2207(c) Establish a splitting of \u2207(x^4 - x + 4y^2) = \u2207(x^4 - x) + \u2207(4y^2), under appropriate differentiability assumptions. Substitute back and use properties of linear maps to write the main gradient in terms of smaller gradients using addition/subtraction. Evaluate \u2207(x^4 - x) at (0, 0) dotted with (x - 0, y - 0): Use function composition and rules so that the gradient with respect to one variable reduces to a simple derivative. Compute the derivative with respect to x, evaluate at x = 0. Unwrap linear map applications and simplify to prove the given equality. Justify differentiability as needed. Evaluate \u2207(4y^2) at (0, 0) dotted with (x - 0, y - 0): Use suitable rules to convert gradient with respect to y to simple derivative. Compute the derivative with respect to y and evaluate at y = 0. Unwrap the map, simplify, and show the result. Justify differentiability of (4y^2). Show that \u2207(c) at (0, 0) dotted with (x - 0, y - 0) = 0, since c is a constant. Substitute the results from the previous steps to simplify the full expression for the tangent condition. Provide differentiability justifications for all subexpressions as needed."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1 - 4 * p.2 ^ 3 - p.2 ^ 2 + p.2 - c) ((3:\u211d), (0:\u211d)) (x-3, y-0) = 0) \u2192 ((x-3) * (133) - (y-0) * (-1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1) ((3:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 + p.2 ^ 2 - p.2) ((3:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1 - 4 * p.2 ^ 3 - p.2 ^ 2 + p.2) ((3:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1) ((3:\u211d), (0:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 + p.2 ^ 2 - p.2) ((3:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1) ((3:\u211d), (0:\u211d))) (x - 3, y - 0) = (x-3) * (133)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1) = (fun x => 5 * x ^ 3 - x ^ 2 + 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 + p.2 ^ 2 - p.2) ((3:\u211d), (0:\u211d))) (x - 3, y - 0) = (y-0) * (-1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 + p.2 ^ 2 - p.2) = (fun x => 4 * x ^ 3 + x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (0:\u211d)) (x - 3, y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^3 - x^2 + 4 * x - 4 * y^3 - y^2 + y - c = 0 at the point (3, 0) is (x-3) * (133) - (y-0) * (-1) = 0. The idea is, to calculate the gradient (\u2207) of the function f(x, y) = 5 * x^3 - x^2 + 4 * x - 4 * y^3 - y^2 + y - c at the point (3, 0), then take the dot product of this gradient with the shifted vector (x-3, y-0). Setting this equal to 0 gives the equation of the tangent; we need to show this is equivalent to the given expression. Introduce the hypothesis: the dot product of the gradient and the shifted vector is zero. Apply the derivative rule for subtraction to rewrite \u2207(5 * x^3 - x^2 + 4 * x - 4 * y^3 - y^2 + y - c) as the difference: \u2207(5 * x^3 - x^2 + 4 * x - 4 * y^3 - y^2 + y) - \u2207(c). Define a hypothesis splitting \u2207(5 * x^3 - x^2 + 4 * x - 4 * y^3 - y^2 + y) = \u2207(5 * x^3 - x^2 + 4 * x) - \u2207(4 * y^3 + y^2 - y), and assume differentiability of each summand at the point. Apply this to write the gradient as \u2207(5 * x^3 - x^2 + 4 * x) - \u2207(4 * y^3 + y^2 - y) - \u2207(c). Show that \u2207(5 * x^3 - x^2 + 4 * x) at (3, 0) applied to (x-3, y-0) is (x-3) * (133). Express the function as a composition to extract x-derivative. Compute the partial derivative with respect to x. Use the rules of linear maps and algebra to verify the result. Prove differentiability of 5 * x^3 - x^2 + 4 * x. Show that \u2207(4 * y^3 + y^2 - y) at (3, 0) applied to (x-3, y-0) is (y-0) * (-1). Express the function as a composition to extract y-derivative. Compute the partial derivative with respect to y. Use linearity and algebra to confirm the result matches. Prove differentiability of 4 * y^3 + y^2 - y. Show that \u2207(c) at (3,0) applied to (x-3, y-0) is 0 (the constant\u2019s derivative is zero). Substitute these calculations into the original equation to get (x-3) * (133) - (y-0) * (-1) = 0. Justify differentiability of the required component functions and sums/differences at the relevant points."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 - p.2 ^ 3 - c) ((-2:\u211d), (-2:\u211d)) (x-(-2), y-(-2)) = 0) \u2192 ((x-(-2)) * (48) - (y-(-2)) * (12) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3) ((-2:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3) ((-2:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 - p.2 ^ 3) ((-2:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3) ((-2:\u211d), (-2:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 3) ((-2:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3) ((-2:\u211d), (-2:\u211d))) (x - (-2), y - (-2)) = (x-(-2)) * (48)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3) = (fun x => 4 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3) ((-2:\u211d), (-2:\u211d))) (x - (-2), y - (-2)) = (y-(-2)) * (12)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3) = (fun x => x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (-2:\u211d)) (x - (-2), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact differentiableAt_snd.pow _\n  \n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 - y^3 - c = 0 at the point (-2,-2) is (x-(-2)) * 48 - (y-(-2)) * 12 = 0. The idea is, to calculate the gradient (\u2207) of the function f(x,y) = 4 * x^3 - y^3 - c at the point (-2,-2), then take the dot product of it with the shifted positional vector (x-(-2), y-(-2)). Setting that equation equal to 0 gives us the equation of the tangent, which we have to show matches (x-(-2)) * 48 - (y-(-2)) * 12 = 0. Introduce the hypothesis, which is that the dot product of the gradient at (-2,-2) with (x-(-2), y-(-2)) is 0. Apply the rule for the derivative of a subtraction to split \u2207(4 * x^3 - y^3 - c) into \u2207(4 * x^3 - y^3) - \u2207(c). Introduce a statement that further splits \u2207(4 * x^3 - y^3) = \u2207(4 * x^3) - \u2207(y^3), assuming differentiability of each part at the point (-2, -2). Use properties of the linear map to further distribute the split applied to \u2207(4 * x^3 - y^3 - c), reducing it to the application of the gradients of each term. Show that the gradient of 4 * x^3 at (-2,-2) applied to (x-(-2), y-(-2)) is (x-(-2)) * 48: Use function composition and differentiation rules to extract the x-component derivative. Calculate the derivative at the given point. Use linear map application rules and algebraic simplification to reach the desired result. Note the differentiability of 4*x^3. Show that the gradient of y^3 at (-2,-2) applied to (x-(-2), y-(-2)) is (y-(-2)) * 12: Use composition and differentiation rules for the y-component. Calculate the partial derivative at the point. Complete the evaluation with the linear map properties. Note differentiability of y^3. Show that the gradient of the constant c at (-2,-2) applied to (x-(-2), y-(-2)) is 0. Substitute the values obtained for each term back into the original equation and simplify. Conclude by asserting the differentiability of the function 4*x^3, y^3, their combination, and the constant, as required."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 - 2 * p.1 ^ 3 - 4 * p.1 ^ 2 + 5 * p.1 - 2 * p.2 ^ 3 - c) ((4:\u211d), (3:\u211d)) (x-4, y-3) = 0) \u2192 ((x-4) * (133) - (y-3) * (54) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 - 2 * p.1 ^ 3 - 4 * p.1 ^ 2 + 5 * p.1) ((4:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3) ((4:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 - 2 * p.1 ^ 3 - 4 * p.1 ^ 2 + 5 * p.1 - 2 * p.2 ^ 3) ((4:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 - 2 * p.1 ^ 3 - 4 * p.1 ^ 2 + 5 * p.1) ((4:\u211d), (3:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 3) ((4:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 - 2 * p.1 ^ 3 - 4 * p.1 ^ 2 + 5 * p.1) ((4:\u211d), (3:\u211d))) (x - 4, y - 3) = (x-4) * (133)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 - 2 * p.1 ^ 3 - 4 * p.1 ^ 2 + 5 * p.1) = (fun x => x ^ 4 - 2 * x ^ 3 - 4 * x ^ 2 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3) ((4:\u211d), (3:\u211d))) (x - 4, y - 3) = (y-3) * (54)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3) = (fun x => 2 * x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (3:\u211d)) (x - 4, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 - 2x^3 - 4x^2 + 5x - 2y^3 - c = 0 at the point (4,3) is (x-4) * 133 - (y-3) * 54 = 0. The idea is: compute the gradient (\u2207) of f(x,y)=x^4 - 2x^3 - 4x^2 + 5x - 2y^3 - c at (4,3), take its dot product with the shifted vector (x-4, y-3), and set the result to 0 to yield the tangent equation in the desired form. Introduce the hypothesis: the directional derivative (gradient dot shifted vector) at (4,3) equals zero. Apply the derivative rule for subtraction to split the gradient: \u2207(x^4 - 2x^3 - 4x^2 + 5x - 2y^3 - c) = \u2207(x^4 - 2x^3 - 4x^2 + 5x - 2y^3) - \u2207(c). Define a hypothesis that further splits the gradient of (x^4 - 2x^3 - 4x^2 + 5x - 2y^3) as \u2207(x^4 - 2x^3 - 4x^2 + 5x) - \u2207(2y^3). Assume differentiability of each part at (4,3). Apply these splittings and use linearity rules to rewrite the gradient in terms of parts involving only x and only y. Show that \u2207(x^4 - 2x^3 - 4x^2 + 5x) at (4,3) dotted with (x-4, y-3) produces (x-4) * 133. Express the function as a composition, so the gradient becomes a univariate derivative with respect to x. Apply derivative rules (sum, difference, and power rules) to compute the derivative with respect to x. Evaluate at x=4 and compute as required. Prove differentiability of x^4 - 2x^3 - 4x^2 + 5x. Show that \u2207(2y^3) at (4,3) dotted with (x-4, y-3) gives (y-3) * 54. Express the function as a composition for the y variable. Differentiate 2y^3 with respect to y and evaluate at y=3. Use the linear map rules and computation to show the result. Prove differentiability of 2y^3. Show that the gradient of c (a constant) at (4,3) dotted with any vector is zero. Substitute the computed values back and simplify the equation to obtain the tangent form. Check and supply differentiability for all aggregated expressions (and for the constants)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 + 3 * p.1 - p.2 ^ 3 - c) ((-4:\u211d), (1:\u211d)) (x-(-4), y-1) = 0) \u2192 ((x-(-4)) * (-1221) - (y-1) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 + 3 * p.1) ((-4:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3) ((-4:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 + 3 * p.1 - p.2 ^ 3) ((-4:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 + 3 * p.1) ((-4:\u211d), (1:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 3) ((-4:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 + 3 * p.1) ((-4:\u211d), (1:\u211d))) (x - (-4), y - 1) = (x-(-4)) * (-1221)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 + 3 * p.1) = (fun x => 4 * x ^ 4 - 5 * x ^ 3 - 5 * x ^ 2 + 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3) ((-4:\u211d), (1:\u211d))) (x - (-4), y - 1) = (y-1) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3) = (fun x => x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (1:\u211d)) (x - (-4), y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact differentiableAt_snd.pow _\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4x\u2074 - 5x\u00b3 - 5x\u00b2 + 3x - y\u00b3 - c = 0 at the point (-4, 1) is (x-(-4)) * (-1221) - (y-1) * (3) = 0. The idea is to compute the gradient (\u2207) of f(x, y) = 4x\u2074 - 5x\u00b3 - 5x\u00b2 + 3x - y\u00b3 - c at (-4, 1), then take its dot product with the vector (x-(-4), y-1), and set it to 0. This gives the equation for the tangent line, and you need to show it's equivalent to the one given in the statement.  Introduce the hypothesis that the dot product of the gradient at the given point with the shifted vector equals zero. Apply the derivative rule for subtraction to split \u2207(4x\u2074 - 5x\u00b3 - 5x\u00b2 + 3x - y\u00b3 - c) as \u2207(4x\u2074 - 5x\u00b3 - 5x\u00b2 + 3x - y\u00b3) - \u2207(c). Define a hypothesis to split \u2207(4x\u2074 - 5x\u00b3 - 5x\u00b2 + 3x - y\u00b3) as \u2207(4x\u2074 - 5x\u00b3 - 5x\u00b2 + 3x) - \u2207(y\u00b3); assume differentiability of both component functions at the point. Use this splitting and properties of linear maps to work with the formula for the gradient at (-4, 1). Show that evaluating the gradient of 4x\u2074 - 5x\u00b3 - 5x\u00b2 + 3x at the point (-4, 1) and dotting with (x-(-4), y-1) gives (x-(-4)) * (-1221): Express the function as a composition with the projection onto the first variable. Apply the rules for the total derivative of compositions and polynomials in one variable. Compute the result of the gradient at the given point. Establish the differentiability of the function at the point. Show that the gradient of y\u00b3 at the point (-4, 1) dotted with (x-(-4), y-1) gives (y-1) * (3): Express the function as a composition with the projection onto the second variable. Use the appropriate derivative rules for the polynomial in one variable. Evaluate at the given point and simplify. Confirm differentiability at the point. Show that the gradient of the constant function c at (-4, 1) dotted with (x-(-4), y-1) is zero. Substitute all the previous results back into the equation, simplify, and deduce that it is equivalent to the statement you aim to prove. Ensure to justify differentiability of all component functions at the relevant points."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 - p.2 ^ 2 + p.2 - c) ((-3:\u211d), (-2:\u211d)) (x-(-3), y-(-2)) = 0) \u2192 ((x-(-3)) * (1) - (y-(-2)) * (-5) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1) ((-3:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 - p.2) ((-3:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 - p.2 ^ 2 + p.2) ((-3:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => p.1) ((-3:\u211d), (-2:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 2 - p.2) ((-3:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1) ((-3:\u211d), (-2:\u211d))) (x - (-3), y - (-2)) = (x-(-3)) * (1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1) = (fun x => x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 - p.2) ((-3:\u211d), (-2:\u211d))) (x - (-3), y - (-2)) = (y-(-2)) * (-5)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 - p.2) = (fun x => x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-2:\u211d)) (x - (-3), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x - y^2 + y - c = 0 at the point (-3, -2) is (x-(-3)) * (1) - (y-(-2)) * (-5) = 0. The plan is to compute the gradient (\u2207) of the function f(x, y) = x - y^2 + y - c at the point (-3, -2), take its dot product with the vector (x-(-3), y-(-2)), set it equal to 0 (as per the hypothesis), and show this is equivalent to the desired equation. Introduce the hypothesis that the dot product of the gradient at the point with the shifted vector is equal to zero. Decompose the derivative using the subtraction rule: \u2207(x - y^2 + y - c) = \u2207(x - y^2 + y) - \u2207(c). Establish a hypothesis that further splits the gradient: \u2207(x - y^2 + y) = \u2207(x) - \u2207(y^2 - y), under the assumption these pieces are differentiable. Apply the previous split and use properties of linear maps to write the total gradient in terms of the gradients of the parts. Show that (fderiv \u211d (fun p => p.1) ...) at (-3,-2) acting on (x-(-3), y-(-2)) simplifies to (x-(-3)) * 1. Express the original function as a composition to isolate differentiation with respect to x. Use the rules for differentiation and linear maps to complete the calculation. Note the differentiability of the projection onto the first variable. Show that (fderiv \u211d (fun p => p.2^2 - p.2) ...) at (-3, -2) acting on (x-(-3), y-(-2)) simplifies to (y-(-2)) * (-5). Rewrite as a composition so the derivative is taken in the y variable. Calculate the required derivative using rules for polynomials, noting the particular value needed at y = -2. Use linearity properties to simplify. Argue the differentiability of y^2 - y. Show that (fderiv \u211d (fun p => c) ...) at (-3, -2) acting on (x-(-3), y-(-2)) is 0, as c is constant. Substitute all the results from steps 5, 6, and 7 back into the main equation and simplify. Justify the differentiability of all the component functions involved at the point (-3, -2), as required to make the splitting and computations above valid."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1 - 2 * p.2 ^ 4 + p.2 ^ 3 - 2 * p.2 ^ 2 - 5 * p.2 - c) ((6:\u211d), (-5:\u211d)) (x-6, y-(-5)) = 0) \u2192 ((x-6) * (355) - (y-(-5)) * (-1090) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1) ((6:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 4 - p.2 ^ 3 + 2 * p.2 ^ 2 + 5 * p.2) ((6:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1 - 2 * p.2 ^ 4 + p.2 ^ 3 - 2 * p.2 ^ 2 - 5 * p.2) ((6:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1) ((6:\u211d), (-5:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 4 - p.2 ^ 3 + 2 * p.2 ^ 2 + 5 * p.2) ((6:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1) ((6:\u211d), (-5:\u211d))) (x - 6, y - (-5)) = (x-6) * (355)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1) = (fun x => 3 * x ^ 3 + 3 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 4 - p.2 ^ 3 + 2 * p.2 ^ 2 + 5 * p.2) ((6:\u211d), (-5:\u211d))) (x - 6, y - (-5)) = (y-(-5)) * (-1090)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 4 - p.2 ^ 3 + 2 * p.2 ^ 2 + 5 * p.2) = (fun x => 2 * x ^ 4 - x ^ 3 + 2 * x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (-5:\u211d)) (x - 6, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3*x^3 + 3*x^2 - 5*x - 2*y^4 + y^3 - 2*y^2 - 5*y - c = 0 at the point (6, -5) can be written as (x-6) * 355 - (y-(-5)) * (-1090) = 0. The method is to compute the gradient vector (\u2207) of the function f(x, y) = 3*x^3 + 3*x^2 - 5*x - 2*y^4 + y^3 - 2*y^2 - 5*y - c at the point (6, -5), then take the dot product of this vector with the displacement vector (x-6, y-(-5)), set this equal to zero, and show it is equivalent to the desired form. Introduce the main hypothesis, which asserts that the dot product of the gradient at (6, -5) with (x-6, y-(-5)) is zero. Apply the derivative rule for subtraction: rewrite the derivative as a difference of \u2207(main function) and \u2207(c), separating the constant. Define a hypothesis that splits the function into x-terms and y-terms: Write the gradient of [3*p.1^3 + 3*p.1^2 - 5*p.1 - 2*p.2^4 + p.2^3 - 2*p.2^2 - 5*p.2] as the gradient of [3*p.1^3 + 3*p.1^2 - 5*p.1] (x part) minus the gradient of [2*p.2^4 - p.2^3 + 2*p.2^2 + 5*p.2] (y part), assuming both parts are differentiable at the point. Use properties of linear maps and these splits to express the overall directional derivative at the point (6, -5) in terms of directional derivatives of the x-part, the y-part, and the constant. Show that the gradient of the x-part at (6, -5) with (x-6, y-(-5)) gives (x-6) * 355: Use function composition and differentiation rules to reduce the x-part to a regular univariate derivative in x. Compute the univariate derivative at x = 6, evaluate it, and confirm differentiability. Show through simplification that the result multiplies (x-6) by 355. Show that the gradient of the y-part at (6, -5) with (x-6, y-(-5)) gives (y-(-5)) * (-1090): Use composition and differentiation rules to reduce to the univariate y-derivative. Calculate the y-derivative at y = -5, check differentiability. Show that this gives (y-(-5)) times (-1090). Show that the gradient of the constant function c at any point, applied to any vector, is zero. Substitute the results from steps 5, 6, 7 into the main equation and simplify, arriving at the tangent form. Give or justify the necessary differentiability conditions for all functions considered."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 - 3 * p.1 + p.2 ^ 2 - c) ((5:\u211d), (-1:\u211d)) (x-5, y-(-1)) = 0) \u2192 ((x-5) * (27) + (y-(-1)) * (-2) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 - 3 * p.1) ((5:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2) ((5:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 - 3 * p.1 + p.2 ^ 2) ((5:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 - 3 * p.1) ((5:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2) ((5:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 - 3 * p.1) ((5:\u211d), (-1:\u211d))) (x - 5, y - (-1)) = (x-5) * (27)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 - 3 * p.1) = (fun x => 3 * x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2) ((5:\u211d), (-1:\u211d))) (x - 5, y - (-1)) = (y-(-1)) * (-2)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2) = (fun x => x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (-1:\u211d)) (x - 5, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact differentiableAt_snd.pow _\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 - 3 * x + y^2 - c = 0 at the point (5, -1) is (x-5) * 27 + (y-(-1)) * (-2) = 0. The method is to compute the gradient (\u2207) of f(x, y) = 3 * x^2 - 3 * x + y^2 - c at (5, -1), use its dot product with (x-5, y-(-1)), set this equal to 0, and show that this is equivalent to the tangent equation in the conclusion. Introduce the hypothesis: the gradient at (5, -1), dotted with the shift vector (x-5, y-(-1)), is 0. Use the subtraction rule for derivatives to rewrite \u2207(3 * x^2 - 3 * x + y^2 - c) = \u2207(3 * x^2 - 3 * x + y^2) - \u2207(c). Establish a hypothesis breaking \u2207(3 * x^2 - 3 * x + y^2) = \u2207(3 * x^2 - 3 * x) + \u2207(y^2), assuming differentiability for these parts. Substitute the above split and utilize properties of linear maps to expand the expression. Show that the contribution from the x-coordinate is (x-5) * 27: Use function composition to reduce the derivative to one variable. Apply calculus rules (sum, product, power, constant multiples, etc.) to explicitly differentiate 3 * x^2 - 3 * x at x=5. Apply rules of linear maps in the context of taking directional derivatives at the point (5, -1). Demonstrate differentiability of the function 3 * x^2 - 3 * x at the point. Show the y-coordinate contribution is (y-(-1)) * (-2): Recognize the function y^2 is composed analogous to the above. Carry out the differentiation of y^2 at y = -1. Use the linearity of the differential operator and confirm the algebraic manipulation yields the desired result. Prove differentiability at the relevant point. Verify that the derivative of the constant function c is identically zero when applied to any vector. Substitute the explicit results from steps 5-7 into the split from steps 2 and 3, combine, and simplify algebraically. Complete any outstanding differentiability checks for all the component functions used in the gradients."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1 + 3 * p.2 ^ 3 - c) ((-6:\u211d), (6:\u211d)) (x-(-6), y-6) = 0) \u2192 ((x-(-6)) * (448) + (y-6) * (324) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1) ((-6:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3) ((-6:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1 + 3 * p.2 ^ 3) ((-6:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1) ((-6:\u211d), (6:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2 ^ 3) ((-6:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1) ((-6:\u211d), (6:\u211d))) (x - (-6), y - 6) = (x-(-6)) * (448)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3 - p.1 ^ 2 + 4 * p.1) = (fun x => 4 * x ^ 3 - x ^ 2 + 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3) ((-6:\u211d), (6:\u211d))) (x - (-6), y - 6) = (y-6) * (324)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3) = (fun x => 3 * x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (6:\u211d)) (x - (-6), y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 - x^2 + 4 * x + 3 * y^3 - c = 0 at the point (-6, 6) is (x-(-6)) * 448 + (y-6) * 324 = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 4 * x^3 - x^2 + 4 * x + 3 * y^3 - c at the point (-6, 6), then take its dot product with the vector (x-(-6), y-6). Setting this equation to zero gives the tangent, and we show this is equivalent to the target equation. Introduce the hypothesis: the dot product of the gradient at (-6, 6) with (x-(-6), y-6) is zero. Apply the rule that allows differentiation of a function minus a constant, splitting the gradient into two terms: the main function and the constant. State a key intermediate result: the derivative of 4 * x^3 - x^2 + 4 * x + 3 * y^3 at (-6, 6) can be written as the sum of the derivative of its x-part (4 * x^3 - x^2 + 4 * x) and its y-part (3 * y^3), assuming differentiability at the relevant points. Rewrite the original gradient value with this split using properties of linear maps, so it becomes a sum and difference involving the partial derivatives. Show that the derivative of the x-part at (-6, 6) applied to (x-(-6), y-6) is (x-(-6)) * 448: Observe that this function depends only on x, so you can treat it as a composition with the projection onto the first variable. Differentiate the sum 4*x^3 - x^2 + 4*x step by step and evaluate at the point -6. Carefully use linear map properties to get the correct final product form. Check and confirm differentiability of the expressions used. Show that the derivative of 3*y^3 at (-6, 6) applied to (x-(-6), y-6) is (y-6) * 324: Recognize this function depends only on y, allowing reduction to a single-variable case via projection. Differentiate the expression 3*y^3 and evaluate at y = 6. Convert the result into the desired product form. Confirm differentiability at this step. Show that the derivative of the constant c at any point, applied to (x-(-6), y-6), is zero. Substitute the results from steps 5-7 into the main equation to obtain a linear combination in (x-(-6)) and (y-6). Check or justify differentiability for each relevant piece, as required by previous steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 + p.2 ^ 3 - 2 * p.2 ^ 2 + 5 * p.2 - c) ((-4:\u211d), (6:\u211d)) (x-(-4), y-6) = 0) \u2192 ((x-(-4)) * (4) + (y-6) * (89) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1) ((-4:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 - 2 * p.2 ^ 2 + 5 * p.2) ((-4:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 + p.2 ^ 3 - 2 * p.2 ^ 2 + 5 * p.2) ((-4:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1) ((-4:\u211d), (6:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 3 - 2 * p.2 ^ 2 + 5 * p.2) ((-4:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1) ((-4:\u211d), (6:\u211d))) (x - (-4), y - 6) = (x-(-4)) * (4)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1) = (fun x => 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 - 2 * p.2 ^ 2 + 5 * p.2) ((-4:\u211d), (6:\u211d))) (x - (-4), y - 6) = (y-6) * (89)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 - 2 * p.2 ^ 2 + 5 * p.2) = (fun x => x ^ 3 - 2 * x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (6:\u211d)) (x - (-4), y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x + y^3 - 2*y^2 + 5*y - c = 0 at the point (-4,6) is (x-(-4)) * 4 + (y-6) * 89 = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 4 * x + y^3 - 2*y^2 + 5*y - c at the point (-4,6), then take the dot product of this gradient with the shifted positional vector (x-(-4), y-6). Setting this quantity equal to 0 gives the equation of the tangent line, which we want to show is equivalent to (x-(-4)) * 4 + (y-6) * 89 = 0.  Introduce the hypothesis that the dot product of the gradient with (x-(-4), y-6) equals 0. Apply the chain rule for subtraction to split the gradient: \u2207(4*x + y^3 - 2*y^2 + 5*y - c) = \u2207(4*x + y^3 - 2*y^2 + 5*y) - \u2207(c). State a hypothesis splitting \u2207(4*x + y^3 - 2*y^2 + 5*y) further as \u2207(4*x) + \u2207(y^3 - 2*y^2 + 5*y), assuming differentiability at both components. Use this splitting and linearity to express the original gradient as \u2207(4*x) + \u2207(y^3 - 2*y^2 + 5*y) - \u2207(c). Show that \u2207(4*x) at (-4,6) dotted with (x-(-4), y-6) equals (x-(-4)) * 4: Use the composition and single-variable differentiation rules to simplify the calculation of the partial derivative with respect to x. Calculate this derivative and evaluate it at the base point. Use properties of linear maps and some algebraic simplification to arrive at the expression. Justify that 4*x is differentiable at the required point. Show that \u2207(y^3 - 2*y^2 + 5*y) at (-4,6) dotted with (x-(-4), y-6) equals (y-6) * 89: Again, use the splitting to focus on the partial with respect to y. Calculate the required derivative, paying attention to the signs and coefficients. Combine the results using the properties of the linear map and algebraic simplification. Show that y^3 - 2*y^2 + 5*y is differentiable at the required point. Show that the gradient of the constant term \u2207(c) dotted with any vector yields 0. Substitute all expressions back into the initial equation, reducing \u2207(4*x + y^3 - 2*y^2 + 5*y - c)\u00b7(x-(-4), y-6) to (x-(-4)) * 4 + (y-6) * 89 = 0. Show differentiability at each necessary point/function for all involved partial derivatives."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - p.1 ^ 2 + 2 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 - 5 * p.2 - c) ((-1:\u211d), (-2:\u211d)) (x-(-1), y-(-2)) = 0) \u2192 ((x-(-1)) * (5) + (y-(-2)) * (-85) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - p.1 ^ 2) ((-1:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 - 5 * p.2) ((-1:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - p.1 ^ 2 + 2 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 - 5 * p.2) ((-1:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - p.1 ^ 2) ((-1:\u211d), (-2:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 - 5 * p.2) ((-1:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - p.1 ^ 2) ((-1:\u211d), (-2:\u211d))) (x - (-1), y - (-2)) = (x-(-1)) * (5)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - p.1 ^ 2) = (fun x => x ^ 3 - x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 - 5 * p.2) ((-1:\u211d), (-2:\u211d))) (x - (-1), y - (-2)) = (y-(-2)) * (-85)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 - 5 * p.2) = (fun x => 2 * x ^ 4 - x ^ 3 + x ^ 2 - 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (-2:\u211d)) (x - (-1), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 - x^2 + 2y^4 - y^3 + y^2 - 5y - c = 0 at the point (-1, -2) is (x-(-1)) * 5 + (y-(-2)) * (-85) = 0. The method is to calculate the gradient (\u2207) of the function f(x, y) = x^3 - x^2 + 2y^4 - y^3 + y^2 - 5y - c at the point (-1, -2), and then take the dot product with the shifted vector (x-(-1), y-(-2)). Setting this equal to 0 gives the tangent equation, which we then show matches the required form. Introduce the hypothesis: the dot product of the gradient at (-1, -2) with the vector (x-(-1), y-(-2)) is 0. Apply the subtraction rule for derivatives to split \u2207(x^3 - x^2 + 2y^4 - y^3 + y^2 - 5y - c) into the gradient of x^3 - x^2 + 2y^4 - y^3 + y^2 - 5y minus the gradient of the constant c. Define a splitting hypothesis that separates the gradients: Show that the gradient of x^3 - x^2 + 2y^4 - y^3 + y^2 - 5y can be written as the sum of the gradient of x^3 - x^2 (function of x only) plus the gradient of 2y^4 - y^3 + y^2 - 5y (function of y only). Assume differentiability of both parts at (-1, -2). Use the above decomposition and apply linear map properties to write the total gradient as the sum described minus the gradient of c. Compute the gradient of x^3 - x^2 at (-1, -2), evaluated on (x-(-1), y-(-2)), is (x-(-1)) * 5: Argue via function composition and derivative rules that the gradient in x reduces to the 1-variable derivative. Take the derivatives of x^3 and -x^2, evaluate at x = -1, and sum. Use the rules for linear maps and algebraic simplification. Argue differentiability of x^3 - x^2. Compute the gradient of 2y^4 - y^3 + y^2 - 5y at (-1, -2), evaluated on (x-(-1), y-(-2)), is (y-(-2)) * (-85): Use composition/chain rule to reduce to the regular derivative in y. Differentiate each term, evaluate at y = -2. Use algebraic simplification to combine into a single term. Argue differentiability of the y-expression. Show that the gradient of the constant function c at any point, on any vector, is zero. Substitute these results back into the original hypothesis and simplify: reduce the tangent equation to (x-(-1)) * 5 + (y-(-2)) * (-85) = 0. Throughout, justify differentiability of all necessary parts: x^3 - x^2, 2y^4 - y^3 + y^2 - 5y, their sum, and the constant function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 4 + 3 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1 + p.2 ^ 3 - c) ((-4:\u211d), (-1:\u211d)) (x-(-4), y-(-1)) = 0) \u2192 ((x-(-4)) * (-1101) + (y-(-1)) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 4 + 3 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1) ((-4:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3) ((-4:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 4 + 3 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1 + p.2 ^ 3) ((-4:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 4 + 3 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1) ((-4:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 3) ((-4:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 4 + 3 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1) ((-4:\u211d), (-1:\u211d))) (x - (-4), y - (-1)) = (x-(-4)) * (-1101)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 4 + 3 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1) = (fun x => 5 * x ^ 4 + 3 * x ^ 3 - 5 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3) ((-4:\u211d), (-1:\u211d))) (x - (-4), y - (-1)) = (y-(-1)) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3) = (fun x => x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (-1:\u211d)) (x - (-4), y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact differentiableAt_snd.pow _\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^4 + 3 * x^3 - 5 * x^2 - 5 * x + y^3 - c = 0 at the point (-4, -1) is (x-(-4)) * (-1101) + (y-(-1)) * (3) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 5 * x^4 + 3 * x^3 - 5 * x^2 - 5 * x + y^3 - c at the point (-4, -1), then take the dot product of this gradient with the shifted positional vector (x-(-4), y-(-1)). Setting this expression equal to 0 gives the equation of the tangent. We need to show this is equivalent to the desired linear equation. Introduce the hypothesis, which states that the dot product of the gradient at (-4, -1) with the shifted vector (x-(-4), y-(-1)) is zero. Use the derivative of a difference to split \u2207(5 * x^4 + 3 * x^3 - 5 * x^2 - 5 * x + y^3 - c) into \u2207(5 * x^4 + 3 * x^3 - 5 * x^2 - 5 * x + y^3) minus the gradient of a constant. Define an intermediate result splitting the gradient further: show that \u2207(5 * x^4 + 3 * x^3 - 5 * x^2 - 5 * x + y^3) = \u2207(5 * x^4 + 3 * x^3 - 5 * x^2 - 5 * x) + \u2207(y^3). Assume differentiability at the relevant points for each component. Substitute this split into the equation and apply the linearity of linear maps, splitting the function further as needed. Show that the gradient of 5 * x^4 + 3 * x^3 - 5 * x^2 - 5 * x, evaluated at (-4, -1), acting on (x-(-4), y-(-1)), is (x-(-4)) * (-1101). Use function composition to pass differentiation along the first variable only. Compute the partial derivatives of each term in the sum with respect to x, and evaluate at x = -4. Combine all terms, simplify, and factor out (x-(-4)). Prove differentiability of all individual polynomial terms in x. Show that the gradient of y^3, evaluated at (-4, -1), acting on (x-(-4), y-(-1)), is (y-(-1)) * 3. Use function composition to pass differentiation along the second variable only. Compute the partial derivative with respect to y, and evaluate at y = -1. Multiply by (y-(-1)). Prove differentiability of y^3. Show that the gradient of a constant term c is zero at every point. Substitute the previous results into the main equation and simplify to obtain (x-(-4)) * (-1101) + (y-(-1)) * 3 = 0. Prove differentiability for all required components: each summand, the sum, and the overall function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 - 4 * p.2 - c) ((-1:\u211d), (4:\u211d)) (x-(-1), y-4) = 0) \u2192 ((x-(-1)) * (-8) - (y-4) * (4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2) ((-1:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2) ((-1:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 - 4 * p.2) ((-1:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2) ((-1:\u211d), (4:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2) ((-1:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2) ((-1:\u211d), (4:\u211d))) (x - (-1), y - 4) = (x-(-1)) * (-8)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2) = (fun x => 4 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2) ((-1:\u211d), (4:\u211d))) (x - (-1), y - 4) = (y-4) * (4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2) = (fun x => 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (4:\u211d)) (x - (-1), y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^2 - 4 * y - c = 0 at the point (-1, 4) is (x-(-1)) * (-8) - (y-4) * (4) = 0. The idea is to compute the gradient (\u2207) of f(x, y) = 4x^2 - 4y - c at the point (-1, 4), take the dot product with the shifted position vector (x-(-1), y-4), set the result to zero, and show this is equivalent to (x-(-1)) * (-8) - (y-4) * (4) = 0.  Introduce the hypothesis: the dot product of the gradient at the point with the shifted position vector is 0. Apply the derivative rule of subtraction to split the gradient: \u2207(4x^2 - 4y - c) = \u2207(4x^2 - 4y) - \u2207(c). Show that \u2207(4x^2 - 4y) can be split as \u2207(4x^2) - \u2207(4y), assuming differentiability at the point for each term. Use this splitting to rewrite the overall gradient as a subtraction of gradients at the relevant point. Compute the gradient of 4x^2 at (-1, 4) and show its application to the shifted vector yields (x-(-1)) * (-8). Express 4x^2 as a composition and apply the rules for the derivative of the composition. Compute the derivative with respect to x and verify the linear map application. Use algebraic simplification to show equality. Prove the differentiability of 4x^2 at the required point. Compute the gradient of 4y at (-1, 4) and show its application to the shifted vector yields (y-4) * (4). Express 4y as a composition and apply the rules for the derivative of the composition. Compute the derivative with respect to y and verify the linear map application. Use algebraic simplification to show equality. Prove the differentiability of 4y at the required point. Show that the gradient of the constant term c at the point, applied to the shifted vector, is 0. Substitute the computations from steps 5\u20137 into your hypothesis, and use algebraic simplification to conclude the desired equality. Make sure differentiability is established for all relevant terms at the required point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 + 2 * p.1 ^ 2 + 2 * p.2 ^ 4 + p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2 - c) ((6:\u211d), (3:\u211d)) (x-6, y-3) = 0) \u2192 ((x-6) * (240) + (y-3) * (229) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3 + 2 * p.1 ^ 2) ((6:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 4 + p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) ((6:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 + 2 * p.1 ^ 2 + 2 * p.2 ^ 4 + p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) ((6:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3 + 2 * p.1 ^ 2) ((6:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 4 + p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) ((6:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3 + 2 * p.1 ^ 2) ((6:\u211d), (3:\u211d))) (x - 6, y - 3) = (x-6) * (240)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3 + 2 * p.1 ^ 2) = (fun x => 2 * x ^ 3 + 2 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 4 + p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) ((6:\u211d), (3:\u211d))) (x - 6, y - 3) = (y-3) * (229)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 4 + p.2 ^ 3 - 3 * p.2 ^ 2 + 4 * p.2) = (fun x => 2 * x ^ 4 + x ^ 3 - 3 * x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (3:\u211d)) (x - 6, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^3 + 2 * x^2 + 2 * y^4 + y^3 - 3 * y^2 + 4 * y - c = 0 at the point (6,3) is (x-6) * 240 + (y-3) * 229 = 0. The general idea is to compute the gradient (\u2207) of the function f(x, y) = 2 * x^3 + 2 * x^2 + 2 * y^4 + y^3 - 3 * y^2 + 4 * y - c at the point (6, 3), then take its dot product with the directional vector (x-6, y-3). Setting this equal to 0 gives the tangent equation, and we must show this matches the given form.  Introduce the hypothesis, where the directional derivative of f at (6, 3) along (x-6, y-3) is 0. Apply the subtraction rule for the derivative to split \u2207(2 * x^3 + 2 * x^2 + 2 * y^4 + y^3 - 3 * y^2 + 4 * y - c) into \u2207(2 * x^3 + 2 * x^2 + 2 * y^4 + y^3 - 3 * y^2 + 4 * y) minus \u2207(c). Define a hypothesis to further split \u2207(2 * x^3 + 2 * x^2 + 2 * y^4 + y^3 - 3 * y^2 + 4 * y) into the sum \u2207(2 * x^3 + 2 * x^2) in x and \u2207(2 * y^4 + y^3 - 3 * y^2 + 4 * y) in y, assuming differentiability for each summand at (6, 3). Substitute this split into the directional derivative, applying linearity of the derivative and of the map, to write the original expression as the sum of the parts in x, y, and the constant c. Compute the x-component of the directional derivative: Re-express as a composition in x, using the chain and product rules to reduce to a single-variable derivative. Perform the actual derivative calculation with respect to x at x = 6. Rewrite and simplify using properties of linear maps and algebraic manipulations. Ensure the differentiability conditions for the x-part of the function are checked. Compute the y-component of the directional derivative: Re-express as a composition in y, similarly using derivative rules. Perform the derivative calculation with respect to y at y = 3. Again, simplify using linear map structure and algebra. Address and verify differentiability for the y-part of the function. Show that the derivative with respect to a constant c is zero for any direction (x-6, y-3). Substitute the explicit calculations for both x- and y-components and the constant into the hypothesis and simplify to obtain (x-6)*240 + (y-3)*229 = 0. Throughout, check and note all differentiability conditions for each part of the split function, composing or adding where needed.  Thus, the structure revolves around splitting the function by the coordinate directions, computing the gradient entries, and evaluating everything at the fixed point, matching the resulting equation to the given tangent."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 - p.1 ^ 2 - p.2 ^ 4 - 2 * p.2 ^ 3 + p.2 ^ 2 + p.2 - c) ((4:\u211d), (0:\u211d)) (x-4, y-0) = 0) \u2192 ((x-4) * (88) - (y-0) * (-1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3 - p.1 ^ 2) ((4:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 3 - p.2 ^ 2 - p.2) ((4:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 - p.1 ^ 2 - p.2 ^ 4 - 2 * p.2 ^ 3 + p.2 ^ 2 + p.2) ((4:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3 - p.1 ^ 2) ((4:\u211d), (0:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 3 - p.2 ^ 2 - p.2) ((4:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3 - p.1 ^ 2) ((4:\u211d), (0:\u211d))) (x - 4, y - 0) = (x-4) * (88)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3 - p.1 ^ 2) = (fun x => 2 * x ^ 3 - x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 3 - p.2 ^ 2 - p.2) ((4:\u211d), (0:\u211d))) (x - 4, y - 0) = (y-0) * (-1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 2 * p.2 ^ 3 - p.2 ^ 2 - p.2) = (fun x => x ^ 4 + 2 * x ^ 3 - x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (0:\u211d)) (x - 4, y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^3 - x^2 - y^4 - 2 * y^3 + y^2 + y - c = 0 at the point (4, 0) is (x-4) * 88 - (y-0) * (-1) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 2 * x^3 - x^2 - y^4 - 2 * y^3 + y^2 + y - c at the point (4, 0), then take the dot product of this gradient with the shifted vector (x-4, y-0). Setting this equal to zero gives the tangent line, and we want to show this is equivalent to (x-4) * 88 - (y-0) * (-1) = 0.  Introduce the hypothesis, which establishes that the dot product of the gradient at (4,0) with the shifted vector (x-4, y-0) is zero. Use a derivative rule to rewrite the gradient of the entire function as \u2207(2 * x^3 - x^2 - y^4 - 2 * y^3 + y^2 + y) minus the gradient of the constant c. Define an intermediate result splitting the gradient of 2 * x^3 - x^2 - y^4 - 2 * y^3 + y^2 + y into \u2207(2 * x^3 - x^2) - \u2207(y^4 + 2 * y^3 - y^2 - y), provided differentiability at the relevant parts. Assume differentiability at (2 * x^3 - x^2) and (y^4 + 2 * y^3 - y^2 - y). Express the function as a difference of functions in x and y only, to use the relevant properties for the gradient split. Use this decomposition and properties of linear maps to write the entire gradient as a suitable sum/difference acting on the vector (x-4, y-0). Show that the directional derivative of the x-component at (4,0) applied to (x-4, y-0) yields (x-4) * 88. Use composition and the chain rule to reduce the gradient to an ordinary derivative. Calculate the derivative with respect to x of 2 * x^3 - x^2 at x = 4. Use linear and algebraic manipulation to complete the calculation. Argue the differentiability of 2 * x^3 - x^2 at (4,0). Show that the directional derivative of the y-component at (4,0) applied to (x-4, y-0) yields (y-0) * (-1). Use composition and chain rule for the y-component. Calculate the derivative of y^4 + 2 * y^3 - y^2 - y with respect to y at y = 0. Use basic properties of linear maps to finish the computation. Argue differentiability of y^4 + 2 * y^3 - y^2 - y at (4, 0). Show that the gradient (directional derivative) with respect to the constant c is 0 in any direction. Substitute the intermediate results into the equation and simplify to obtain the desired tangent line equation. Justify at each step that all required differentiability and splitting properties hold for the functions involved."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 4 - 2 * p.1 ^ 3 + 2 * p.1 ^ 2 + 4 * p.2 - c) ((-1:\u211d), (2:\u211d)) (x-(-1), y-2) = 0) \u2192 ((x-(-1)) * (-18) + (y-2) * (4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 4 - 2 * p.1 ^ 3 + 2 * p.1 ^ 2) ((-1:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2) ((-1:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 4 - 2 * p.1 ^ 3 + 2 * p.1 ^ 2 + 4 * p.2) ((-1:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 4 - 2 * p.1 ^ 3 + 2 * p.1 ^ 2) ((-1:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2) ((-1:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 4 - 2 * p.1 ^ 3 + 2 * p.1 ^ 2) ((-1:\u211d), (2:\u211d))) (x - (-1), y - 2) = (x-(-1)) * (-18)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 4 - 2 * p.1 ^ 3 + 2 * p.1 ^ 2) = (fun x => 2 * x ^ 4 - 2 * x ^ 3 + 2 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2) ((-1:\u211d), (2:\u211d))) (x - (-1), y - 2) = (y-2) * (4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2) = (fun x => 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (2:\u211d)) (x - (-1), y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^4 - 2 * x^3 + 2 * x^2 + 4 * y - c = 0 at the point (-1,2) is (x-(-1)) * (-18) + (y-2) * (4) = 0. The approach is to compute the gradient (\u2207) of the function f(x,y) = 2 * x^4 - 2 * x^3 + 2 * x^2 + 4 * y - c at the point (-1,2), then evaluate the dot product of the gradient with the vector of displacements (x-(-1), y-2), set it to 0, and show that the equation simplifies to the required tangent line.  Introduce the hypothesis that the dot product of the gradient with the shifted positional vector is equal to 0. Apply the rule for the derivative of a subtraction to separate the constant term: \u2207(2 * x^4 - 2 * x^3 + 2 * x^2 + 4 * y - c) as \u2207(2 * x^4 - 2 * x^3 + 2 * x^2 + 4 * y) - \u2207(c). Show that \u2207(2 * x^4 - 2 * x^3 + 2 * x^2 + 4 * y) splits as \u2207(2 * x^4 - 2 * x^3 + 2 * x^2) + \u2207(4 * y), given the differentiability of the components. Use the previous hypothesis and the properties of linear maps to split the expression for the gradient at the point and vector: as above. Prove that the gradient of (2 * x^4 - 2 * x^3 + 2 * x^2) at (-1,2), evaluated on the vector (x-(-1), y-2), is (x-(-1)) * (-18). Identify the component function as a composition so that the gradient in one variable becomes the ordinary derivative. Compute the partial derivative with respect to x. Show how the dot product of this gradient with (x-(-1), y-2) yields the desired linear term. Confirm differentiability of 2 * x^4 - 2 * x^3 + 2 * x^2. Prove that the gradient of 4*y at (-1,2), evaluated on the vector (x-(-1), y-2), is (y-2) * 4. Likewise, interpret as a composition and link with the ordinary derivative. Compute the derivative with respect to y. Demonstrate the linear map result. Confirm differentiability of 4*y. Prove that the gradient of the constant c at (-1,2), evaluated on (x-(-1), y-2), is 0. Use the above results to combine and simplify the equation for the tangent, showing it has the desired form. Justify differentiability at each step for the necessary functions: \u2207(2 * x^4 - 2 * x^3 + 2 * x^2), \u2207(4 * y), their sum, and for the constant."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 - 5 * p.1 ^ 2 - p.1 - 5 * p.2 ^ 4 - 2 * p.2 ^ 3 + p.2 ^ 2 - 5 * p.2 - c) ((4:\u211d), (2:\u211d)) (x-4, y-2) = 0) \u2192 ((x-4) * (55) - (y-2) * (185) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3 - 5 * p.1 ^ 2 - p.1) ((4:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 4 + 2 * p.2 ^ 3 - p.2 ^ 2 + 5 * p.2) ((4:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 - 5 * p.1 ^ 2 - p.1 - 5 * p.2 ^ 4 - 2 * p.2 ^ 3 + p.2 ^ 2 - 5 * p.2) ((4:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3 - 5 * p.1 ^ 2 - p.1) ((4:\u211d), (2:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 4 + 2 * p.2 ^ 3 - p.2 ^ 2 + 5 * p.2) ((4:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3 - 5 * p.1 ^ 2 - p.1) ((4:\u211d), (2:\u211d))) (x - 4, y - 2) = (x-4) * (55)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3 - 5 * p.1 ^ 2 - p.1) = (fun x => 2 * x ^ 3 - 5 * x ^ 2 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 4 + 2 * p.2 ^ 3 - p.2 ^ 2 + 5 * p.2) ((4:\u211d), (2:\u211d))) (x - 4, y - 2) = (y-2) * (185)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 4 + 2 * p.2 ^ 3 - p.2 ^ 2 + 5 * p.2) = (fun x => 5 * x ^ 4 + 2 * x ^ 3 - x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (2:\u211d)) (x - 4, y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve 2x\u00b3 - 5x\u00b2 - x - 5y\u2074 - 2y\u00b3 + y\u00b2 - 5y - c = 0 at the point (4,2) is (x-4) * 55 - (y-2) * 185 = 0. The main idea is to compute the gradient (\u2207) of the function f(x,y) = 2x\u00b3 - 5x\u00b2 - x - 5y\u2074 - 2y\u00b3 + y\u00b2 - 5y - c at the specific point (4,2), then take the dot product of this gradient with the shifted vector (x-4, y-2), set it to zero, and simplify to match the required form.  Introduce the hypothesis, which states that the dot product of the gradient at (4,2) with the vector (x-4, y-2) is 0. Apply the derivative rule for subtraction to split the total derivative into the difference of two terms: \u2207(2x\u00b3 - 5x\u00b2 - x - 5y\u2074 - 2y\u00b3 + y\u00b2 - 5y - c) = \u2207(2x\u00b3 - 5x\u00b2 - x - 5y\u2074 - 2y\u00b3 + y\u00b2 - 5y) - \u2207(c) Define a hypothesis to further split the first part as: \u2207(2x\u00b3 - 5x\u00b2 - x - 5y\u2074 - 2y\u00b3 + y\u00b2 - 5y) = \u2207(2x\u00b3 - 5x\u00b2 - x) - \u2207(5y\u2074 + 2y\u00b3 - y\u00b2 + 5y), assuming differentiability of (2x\u00b3 - 5x\u00b2 - x) and (5y\u2074 + 2y\u00b3 - y\u00b2 + 5y) at (4,2). Use properties of linear maps to evaluate the tangent equation as the result of (gradient at (4,2)) dot (x-4, y-2), composing all the above splits. Show that \u2207(2x\u00b3 - 5x\u00b2 - x) evaluated at (4,2) and applied to (x-4, y-2) simplifies to (x-4) * 55: Re-express the partial function as a composition to isolate dependence on x. Expand and compute the x-derivative explicitly, using the standard differentiation rules for powers and linearity. Use the structure of the linear map to connect the gradient value and the action on the vector (x-4, y-2). Verify that 2x\u00b3 - 5x\u00b2 - x is differentiable at x=4. Show that \u2207(5y\u2074 + 2y\u00b3 - y\u00b2 + 5y) at (4,2) acting on (x-4, y-2) gives (y-2) * 185: Re-express as a function of only y via composition. Compute the y-derivative in detail, using power rules, product/chain rules, etc. Use the linear map\u2019s application to relate the resulting value to the (x-4, y-2) vector. Check differentiability of 5y\u2074 + 2y\u00b3 - y\u00b2 + 5y at y=2. Show that the derivative of the constant c term in any direction is zero. Substitute the above results into the tangent equation, simplifying to verify it matches the desired form. Justify all differentiability assumptions used for the decompositions and for the applications of the properties of the gradient for the split pieces (x part, y part, and the full function)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 4 - 2 * p.1 + 3 * p.2 ^ 4 - c) ((-6:\u211d), (1:\u211d)) (x-(-6), y-1) = 0) \u2192 ((x-(-6)) * (-1730) + (y-1) * (12) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 4 - 2 * p.1) ((-6:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 4) ((-6:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 4 - 2 * p.1 + 3 * p.2 ^ 4) ((-6:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 4 - 2 * p.1) ((-6:\u211d), (1:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2 ^ 4) ((-6:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 4 - 2 * p.1) ((-6:\u211d), (1:\u211d))) (x - (-6), y - 1) = (x-(-6)) * (-1730)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 4 - 2 * p.1) = (fun x => 2 * x ^ 4 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 4) ((-6:\u211d), (1:\u211d))) (x - (-6), y - 1) = (y-1) * (12)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 4) = (fun x => 3 * x ^ 4) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (1:\u211d)) (x - (-6), y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^4 - 2 * x + 3 * y^4 - c = 0 at the point (-6,1) is (x-(-6)) * (-1730) + (y-1) * (12) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 2 * x^4 - 2 * x + 3 * y^4 - c at the point (-6, 1), then take the dot product with the vector (x-(-6), y-1) (which is the difference from the point of tangency). Setting this equation equal to 0 gives the tangent equation, which we have to show matches the desired form. Introduce the hypothesis, which asserts that the dot product of the gradient at the point (-6, 1) with the vector (x-(-6), y-1) equals 0. Use the rule for the derivative of a difference to split the fderiv into the sum/difference of fderiv's, separating off the constant. Define a hypothesis that splits the fderiv of the sum 2 * x^4 - 2 * x + 3 * y^4 into the sum of fderiv's of 2 * x^4 - 2 * x and 3 * y^4, under the assumption that both are differentiable at the required point. Use the previous splitting and the linearity properties of the fderiv operator to rewrite everything in terms of these pieces. Show that the fderiv (gradient) of 2 * x^4 - 2 * x at (-6, 1), evaluated on (x-(-6), y-1), is (x-(-6)) * (-1730). Recognize that this function only depends on x, so use a composition rule to simplify. Compute the derivative with respect to x at x = -6. Argue through linear maps that the result is proportional to (x-(-6)), and simplify the expression. Confirm differentiability of this function at the specified point. Show that the fderiv of 3 * y^4 at (-6, 1), applied to (x-(-6), y-1), gives (y-1) * 12. Recognize that this function only depends on y, so a similar composition rule applies. Compute the derivative with respect to y at y = 1. Argue through linear maps that the result is proportional to (y-1), and simplify the expression. Show differentiability at the specified point. Show that the fderiv of the constant c is 0, so when applied to the shift vector it gives 0. Substitute all those computations back into the main equation, reduce, and show that you get (x-(-6)) * (-1730) + (y-1) * (12) = 0. Justify the differentiability of all required sub-expressions and sums at the given point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 + 3 * p.1 ^ 2 + 4 * p.2 ^ 2 - c) ((-3:\u211d), (6:\u211d)) (x-(-3), y-6) = 0) \u2192 ((x-(-3)) * (-126) + (y-6) * (48) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 + 3 * p.1 ^ 2) ((-3:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2) ((-3:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 + 3 * p.1 ^ 2 + 4 * p.2 ^ 2) ((-3:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 + 3 * p.1 ^ 2) ((-3:\u211d), (6:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 2) ((-3:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 + 3 * p.1 ^ 2) ((-3:\u211d), (6:\u211d))) (x - (-3), y - 6) = (x-(-3)) * (-126)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 + 3 * p.1 ^ 2) = (fun x => x ^ 4 + 3 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2) ((-3:\u211d), (6:\u211d))) (x - (-3), y - 6) = (y-6) * (48)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2) = (fun x => 4 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (6:\u211d)) (x - (-3), y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 + 3x^2 + 4y^2 - c = 0 at the point (-3,6) is (x-(-3)) * (-126) + (y-6) * (48) = 0. The method is to compute the gradient (\u2207) of f(x, y) = x^4 + 3x^2 + 4y^2 - c at (-3,6), then take the dot product of this gradient with the vector (x-(-3), y-6). Setting this equal to 0 gives the tangent's equation, which we verify is equivalent to the given form. Introduce the hypothesis, which is the statement that the dot product of the gradient at the point with the difference vector (x-(-3), y-6) equals zero. Apply the differentiation rule for subtraction to break up the gradient of x^4 + 3x^2 + 4y^2 - c as the sum/combination of gradients of the function without the constant term and the constant term separately. Define a hypothesis to split the gradient of x^4 + 3x^2 + 4y^2 into the sum of the gradient of x^4 + 3x^2 (a function of x only) and 4y^2 (a function of y only), assuming both are differentiable at the point. Using the result of this split and the properties of linear maps, rewrite the total derivative as the sum/difference of the relevant pieces. Compute explicitly that the gradient of x^4 + 3x^2 at x=-3, applied to (x-(-3), y-6), simplifies to (x-(-3)) * (-126): Use the composition of functions and properties of derivatives to reduce the partial derivative in x to a single-variable calculus computation. Find the required derivatives with respect to x, evaluate at x=-3, and compute the outcome. Apply the structure of continuous linear maps and use simplification to justify the calculation. Show differentiability of x^4 + 3x^2 at the point. Compute explicitly that the gradient of 4y^2 at y=6, applied to (x-(-3), y-6), gives (y-6)*48: Use function composition and the differentiation rules for y to compute the necessary derivative. Evaluate the relevant derivative at y=6 and justify the result. Use properties of linear maps for further simplification. Show differentiability of 4y^2 at the point. Show that the gradient of the constant c is zero, so its contribution vanishes in the directional derivative. Substitute all previous results into the original equation, simplify, and show that the left-hand side is indeed (x-(-3)) * (-126) + (y-6) * (48). In closing steps, justify all differentiability and structural claims used for the various component functions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 - 4 * p.1 + p.2 ^ 4 + 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 3 * p.2 - c) ((3:\u211d), (-4:\u211d)) (x-3, y-(-4)) = 0) \u2192 ((x-3) * (20) + (y-(-4)) * (-37) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2 - 4 * p.1) ((3:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 3 * p.2) ((3:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 - 4 * p.1 + p.2 ^ 4 + 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 3 * p.2) ((3:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2 - 4 * p.1) ((3:\u211d), (-4:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 3 * p.2) ((3:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2 - 4 * p.1) ((3:\u211d), (-4:\u211d))) (x - 3, y - (-4)) = (x-3) * (20)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2 - 4 * p.1) = (fun x => 4 * x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 3 * p.2) ((3:\u211d), (-4:\u211d))) (x - 3, y - (-4)) = (y-(-4)) * (-37)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 3 * p.2) = (fun x => x ^ 4 + 4 * x ^ 3 - 3 * x ^ 2 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (-4:\u211d)) (x - 3, y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^2 - 4 * x + y^4 + 4 * y^3 - 3 * y^2 + 3 * y - c = 0 at the point (3, -4) is (x-3) * 20 + (y-(-4)) * (-37) = 0. The approach is to compute the gradient (\u2207) of the function f(x,y) = 4 * x^2 - 4 * x + y^4 + 4 * y^3 - 3 * y^2 + 3 * y - c at (3, -4), then evaluate its dot product with the vector (x-3, y-(-4)), and set this equal to 0 to obtain the tangent equation.  Introduce the hypothesis, which posits that the dot product of the gradient and the shifted positional vector ((x-3, y-(-4))) is 0. Apply the derivative rule for subtraction to separate the term involving the constant c: \u2207(4 * x^2 - 4 * x + y^4 + 4 * y^3 - 3 * y^2 + 3 * y - c) = \u2207(rest) - \u2207(c) Define a hypothesis to split the gradient of the remaining terms as a sum: \u2207(4 * x^2 - 4 * x + y^4 + 4 * y^3 - 3 * y^2 + 3 * y) = \u2207(4 * x^2 - 4 * x) + \u2207(y^4 + 4 * y^3 - 3 * y^2 + 3 * y) Assume differentiability of both parts at (3, -4). Use the previous step together with linear map properties to express the total gradient as \u2207(4 * x^2 - 4 * x) + \u2207(y^4 + 4 * y^3 - 3 * y^2 + 3 * y) - \u2207(c). Show that applying \u2207(4 * x^2 - 4 * x) at (3, -4) to (x-3, y-(-4)) yields (x-3) * 20. Identify that this part depends only on x, so the y-derivative is zero. Use chain rule and compute \u2202/\u2202x (4x^2 - 4x) at x = 3. Justify simplification using properties of linear maps and arithmetic. Prove the differentiability of 4 * x^2 - 4 * x at x = 3. Show that applying \u2207(y^4 + 4 * y^3 - 3 * y^2 + 3 * y) at (3, -4) to (x-3, y-(-4)) yields (y-(-4)) * (-37). Identify that this part depends only on y, so the x-derivative is zero. Use the chain rule and compute \u2202/\u2202y (y^4 + 4y^3 - 3y^2 + 3y) at y = -4. Justify simplification using properties of linear maps and arithmetic. Prove the differentiability of this function of y at y = -4. Show that the gradient of the constant c applied at any point gives 0 when evaluated on any vector. Substitute in all the expressions from steps 5, 6, and 7, and combine them to simplify the tangent plane equation. Supply differentiation proofs for each component involved and argument for total differentiability at the given point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 + p.2 ^ 4 - 3 * p.2 ^ 3 - 3 * p.2 ^ 2 - c) ((-2:\u211d), (-3:\u211d)) (x-(-2), y-(-3)) = 0) \u2192 ((x-(-2)) * (2) + (y-(-3)) * (-171) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((-2:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 - 3 * p.2 ^ 3 - 3 * p.2 ^ 2) ((-2:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 + p.2 ^ 4 - 3 * p.2 ^ 3 - 3 * p.2 ^ 2) ((-2:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((-2:\u211d), (-3:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 - 3 * p.2 ^ 3 - 3 * p.2 ^ 2) ((-2:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((-2:\u211d), (-3:\u211d))) (x - (-2), y - (-3)) = (x-(-2)) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 - 3 * p.2 ^ 3 - 3 * p.2 ^ 2) ((-2:\u211d), (-3:\u211d))) (x - (-2), y - (-3)) = (y-(-3)) * (-171)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 - 3 * p.2 ^ 3 - 3 * p.2 ^ 2) = (fun x => x ^ 4 - 3 * x ^ 3 - 3 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (-3:\u211d)) (x - (-2), y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2*x + y^4 - 3*y^3 - 3*y^2 - c = 0 at the point (-2, -3) is (x-(-2))*2 + (y-(-3))*(-171) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 2*x + y^4 - 3*y^3 - 3*y^2 - c at the point (-2, -3), and then take the dot product of this gradient with the vector (x-(-2), y-(-3)). Setting that equal to 0 yields the equation of the tangent, which we must show is equivalent to (x-(-2))*2 + (y-(-3))*(-171) = 0.  Introduce the hypothesis, which is the dot product of the gradient (evaluated at (-2, -3)) with the shifted position vector equals zero. Apply the derivative rule for subtraction to split the derivative: \u2207(2*x + y^4 - 3*y^3 - 3*y^2 - c) = \u2207(2*x + y^4 - 3*y^3 - 3*y^2) - \u2207(c). Define a hypothesis that splits the function further as \u2207(2*x + y^4 - 3*y^3 - 3*y^2) = \u2207(2*x) + \u2207(y^4 - 3*y^3 - 3*y^2). This assumes differentiability at the relevant points. Use this splitting and rules for linear maps to write the gradient as the sum and differences of the gradients of these terms, and apply them to the shifted vector. Show that \u2207(2*x) at (-2, -3), applied to (x-(-2), y-(-3)), equals (x-(-2))*2. Express the function as a composition and apply the chain rule for derivatives. Use the rules for differentiating scalar multiples and coordinate projection. Apply the resulting linear map to the shifted vector and simplify. Justify differentiability of 2*x. Show that \u2207(y^4 - 3*y^3 - 3*y^2) at (-2, -3), applied to (x-(-2), y-(-3)), equals (y-(-3))*(-171). Express the function in terms of coordinate projection and composition. Use the relevant rules for differentiating powers and scalar multiples, and sum/difference rules. Apply the resulting linear map to the shifted vector and simplify the coefficients. Justify differentiability of y^4 - 3*y^3 - 3*y^2. Show that \u2207(c) at (-2, -3), applied to (x-(-2), y-(-3)), equals 0, since c is constant. Substitute these results back into the result from step 4 to simplify the total expression. Conclude by checking differentiability of all relevant terms (as required for the earlier steps)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 + 2 * p.1 + 3 * p.2 ^ 4 + 3 * p.2 ^ 3 - 2 * p.2 ^ 2 - c) ((-5:\u211d), (5:\u211d)) (x-(-5), y-5) = 0) \u2192 ((x-(-5)) * (-8) + (y-5) * (1705) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((-5:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 4 + 3 * p.2 ^ 3 - 2 * p.2 ^ 2) ((-5:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 + 2 * p.1 + 3 * p.2 ^ 4 + 3 * p.2 ^ 3 - 2 * p.2 ^ 2) ((-5:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((-5:\u211d), (5:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2 ^ 4 + 3 * p.2 ^ 3 - 2 * p.2 ^ 2) ((-5:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((-5:\u211d), (5:\u211d))) (x - (-5), y - 5) = (x-(-5)) * (-8)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 + 2 * p.1) = (fun x => x ^ 2 + 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 4 + 3 * p.2 ^ 3 - 2 * p.2 ^ 2) ((-5:\u211d), (5:\u211d))) (x - (-5), y - 5) = (y-5) * (1705)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 4 + 3 * p.2 ^ 3 - 2 * p.2 ^ 2) = (fun x => 3 * x ^ 4 + 3 * x ^ 3 - 2 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (5:\u211d)) (x - (-5), y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 + 2x + 3y^4 + 3y^3 - 2y^2 - c = 0 at the point (-5,5) is (x-(-5)) * (-8) + (y-5) * (1705) = 0. The idea is to calculate the gradient (\u2207) of the function f(x,y) = x^2 + 2x + 3y^4 + 3y^3 - 2y^2 - c at the point (-5,5), then take the dot product of this gradient with the shifted vector (x-(-5), y-5). Setting this equal to 0 gives the tangent equation, and we must show this is equivalent to the stated linear equation. Introduce the hypothesis that the dot product of the gradient with (x-(-5), y-5) is 0. Use the rule for the derivative of a difference to split \u2207(x^2 + 2x + 3y^4 + 3y^3 - 2y^2 - c) = \u2207(x^2 + 2x + 3y^4 + 3y^3 - 2y^2) - \u2207(c). State a hypothesis splitting the gradient further: \u2207(x^2 + 2x + 3y^4 + 3y^3 - 2y^2) = \u2207(x^2 + 2x) + \u2207(3y^4 + 3y^3 - 2y^2). Here, assume differentiability at (x^2 + 2x) and (3y^4 + 3y^3 - 2y^2). Use this to express the gradient at (-5,5) in terms of the two parts and \u2207(c). Show that \u2207(x^2 + 2x), evaluated at (-5,5) and applied to (x-(-5), y-5), yields (x-(-5)) * (-8): Rewrite x^2 + 2x as a function of one variable composed with the projection onto the first coordinate for differentiation. Compute the simple derivative of x \u21a6 x^2 + 2x at x = -5. Verify using linear map rules, simplification, and plug in the specific values. Confirm differentiability of x^2 + 2x at the relevant point. Show that \u2207(3y^4 + 3y^3 - 2y^2), evaluated at (-5,5) and applied to (x-(-5), y-5), yields (y-5) * (1705): Rewrite 3y^4 + 3y^3 - 2y^2 as a function of one variable composed with projection onto the second coordinate. Compute the simple derivative with respect to y at y = 5. Use linear map properties, simplification, and substitute the values. Confirm differentiability for this function. Show that the gradient of the constant term c evaluated at any point and applied to the difference vector yields 0. Substitute in the results from steps 5\u20137 to rewrite the original equation in terms of the numbers (-8) and 1705, corresponding to the derivatives at the point. Prove differentiability for all the necessary components: \u2207(x^2 + 2x), \u2207(3y^4 + 3y^3 - 2y^2), their sum, the overall function, and the constant term."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 + 2 * p.1 ^ 2 - 2 * p.1 - 5 * p.2 ^ 3 + 5 * p.2 ^ 2 + 2 * p.2 - c) ((2:\u211d), (3:\u211d)) (x-2, y-3) = 0) \u2192 ((x-2) * (18) - (y-3) * (103) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 + 2 * p.1 ^ 2 - 2 * p.1) ((2:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3 - 5 * p.2 ^ 2 - 2 * p.2) ((2:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 + 2 * p.1 ^ 2 - 2 * p.1 - 5 * p.2 ^ 3 + 5 * p.2 ^ 2 + 2 * p.2) ((2:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 + 2 * p.1 ^ 2 - 2 * p.1) ((2:\u211d), (3:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 3 - 5 * p.2 ^ 2 - 2 * p.2) ((2:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 + 2 * p.1 ^ 2 - 2 * p.1) ((2:\u211d), (3:\u211d))) (x - 2, y - 3) = (x-2) * (18)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 + 2 * p.1 ^ 2 - 2 * p.1) = (fun x => x ^ 3 + 2 * x ^ 2 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3 - 5 * p.2 ^ 2 - 2 * p.2) ((2:\u211d), (3:\u211d))) (x - 2, y - 3) = (y-3) * (103)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3 - 5 * p.2 ^ 2 - 2 * p.2) = (fun x => 5 * x ^ 3 - 5 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (3:\u211d)) (x - 2, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 + 2x^2 - 2x - 5y^3 + 5y^2 + 2y - c = 0 at the point (2, 3) is (x-2) * 18 - (y-3) * 103 = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = x^3 + 2x^2 - 2x - 5y^3 + 5y^2 + 2y - c at the point (2, 3), take the dot product with the vector (x-2, y-3), and equate that to 0 to obtain the equation for the tangent line. Introduce the hypothesis: that the dot product of the gradient at (2, 3) with the shifted position vector (x-2, y-3) is 0. Use a rule to split the total derivative of f(x, y) - c into f(x, y) and the constant part separately. Formulate a hypothesis that decomposes the derivative of the main expression into the derivative with respect to x and the derivative with respect to y, using differentiability assumptions on each part. Apply this decomposition to rewrite the gradient of f(x, y) - c as the difference between the gradients with respect to x and y components and the constant part. Show that the x-component part, evaluated at (2,3) and applied to (x-2, y-3), yields (x-2) * 18. Use composition rules to rewrite the function as a function of x applied to the first coordinate. Apply rules for computing derivatives of sums, products, and powers to obtain the desired coefficient. Use rules of linear maps to simplify the action on the pair (x-2, y-3). Confirm the differentiability of x^3 + 2x^2 - 2x. Show the y-component part, evaluated at (2,3) and applied to (x-2, y-3), yields (y-3) * 103. Again, use function composition to treat the y-component as a function of y mapping to the second coordinate. Apply derivative formulas for sums, scalar multiples, and powers to get the coefficient. Use linear map properties to confirm the explicit form after evaluation. Confirm the differentiability of 5y^3 - 5y^2 - 2y. Show that the fderiv of the constant part (c) applied to (x-2, y-3) is zero. Substitute the results of steps 5\u20137 into the original equation and simplify it, checking that it matches the goal. Provide differentiability justification for all sub-expressions as required by the rewrite and computation steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 - 2 * p.1 + 5 * p.2 ^ 2 - p.2 - c) ((4:\u211d), (-3:\u211d)) (x-4, y-(-3)) = 0) \u2192 ((x-4) * (22) + (y-(-3)) * (-31) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2 - p.2) ((4:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 - 2 * p.1 + 5 * p.2 ^ 2 - p.2) ((4:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (-3:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 2 - p.2) ((4:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (-3:\u211d))) (x - 4, y - (-3)) = (x-4) * (22)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 - 2 * p.1) = (fun x => 3 * x ^ 2 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2 - p.2) ((4:\u211d), (-3:\u211d))) (x - 4, y - (-3)) = (y-(-3)) * (-31)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2 - p.2) = (fun x => 5 * x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (-3:\u211d)) (x - 4, y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 - 2 * x + 5 * y^2 - y - c = 0 at the point (4, -3) is (x-4) * 22 + (y-(-3)) * (-31) = 0. The plan is to compute the gradient (\u2207) of f(x, y) = 3x^2 - 2x + 5y^2 - y - c at (4, -3), take its dot product with the vector (x-4, y-(-3)), set it to zero, and show this simplifies to the desired tangent equation.  Introduce the hypothesis, which gives the dot product of the gradient at (4, -3) with the difference vector is zero. Apply the rule for the derivative of a subtraction to write \u2207(3x^2 - 2x + 5y^2 - y - c) as \u2207(3x^2 - 2x + 5y^2 - y) - \u2207(c). Define a hypothesis to split up \u2207(3x^2 - 2x + 5y^2 - y) as \u2207(3x^2 - 2x) + \u2207(5y^2 - y): Assume differentiability at the respective pieces. Show that the function algebraically splits as desired, to justify splitting the derivative. Use linear map properties to express the whole fderiv as the sum and difference of the gradients for the x and y parts, minus the constant. Show that the x-part gradient, evaluated and dotted, gives (x-4) * 22: Use function composition to focus on the x variable. Use the one-variable derivative rules to compute the x derivative. Work through the simplification and substitution to get the 22. Confirm differentiability for this piece. Show that the y-part gradient, evaluated and dotted, gives (y-(-3)) * (-31): Use function composition to focus on the y variable. Use the one-variable derivative rules to compute the y derivative. Work through the simplification and substitution to get the -31. Confirm differentiability for this piece. Show that the gradient of the constant at the given point vanishes when dotted with the difference vector. Substitute the expressions for the x-part, y-part, and constant into the original hypothesis, simplify, and derive the desired linear tangent equation. Give all required differentiability justifications for the x part, y part, full function, and constant."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 - 2 * p.2 ^ 2 + p.2 - c) ((4:\u211d), (-1:\u211d)) (x-4, y-(-1)) = 0) \u2192 ((x-4) * (2) - (y-(-1)) * (-5) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((4:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((4:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 - 2 * p.2 ^ 2 + p.2) ((4:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((4:\u211d), (-1:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((4:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((4:\u211d), (-1:\u211d))) (x - 4, y - (-1)) = (x-4) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((4:\u211d), (-1:\u211d))) (x - 4, y - (-1)) = (y-(-1)) * (-5)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 2 - p.2) = (fun x => 2 * x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (-1:\u211d)) (x - 4, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x - 2y^2 + y - c = 0 at the point (4, -1) is (x-4) * 2 - (y-(-1)) * (-5) = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = 2x - 2y^2 + y - c at the point (4, -1), then take the dot product with the shifted position vector (x-4, y-(-1)), set the result to zero, and show this is equivalent to the claimed tangent equation.  Introduce the hypothesis: the dot product of the gradient with (x-4, y-(-1)) is zero. Use the derivative rule for subtraction to split \u2207(2x - 2y^2 + y - c) = \u2207(2x - 2y^2 + y) - \u2207(c). Create a sub-hypothesis to split \u2207(2x - 2y^2 + y) = \u2207(2x) - \u2207(2y^2 - y). Assume differentiability at the relevant places. Rewrite the expression using the linearity of the derivative and the subtraction rule to expand the gradient. For the x-component: show that \u2207(2x) at (4, -1) dot (x-4, y-(-1)) contributes (x-4) * 2. Use function composition properties and derivative rules to reduce the multivariate derivative to a univariate one. Compute the single-variable derivative. Apply the definition of the linear map and algebraic simplification. Confirm differentiability for 2x. For the y-component: show that \u2207(2y^2 - y) at (4, -1) dot (x-4, y-(-1)) contributes (y-(-1)) * (-5). Use function composition and derivative rules for the y variable. Compute the necessary single-variable derivatives. Apply properties of the linear map and perform the algebra. Confirm differentiability for 2y^2 - y. For the constant c: show \u2207(c) at (4, -1) dot (x-4, y-(-1)) = 0 since the derivative of a constant is zero. Substitute the results from steps 5\u20137 into the main equation. Provide the necessary differentiability proofs for \u2207(2x), \u2207(2y^2 - y), their sum, and the constant function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1 + 3 * p.2 ^ 2 - c) ((4:\u211d), (-4:\u211d)) (x-4, y-(-4)) = 0) \u2192 ((x-4) * (253) + (y-(-4)) * (-24) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1) ((4:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 2) ((4:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1 + 3 * p.2 ^ 2) ((4:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1) ((4:\u211d), (-4:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2 ^ 2) ((4:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1) ((4:\u211d), (-4:\u211d))) (x - 4, y - (-4)) = (x-4) * (253)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3 + 2 * p.1 ^ 2 - 3 * p.1) = (fun x => 5 * x ^ 3 + 2 * x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 2) ((4:\u211d), (-4:\u211d))) (x - 4, y - (-4)) = (y-(-4)) * (-24)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 2) = (fun x => 3 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (-4:\u211d)) (x - 4, y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^3 + 2 * x^2 - 3 * x + 3 * y^2 - c = 0 at the point (4, -4) is (x-4) * 253 + (y-(-4)) * (-24) = 0. The general idea is to compute the gradient (\u2207) of f(x, y) = 5*x^3 + 2*x^2 - 3*x + 3*y^2 - c at the point (4, -4), then take the dot product with the vector (x-4, y-(-4)). Setting this equal to 0 gives the tangent equation, which you must show is the same as (x-4) * 253 + (y-(-4)) * (-24) = 0.  Introduce the hypothesis that the directional derivative (the dot product of the gradient at (4, -4) with (x-4, y-(-4))) is zero. Apply the rule for differentiating a subtraction to split \u2207(5x^3 + 2x^2 - 3x + 3y^2 - c) as \u2207(5x^3 + 2x^2 - 3x + 3y^2) - \u2207(c). Define a hypothesis splitting the gradient further: \u2207(5x^3 + 2x^2 - 3x + 3y^2) = \u2207(5x^3 + 2x^2 - 3x) + \u2207(3y^2), assuming differentiability at the relevant points. Use this hypothesis and properties of linear maps to rewrite the tangent equation in terms of the sum and difference of partial derivatives. Show that \u2207(5x^3 + 2x^2 - 3x) at (4, -4), applied to (x-4, y-(-4)), gives (x-4) * 253: Use composition and differentiation rules to isolate differentiation with respect to x. Compute the derivatives, combine according to the sum and scalar multiplication rules, and evaluate at x = 4. Justify all differentiability conditions. Show that \u2207(3y^2) at (4, -4), applied to (x-4, y-(-4)), gives (y-(-4)) * (-24): Use composition and differentiation rules to isolate differentiation with respect to y. Compute the derivatives, combine terms, and evaluate at y = -4. Justify all differentiability conditions. Show that \u2207(c) at (4, -4), applied to (x-4, y-(-4)), gives 0, as c is constant. Substitute the computed expressions into the equation, combine them, and confirm it matches (x-4) * 253 + (y-(-4)) * (-24) = 0. Establish all differentiability requirements for the involved functions to justify the manipulations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 + p.1 ^ 2 - 4 * p.2 - c) ((0:\u211d), (5:\u211d)) (x-0, y-5) = 0) \u2192 ((x-0) * (0) - (y-5) * (4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 + p.1 ^ 2) ((0:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2) ((0:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 + p.1 ^ 2 - 4 * p.2) ((0:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 + p.1 ^ 2) ((0:\u211d), (5:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2) ((0:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 + p.1 ^ 2) ((0:\u211d), (5:\u211d))) (x - 0, y - 5) = (x-0) * (0)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 + p.1 ^ 2) = (fun x => x ^ 3 + x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2) ((0:\u211d), (5:\u211d))) (x - 0, y - 5) = (y-5) * (4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2) = (fun x => 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (5:\u211d)) (x - 0, y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation for the tangent to the curve x^3 + x^2 - 4y - c = 0 at the point (0,5) can be written as (x-0) * (0) - (y-5) * (4) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = x^3 + x^2 - 4y - c at the point (0, 5), then take the dot product with the shifted position vector (x-0, y-5). Setting this equal to zero gives the equation of the tangent, which we want to show coincides with the given equality.  Introduce the hypothesis that the dot product of the gradient at (0, 5) with (x-0, y-5) is zero. Use the linearity of the derivative with respect to subtraction to split \u2207(x^3 + x^2 - 4y - c) into \u2207(x^3 + x^2 - 4y) - \u2207(c). Define a hypothesis to further split \u2207(x^3 + x^2 - 4y) as \u2207(x^3 + x^2) - \u2207(4y), assuming differentiability of each part at (0, 5). Apply this splitting and the structure of continuous linear maps to expand the gradient evaluation as a difference. Show that \u2207(x^3 + x^2) at (0, 5) dot (x-0, y-5) is (x-0) * (0): Use the composition of functions and the chain rule to reduce to a standard derivative. Compute the derivatives with respect to x. Simplify the resulting linear map application. Verify differentiability of x^3 + x^2 at the point. Show that \u2207(4y) at (0, 5) dot (x-0, y-5) is (y-5) * 4: Apply chain rule through function composition to reduce to simple derivative calculus. Compute the derivative with respect to y. Simplify linear map application accordingly. Verify differentiability of 4y at the point. Show that \u2207(c) at (0, 5) dot (x-0, y-5) is 0, since c is constant with respect to both variables. Substitute all previous results and simplify the resulting expression for the tangent. Provide the necessary differentiability justifications for each function involved (x^3 + x^2, 4y, the total function, and the constant c)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1 + 5 * p.2 ^ 4 - 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2 - c) ((0:\u211d), (4:\u211d)) (x-0, y-4) = 0) \u2192 ((x-0) * (-5) + (y-4) * (1069) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1) ((0:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 4 - 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) ((0:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1 + 5 * p.2 ^ 4 - 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) ((0:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1) ((0:\u211d), (4:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 4 - 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) ((0:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1) ((0:\u211d), (4:\u211d))) (x - 0, y - 4) = (x-0) * (-5)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3 + 3 * p.1 ^ 2 - 5 * p.1) = (fun x => 2 * x ^ 3 + 3 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 4 - 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) ((0:\u211d), (4:\u211d))) (x - 0, y - 4) = (y-4) * (1069)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 4 - 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) = (fun x => 5 * x ^ 4 - 4 * x ^ 3 - 3 * x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (4:\u211d)) (x - 0, y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^3 + 3 * x^2 - 5 * x + 5 * y^4 - 4 * y^3 - 3 * y^2 + 5 * y - c = 0 at the point (0, 4) is (x-0) * (-5) + (y-4) * (1069) = 0. The strategy is to compute the gradient (\u2207) of f(x, y) at (0, 4), take the dot product with (x-0, y-4), set it to zero, and show this is equivalent to the desired tangent equation. Introduce the hypothesis: the fact that the dot product of the gradient at (0, 4) and (x-0, y-4) equals 0. Use the derivative rule for subtraction to split \u2207(2x^3 + 3x^2 - 5x + 5y^4 - 4y^3 - 3y^2 + 5y - c) as \u2207(2x^3 + 3x^2 - 5x + 5y^4 - 4y^3 - 3y^2 + 5y) - \u2207(c). Define a hypothesis to split the gradient of the sum: observe that the function is separable as a function of x and a function of y, so split as \u2207(2x^3 + 3x^2 - 5x) + \u2207(5y^4 - 4y^3 - 3y^2 + 5y), assuming differentiability at each component. Use this splitting and rules for continuous linear maps to write the complete gradient as the sum (or difference) of the gradients of the x-part, y-part, and the constant c. Compute the gradient of the x-part at (0,4) with input (x-0, y-4), and show this is (x-0) * (-5). Apply the chain rule and recognize that, since this part depends only on x, the partial derivative with respect to x can be computed via ordinary rules. Differentiate the function 2x^3 + 3x^2 - 5x. Simplify and plug in the input direction; carry out the scalar multiplication. Ensure all differentiability assumptions are satisfied for the relevant functions. Compute the gradient of the y-part at (0,4) with input (x-0, y-4), and show this is (y-4) * (1069). Realize this part only depends on y. The chain and product rules simplify to the usual single-variable differentiation with respect to y. Differentiate 5y^4 - 4y^3 - 3y^2 + 5y. Simplify, evaluate at y=4, and multiply by (y-4). Ensure differentiability conditions hold for this function. Show that the gradient of the constant c is zero in all directions. Substitute the computations from steps 5, 6, and 7, and combine using linearity to finish simplification. Confirm all required differentiability conditions for each component you have split."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 + 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 4 * p.1 - 5 * p.2 ^ 2 - 5 * p.2 - c) ((-5:\u211d), (6:\u211d)) (x-(-5), y-6) = 0) \u2192 ((x-(-5)) * (-329) - (y-6) * (65) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 + 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2 + 5 * p.2) ((-5:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 + 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 4 * p.1 - 5 * p.2 ^ 2 - 5 * p.2) ((-5:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 + 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (6:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 2 + 5 * p.2) ((-5:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 + 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (6:\u211d))) (x - (-5), y - 6) = (x-(-5)) * (-329)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 + 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 4 * p.1) = (fun x => x ^ 4 + 3 * x ^ 3 + 5 * x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2 + 5 * p.2) ((-5:\u211d), (6:\u211d))) (x - (-5), y - 6) = (y-6) * (65)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2 + 5 * p.2) = (fun x => 5 * x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (6:\u211d)) (x - (-5), y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 + 3 x^3 + 5 x^2 - 4x - 5y^2 - 5y - c = 0 at the point (-5, 6) is (x - (-5)) * (-329) - (y - 6) * (65) = 0. The method is to compute the gradient (\u2207) of the function f(x, y) = x^4 + 3 x^3 + 5 x^2 - 4x - 5y^2 - 5y - c at the point (-5, 6), then take its dot product with the shifted positional vector (x - (-5), y - 6), set that equal to 0, and show this coincides with the provided tangent equation.  Introduce the hypothesis: set the dot product of the gradient at the point with the shifted positional vector equal to 0. Apply the derivative rule for subtraction to write \u2207(x^4 + 3 x^3 + 5 x^2 - 4x - 5y^2 - 5y - c) = \u2207(x^4 + 3 x^3 + 5 x^2 - 4x - 5y^2 - 5y) - \u2207(c). Split up the function as \u2207(x^4 + 3 x^3 + 5 x^2 - 4x - 5y^2 - 5y) = \u2207(x^4 + 3 x^3 + 5 x^2 - 4x) - \u2207(5y^2 + 5y), assuming both parts are differentiable at the point. Use linearity and this split to expand the gradient accordingly. Show that \u2207(x^4 + 3 x^3 + 5 x^2 - 4x) at (-5, 6), applied to (x - (-5), y - 6), equals (x - (-5)) * (-329): Observe the partial derivative with respect to x, using the rules for polynomials and the chain rule for function composition. Explicitly differentiate x^4, 3x^3, 5x^2, and -4x, and sum them. Evaluate this at x = -5. Use linearity to see only the (x - (-5)) component remains, multiplied by the computed derivative value. Prove differentiability of this polynomial at the relevant point. Show that \u2207(5y^2 + 5y) at (-5, 6), applied to (x - (-5), y - 6), equals (y - 6) * (65): Observe the partial derivative with respect to y. Differentiate 5y^2 and 5y, sum, and evaluate at y = 6. By linearity, extract the (y - 6) component multiplied by this derivative. Prove this function is differentiable at the relevant point. Show that \u2207(c) at (-5, 6), applied to (x - (-5), y - 6), is 0, as c is constant. Substitute all the above into your original expression and simplify. Confirm all differentiability conditions for the polynomial terms and constants at the required point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 - 2 * p.1 + 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 2 * p.2 - c) ((4:\u211d), (-1:\u211d)) (x-4, y-(-1)) = 0) \u2192 ((x-4) * (38) + (y-(-1)) * (12) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 2 * p.2) ((4:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 - 2 * p.1 + 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 2 * p.2) ((4:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 2 * p.2) ((4:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (-1:\u211d))) (x - 4, y - (-1)) = (x-4) * (38)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 - 2 * p.1) = (fun x => 5 * x ^ 2 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 2 * p.2) ((4:\u211d), (-1:\u211d))) (x - 4, y - (-1)) = (y-(-1)) * (12)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 2 * p.2) = (fun x => 2 * x ^ 3 - 4 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (-1:\u211d)) (x - 4, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 - 2 * x + 2 * y^3 - 4 * y^2 - 2 * y - c = 0 at the point (4, -1) is (x-4) * 38 + (y-(-1)) * 12 = 0. The approach is to compute the gradient (\u2207) of f(x, y) = 5 * x^2 - 2 * x + 2 * y^3 - 4 * y^2 - 2 * y - c at the point (4, -1), then take the dot product with the shifted vector (x-4, y-(-1)), set the result to zero, and show that this gives the desired result.  Introduce the hypothesis: the dot product of the gradient at the point (4, -1) with the vector (x-4, y-(-1)) is zero. Apply the rule for the derivative of a subtraction to split the gradient of the full function into the gradient of 5 * x^2 - 2 * x + 2 * y^3 - 4 * y^2 - 2 * y and the gradient of the constant term c. Introduce and prove a hypothesis showing that the gradient of 5 * x^2 - 2 * x + 2 * y^3 - 4 * y^2 - 2 * y at (4, -1) splits into the sum of the gradients of the x-part, 5 * x^2 - 2 * x, and the y-part, 2 * y^3 - 4 * y^2 - 2 * y, at (4, -1). Substitute this result and apply the appropriate properties of linear maps to simplify the expression for the derivative at the given point. Show that the gradient of 5 * x^2 - 2 * x at (4, -1) with respect to (x-4, y-(-1)) yields (x-4) * 38. Use function composition and rules for computing the total derivative to move from the function of two variables to a function of one variable (x). Compute the required partial derivative with respect to x and evaluate at x = 4. Show how the linear map applies to the vector, and simplify to obtain the desired form. Justify differentiability at every step for 5 * x^2 - 2 * x. Show that the gradient of 2 * y^3 - 4 * y^2 - 2 * y at (4, -1) with respect to (x-4, y-(-1)) yields (y-(-1)) * 12. Use function composition and rules for computing the total derivative to move to the function of one variable (y). Compute the required partial derivative with respect to y and evaluate at y = -1. Show how the linear map applies to the vector, and simplify to obtain the desired form. Justify differentiability at every step for 2 * y^3 - 4 * y^2 - 2 * y. Show that the gradient of the constant function c at (4, -1), applied to the difference (x-4, y-(-1)), is zero. Substitute the results from steps 5\u20137 back into the original equation, and simplify to obtain (x-4) * 38 + (y-(-1)) * 12 = 0. Justify the differentiability for each part and for the total function at (4, -1)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - 2 * p.1 ^ 2 + 5 * p.1 + 5 * p.2 ^ 2 + 3 * p.2 - c) ((-1:\u211d), (0:\u211d)) (x-(-1), y-0) = 0) \u2192 ((x-(-1)) * (12) + (y-0) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - 2 * p.1 ^ 2 + 5 * p.1) ((-1:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2 + 3 * p.2) ((-1:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - 2 * p.1 ^ 2 + 5 * p.1 + 5 * p.2 ^ 2 + 3 * p.2) ((-1:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - 2 * p.1 ^ 2 + 5 * p.1) ((-1:\u211d), (0:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 2 + 3 * p.2) ((-1:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - 2 * p.1 ^ 2 + 5 * p.1) ((-1:\u211d), (0:\u211d))) (x - (-1), y - 0) = (x-(-1)) * (12)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - 2 * p.1 ^ 2 + 5 * p.1) = (fun x => x ^ 3 - 2 * x ^ 2 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2 + 3 * p.2) ((-1:\u211d), (0:\u211d))) (x - (-1), y - 0) = (y-0) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2 + 3 * p.2) = (fun x => 5 * x ^ 2 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (0:\u211d)) (x - (-1), y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 - 2x^2 + 5x + 5y^2 + 3y - c = 0 at the point (-1, 0) is (x-(-1)) * 12 + (y-0) * 3 = 0. The idea is to take the gradient (\u2207) of the function f(x,y) = x^3 - 2x^2 + 5x + 5y^2 + 3y - c at the point (-1,0), then write the equation for the tangent as the dot product of the gradient with the shifted positional vector (x-(-1), y-0) equal to 0, and show this simplifies to the claimed equation. Introduce the hypothesis: the dot product of the gradient with the shifted vector is 0. Apply the derivative rule of subtraction: split \u2207(x^3 - 2x^2 + 5x + 5y^2 + 3y - c) = \u2207(x^3 - 2x^2 + 5x + 5y^2 + 3y) - \u2207(c). Introduce an intermediate result to split the gradient sum for the non-constant part into two blocks: \u2207(x^3 - 2x^2 + 5x + 5y^2 + 3y) = \u2207(x^3 - 2x^2 + 5x) + \u2207(5y^2 + 3y), assuming differentiability at these respective components. Use this splitting and the rules of linear maps to expand the relevant terms for the dot product. Compute the contribution from the x-part: Express the function in terms of a composition to reduce differentiation to a single-variable function. Use differentiation rules on x^3 - 2x^2 + 5x, evaluating at x = -1. Show that this part gives (x-(-1)) * 12 by explicit computation and simplification. State and check that the differentiability conditions are satisfied for this component. Compute the contribution from the y-part: Similarly, reduce to a single-variable function for y, express as a composition. Use differentiation rules on 5y^2 + 3y, evaluating at y = 0. Show this yields (y-0) * 3. Confirm differentiability conditions for the y-component. Show the contribution of the constant c is 0: \u2207(c) at any point is zero, so the dot product vanishes. Substitute the three computed results into the equation and simplify to obtain the tangent equation in the desired form. Justify any differentiability requirements needed throughout for the application of multivariable differentiation rules."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 - p.2 - c) ((1:\u211d), (-6:\u211d)) (x-1, y-(-6)) = 0) \u2192 ((x-1) * (2) - (y-(-6)) * (1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((1:\u211d), (-6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2) ((1:\u211d), (-6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 - p.2) ((1:\u211d), (-6:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((1:\u211d), (-6:\u211d)) -\n      fderiv \u211d (fun p => p.2) ((1:\u211d), (-6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((1:\u211d), (-6:\u211d))) (x - 1, y - (-6)) = (x-1) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2) ((1:\u211d), (-6:\u211d))) (x - 1, y - (-6)) = (y-(-6)) * (1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2) = (fun x => x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (-6:\u211d)) (x - 1, y - (-6)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact differentiableAt_snd\n  \n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the line 2x - y - c = 0 at the point (1, -6) is (x-1) * 2 - (y-(-6)) * 1 = 0. The method is to compute the gradient (\u2207) of f(x, y) = 2x - y - c at the point (1, -6), then form its dot product with the shifted positional vector (x-1, y-(-6)). Setting this equal to zero gives the tangent, and we have to check it matches (x-1)*2 - (y-(-6))=0. Introduce the hypothesis, expressing that the gradient at (1, -6) dotted with (x-1, y-(-6)) equals zero. Use the rule for the derivative of a difference to split \u2207(2x - y - c) = \u2207(2x - y) - \u2207(c). Further split \u2207(2x - y) = \u2207(2x) - \u2207(y). Assume differentiability at 2x and y. Use the above to rewrite the original gradient in terms of \u2207(2x), \u2207(y), and \u2207(c), and apply the appropriate rules for linear maps to the expression involving their dot products. Compute \u2207(2x) at (1,-6) dot (x-1, y-(-6)) = (x-1) * 2. Use function composition and derivative rules to show the gradient with respect to one variable reduces to differentiation in that component. Compute the derivative with respect to x. Use properties of linear maps and algebra to simplify to (x-1) * 2. Argue that 2x is differentiable. Compute \u2207(y) at (1,-6) dot (x-1, y-(-6)) = (y-(-6)) * 1. Again, relate this to the corresponding single-variable derivative. Compute the derivative with respect to y. Use linear map properties and algebraic simplification. Argue that y is differentiable. Show that \u2207(c) at (1,-6) dot (x-1, y-(-6)) = 0 (as the derivative of a constant vanishes). Substitute the computations above back into the original equation, simplify, and deduce (x-1)*2 - (y-(-6))*1 = 0. Verify all the functions involved are differentiable at the required point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 4 + 3 * p.1 ^ 2 + p.1 - 2 * p.2 ^ 2 + 2 * p.2 - c) ((-4:\u211d), (-2:\u211d)) (x-(-4), y-(-2)) = 0) \u2192 ((x-(-4)) * (-535) - (y-(-2)) * (-10) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 4 + 3 * p.1 ^ 2 + p.1) ((-4:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 2 - 2 * p.2) ((-4:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 4 + 3 * p.1 ^ 2 + p.1 - 2 * p.2 ^ 2 + 2 * p.2) ((-4:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 4 + 3 * p.1 ^ 2 + p.1) ((-4:\u211d), (-2:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 2 - 2 * p.2) ((-4:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 4 + 3 * p.1 ^ 2 + p.1) ((-4:\u211d), (-2:\u211d))) (x - (-4), y - (-2)) = (x-(-4)) * (-535)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 4 + 3 * p.1 ^ 2 + p.1) = (fun x => 2 * x ^ 4 + 3 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 2 - 2 * p.2) ((-4:\u211d), (-2:\u211d))) (x - (-4), y - (-2)) = (y-(-2)) * (-10)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 2 - 2 * p.2) = (fun x => 2 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (-2:\u211d)) (x - (-4), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x\u2074 + 3x\u00b2 + x - 2y\u00b2 + 2y - c = 0 at the point (-4, -2) is (x-(-4)) * (-535) - (y-(-2)) * (-10) = 0. The main idea is to compute the gradient (\u2207) of f(x, y) = 2x\u2074 + 3x\u00b2 + x - 2y\u00b2 + 2y - c at the point (-4, -2), and then use the linear approximation at that point (i.e. take the dot product with the shifted positional vector) to describe the tangent. This will yield the equation we seek. Introduce the hypothesis, which states that the dot product of the gradient of the function (evaluated at the relevant point) and (x-(-4), y-(-2)) equals zero. Use the linearity of the derivative to break up the derivative of the sum/difference into smaller pieces: \u2207(2x\u2074 + 3x\u00b2 + x - 2y\u00b2 + 2y - c) = \u2207(2x\u2074 + 3x\u00b2 + x - 2y\u00b2 + 2y) - \u2207(c). Define a helper statement showing that the function inside the first gradient can be separated by variables: \u2207(2x\u2074 + 3x\u00b2 + x - 2y\u00b2 + 2y) = \u2207(2x\u2074 + 3x\u00b2 + x) - \u2207(2y\u00b2 - 2y), assuming each piece is differentiable at (-4, -2). Use this split and the properties of linear maps to break the total fderiv at (-4, -2) into the sum/subtraction of the fderivs of the coordinate functions. Compute the directional derivative of (2x\u2074 + 3x\u00b2 + x) in the first variable: Express (2x\u2074 + 3x\u00b2 + x) as a function composed with the first coordinate. Use the chain and sum rules to compute the derivatives for each term with respect to x. Substitute x = -4 and perform the arithmetic. Show that the resulting value, when combined with the vector (x-(-4)), gives (x-(-4)) * (-535). Compute the directional derivative of (2y\u00b2 - 2y) in the second variable: Express (2y\u00b2 - 2y) as a function of the second coordinate. Use the chain, subtraction, and product rules to compute the derivatives. Substitute y = -2 and simplify to obtain (y-(-2)) * (-10). Show that the derivative of the constant function c is zero, regardless of the vector. Substitute these three pieces back into the original hypothesis and simplify to reach the final tangent equation. Justify all differentiability claims for the component functions used above."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 + 5 * p.1 ^ 3 + p.1 ^ 2 + 5 * p.1 + p.2 ^ 4 - p.2 ^ 3 - p.2 ^ 2 - c) ((3:\u211d), (3:\u211d)) (x-3, y-3) = 0) \u2192 ((x-3) * (254) + (y-3) * (75) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 + 5 * p.1 ^ 3 + p.1 ^ 2 + 5 * p.1) ((3:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 - p.2 ^ 3 - p.2 ^ 2) ((3:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 + 5 * p.1 ^ 3 + p.1 ^ 2 + 5 * p.1 + p.2 ^ 4 - p.2 ^ 3 - p.2 ^ 2) ((3:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 + 5 * p.1 ^ 3 + p.1 ^ 2 + 5 * p.1) ((3:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 - p.2 ^ 3 - p.2 ^ 2) ((3:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 + 5 * p.1 ^ 3 + p.1 ^ 2 + 5 * p.1) ((3:\u211d), (3:\u211d))) (x - 3, y - 3) = (x-3) * (254)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 + 5 * p.1 ^ 3 + p.1 ^ 2 + 5 * p.1) = (fun x => x ^ 4 + 5 * x ^ 3 + x ^ 2 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 - p.2 ^ 3 - p.2 ^ 2) ((3:\u211d), (3:\u211d))) (x - 3, y - 3) = (y-3) * (75)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 - p.2 ^ 3 - p.2 ^ 2) = (fun x => x ^ 4 - x ^ 3 - x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (3:\u211d)) (x - 3, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_snd.pow _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 + 5 * x^3 + x^2 + 5 * x + y^4 - y^3 - y^2 - c = 0 at the point (3,3) is (x-3) * 254 + (y-3) * 75 = 0. The strategy is to compute the gradient (\u2207) of the function f(x,y) = x^4 + 5 * x^3 + x^2 + 5 * x + y^4 - y^3 - y^2 - c at (3,3), then apply the dot product to the vector (x-3, y-3), and show that this yields (x-3) * 254 + (y-3) * 75 = 0. Introduce the hypothesis, stating that the directional derivative (the dot product of the gradient at (3,3) with (x-3, y-3)) equals zero. Use the subtraction rule for derivatives to separate the gradient of the function into \u2207(x^4 + 5x^3 + x^2 + 5x + y^4 - y^3 - y^2) and \u2207(c). Introduce a hypothesis that splits \u2207(x^4 + 5x^3 + x^2 + 5x + y^4 - y^3 - y^2) into the sum of the gradients of the x and y parts: Show that this gradient is the sum of \u2207(x^4 + 5x^3 + x^2 + 5x) and \u2207(y^4 - y^3 - y^2), assuming differentiability at the relevant point for each. Substitute and rewrite the equation using the properties of linear maps, breaking the overall derivative as a sum and difference of the components. Compute the x-part: Use function composition to identify the function of x in terms of the first coordinate. Apply the chain rule and rules for differentiating powers, sums, and scalar multiples. After simplification, show this component of the directional derivative gives (x-3) * 254. Provide justification for differentiability for the x-part function at (3,3). Compute the y-part: Use function composition to identify the function of y in terms of the second coordinate. Apply the chain rule and rules for differentiating powers, sums, and scalar multiples. After simplification, show this component of the directional derivative gives (y-3) * 75. Provide justification for differentiability for the y-part function at (3,3). Show that the derivative of the constant part c (with respect to (x-3, y-3)) gives 0. Substitute the computed parts (x and y contributions, and the constant) into the original equation, simplify, and conclude that the equation reduces to the given tangent equation. Provide, as needed, the proofs of differentiability of the various involved component functions at (3,3), to justify all previous application of the rules."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 - 4 * p.1 + p.2 ^ 2 + 4 * p.2 - c) ((-5:\u211d), (-3:\u211d)) (x-(-5), y-(-3)) = 0) \u2192 ((x-(-5)) * (-54) + (y-(-3)) * (-2) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 - 4 * p.1 + p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (-3:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 - 4 * p.1) ((-5:\u211d), (-3:\u211d))) (x - (-5), y - (-3)) = (x-(-5)) * (-54)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 - 4 * p.1) = (fun x => 5 * x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-3:\u211d))) (x - (-5), y - (-3)) = (y-(-3)) * (-2)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 + 4 * p.2) = (fun x => x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (-3:\u211d)) (x - (-5), y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve 5 * x^2 - 4 * x + y^2 + 4 * y - c = 0 at the point (-5, -3) is (x-(-5)) * (-54) + (y-(-3)) * (-2) = 0. The approach is to compute the gradient of f(x, y) = 5x^2 - 4x + y^2 + 4y - c at (-5, -3), then take its dot product with the vector (x-(-5), y-(-3)), and set that expression equal to zero. We then demonstrate this reduces to the claimed tangent line equation. Introduce the hypothesis: the directional derivative (dot product of gradient and displacement vector) is zero for the given function at the point (-5, -3). Apply the rule for the derivative of a subtraction to split the derivative into fderiv(main expression) - fderiv(constant function). Define a hypothesis splitting fderiv(5x^2 - 4x + y^2 + 4y) into the sum of fderiv(5x^2 - 4x) and fderiv(y^2 + 4y), provided both are differentiable. Substitute that split into the main hypothesis and use properties of linear maps to write everything as sums and differences of continuous linear maps. Calculate the gradient of 5x^2 - 4x at (-5, -3) evaluated on (x-(-5), y-(-3)), and show this equals (x-(-5)) * (-54): Express 5x^2 - 4x as a function composed with the projection onto the first coordinate. Use the chain rule for differentiation and the linearity of the projection. Apply the rules for differentiating powers, scalar multiples, and sums/subtractions to compute the derivative explicitly at the required point. Use properties of the linear map to connect this value to (x-(-5)) * (-54). Justify differentiability at the relevant points. Repeat the calculation for the y-component: show the gradient of y^2 + 4y at (-5, -3) applied to (x-(-5), y-(-3)) equals (y-(-3)) * (-2): Express y^2 + 4y as a function composed with the projection onto the second coordinate. Apply the product rule, sum rule, and scalar multiple rules to compute the derivative at the relevant point. Use the linearity of the projection and the algebraic form to show the result is (y-(-3)) * (-2). Justify differentiability at the chosen point. Show that the derivative of the constant c (viewed as a function of (x, y)) is zero when applied to any direction vector. Substitute all intermediate results back into the main hypothesis and simplify, reducing the equation to the required tangent line form. Establish all differentiability conditions and verify the algebraic equalities needed for each component in the argument."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 + p.1 + 2 * p.2 ^ 2 + 2 * p.2 - c) ((-5:\u211d), (4:\u211d)) (x-(-5), y-4) = 0) \u2192 ((x-(-5)) * (-29) + (y-4) * (18) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 + p.1) ((-5:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 2 + 2 * p.2) ((-5:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 + p.1 + 2 * p.2 ^ 2 + 2 * p.2) ((-5:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 + p.1) ((-5:\u211d), (4:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 2 + 2 * p.2) ((-5:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 + p.1) ((-5:\u211d), (4:\u211d))) (x - (-5), y - 4) = (x-(-5)) * (-29)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 + p.1) = (fun x => 3 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 2 + 2 * p.2) ((-5:\u211d), (4:\u211d))) (x - (-5), y - 4) = (y-4) * (18)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 2 + 2 * p.2) = (fun x => 2 * x ^ 2 + 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (4:\u211d)) (x - (-5), y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3*x^2 + x + 2*y^2 + 2*y - c = 0 at the point (-5,4) is (x-(-5)) * (-29) + (y-4) * (18) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 3*x^2 + x + 2*y^2 + 2*y - c at the point (-5,4), take the dot product with the vector (x-(-5), y-4), and show that setting this equal to zero gives the desired tangent equation.  Introduce the hypothesis that states: the dot product of the gradient at (-5,4) with (x-(-5), y-4) equals 0. Use the rule for the derivative of a difference to split \u2207(3*x^2 + x + 2*y^2 + 2*y - c) as \u2207(3*x^2 + x + 2*y^2 + 2*y) - \u2207(c). Formulate a hypothesis expressing that the gradient of the sum (3*x^2 + x + 2*y^2 + 2*y) splits as the sum of the gradients: one in x and one in y. Assume differentiability at each relevant subfunction. Use this hypothesis and the linearity of the differential to rewrite the gradient at the chosen point as the sum of two gradients (in x and in y) minus the gradient of the constant function. Show that the x-part: Use the chain rule and identification of variable structure to show you can reduce to the single-variable derivative. Compute the derivative with respect to x, evaluate at x = -5, and simplify. Use the structure of linear maps to relate this to the directional derivative, and verify the computation using simplifications. Justify differentiability of 3*x^2 + x. Show the y-part: Similarly, use the chain rule for y and reduce to a single-variable function. Calculate the derivative with respect to y, evaluate at y = 4, and simplify. Use linearity of maps and simplification to reach the claimed form. Justify differentiability of 2*y^2 + 2*y. Show that the gradient of c (a constant) evaluated at any point and applied to any direction gives zero. Substitute the results from the previous steps back into the original equation, and simplify it to the target equation (x-(-5)) * (-29) + (y-4) * (18) = 0. Ensure all differentiability conditions for subfunctions and sums/products required in the application of the chain, product, and sum rules are provided."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 4 + p.1 ^ 3 + 2 * p.1 ^ 2 - p.1 - p.2 ^ 2 - 2 * p.2 - c) ((-1:\u211d), (5:\u211d)) (x-(-1), y-5) = 0) \u2192 ((x-(-1)) * (-22) - (y-5) * (12) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 + 2 * p.1 ^ 2 - p.1) ((-1:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 + 2 * p.2) ((-1:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 4 + p.1 ^ 3 + 2 * p.1 ^ 2 - p.1 - p.2 ^ 2 - 2 * p.2) ((-1:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 + 2 * p.1 ^ 2 - p.1) ((-1:\u211d), (5:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 2 + 2 * p.2) ((-1:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 4 + p.1 ^ 3 + 2 * p.1 ^ 2 - p.1) ((-1:\u211d), (5:\u211d))) (x - (-1), y - 5) = (x-(-1)) * (-22)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 4 + p.1 ^ 3 + 2 * p.1 ^ 2 - p.1) = (fun x => 5 * x ^ 4 + x ^ 3 + 2 * x ^ 2 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 + 2 * p.2) ((-1:\u211d), (5:\u211d))) (x - (-1), y - 5) = (y-5) * (12)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 + 2 * p.2) = (fun x => x ^ 2 + 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (5:\u211d)) (x - (-1), y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^4 + x^3 + 2 * x^2 - x - y^2 - 2 * y - c = 0 at the point (-1,5) is (x-(-1)) * (-22) - (y-5) * (12) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 5 * x^4 + x^3 + 2 * x^2 - x - y^2 - 2 * y - c at the point (-1, 5), then compute the dot product of this with the shifted positional vector (x-(-1), y-5). Setting this expression equal to zero gives the equation of the tangent, which must simplify to the target equation.  Introduce the hypothesis, namely that the dot product of the gradient with the shifted positional vector (x-(-1), y-5) equals 0. Apply the derivative rule for subtraction to split: \u2207(5 * x^4 + x^3 + 2 * x^2 - x - y^2 - 2 * y - c) = \u2207(5 * x^4 + x^3 + 2 * x^2 - x - y^2 - 2 * y) - \u2207(c) Define a hypothesis showing \u2207(5 * x^4 + x^3 + 2 * x^2 - x - y^2 - 2 * y) = \u2207(5 * x^4 + x^3 + 2 * x^2 - x) - \u2207(y^2 + 2 * y), assuming both parts are differentiable at the point of interest. Use this hypothesis along with properties of linear maps to split the main gradient expression into its x- and y-dependent components, minus the constant part. Show that the directional derivative of \u2207(5*x^4 + x^3 + 2*x^2 - x) evaluated at (-1,5) and dotted with (x-(-1), y-5) is (x-(-1)) * (-22): Use the composition and variable rules to evaluate the gradient with respect to the first variable. Compute the actual derivative with respect to x of the function 5*x^4 + x^3 + 2*x^2 - x at x = -1, and multiply by (x - (-1)). Take care with the use of linear maps and algebra to justify the computation. Confirm differentiability of the x-dependent part at the relevant point. Show that the directional derivative of \u2207(y^2 + 2*y) at (-1,5) with (x-(-1), y-5) is (y-5) * (12): Use the composition and variable rules to evaluate the gradient with respect to the second variable. Compute the actual derivative with respect to y of the function y^2 + 2*y at y = 5, and multiply by (y-5). Use linearity and algebraic properties as needed to justify. Check differentiability of the y-dependent part at this point. Show that the gradient of the (constant) c with respect to (x-(-1), y-5) yields 0. Substitute the previous computations into the main hypothesis equation, simplifying as needed to match the desired tangent line formula. Supply the required differentiability conditions for all subcomponents: the x-part, the y-part, the overall function, and the constant."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 - 5 * p.2 ^ 3 - 3 * p.2 ^ 2 - c) ((5:\u211d), (5:\u211d)) (x-5, y-5) = 0) \u2192 ((x-5) * (150) - (y-5) * (405) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3) ((5:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3 + 3 * p.2 ^ 2) ((5:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 - 5 * p.2 ^ 3 - 3 * p.2 ^ 2) ((5:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3) ((5:\u211d), (5:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 3 + 3 * p.2 ^ 2) ((5:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3) ((5:\u211d), (5:\u211d))) (x - 5, y - 5) = (x-5) * (150)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3) = (fun x => 2 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3 + 3 * p.2 ^ 2) ((5:\u211d), (5:\u211d))) (x - 5, y - 5) = (y-5) * (405)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3 + 3 * p.2 ^ 2) = (fun x => 5 * x ^ 3 + 3 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (5:\u211d)) (x - 5, y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^3 - 5 * y^3 - 3 * y^2 - c = 0 at the point (5,5) is (x-5) * 150 - (y-5) * 405 = 0. The idea is to compute the gradient (\u2207) of the function f(x,y) = 2 * x^3 - 5 * y^3 - 3 * y^2 - c at the point (5,5), then take its dot product with the vector (x-5, y-5). Setting this equal to 0 gives the tangent line at (5,5), which we need to show is exactly (x-5) * 150 - (y-5) * 405 = 0. Introduce the hypothesis, setting the directional derivative at (5,5) along (x-5, y-5) to zero. Use the rule for the derivative of a difference to write the derivative of the full function as the difference of the derivatives of 2 * x^3 - 5 * y^3 - 3 * y^2 and the constant c. Split the part 2 * x^3 - 5 * y^3 - 3 * y^2 as a difference itself: the derivative of 2 * x^3 minus the derivative of (5 * y^3 + 3 * y^2). Assume differentiability for both pieces at (5,5). Use linearity to expand and rewrite the expressions for the derivatives, applying the appropriate subtraction and combination rules. Compute the contribution of the x-variable: Interpret 2 * x^3 as a function of the first coordinate only. Use composition and rules for mixed partials to reduce computing the gradient to a single-variable derivative. Calculate the required derivative and evaluate at the point (5,5), contracted with (x-5, y-5). Show this yields (x-5)*150. Conclude the differentiability of 2 * x^3 at the point. Compute the contribution from the y-variable: Observe that 5 * y^3 + 3 * y^2 depends only on the second coordinate. Similarly, reduce this to differentiating 5 * y^3 + 3 * y^2 with respect to y. Compute the derivative at y=5 and show the contraction with (x-5, y-5) gives (y-5)*405. Confirm differentiability of this function at (5,5). Show that the derivative of the constant term c is 0 when evaluated at the point on the shifted vector. Substitute the computed values back into the overall expression, reducing the equation to the desired tangent line form. Justify the differentiability at (5,5) of all required component functions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 + 2 * p.1 ^ 2 - 4 * p.1 + 4 * p.2 ^ 3 - 5 * p.2 - c) ((-1:\u211d), (-2:\u211d)) (x-(-1), y-(-2)) = 0) \u2192 ((x-(-1)) * (-12) + (y-(-2)) * (43) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 2 - 4 * p.1) ((-1:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 - 5 * p.2) ((-1:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 + 2 * p.1 ^ 2 - 4 * p.1 + 4 * p.2 ^ 3 - 5 * p.2) ((-1:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 2 - 4 * p.1) ((-1:\u211d), (-2:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 - 5 * p.2) ((-1:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 2 - 4 * p.1) ((-1:\u211d), (-2:\u211d))) (x - (-1), y - (-2)) = (x-(-1)) * (-12)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 + 2 * p.1 ^ 2 - 4 * p.1) = (fun x => x ^ 4 + 2 * x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 - 5 * p.2) ((-1:\u211d), (-2:\u211d))) (x - (-1), y - (-2)) = (y-(-2)) * (43)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 - 5 * p.2) = (fun x => 4 * x ^ 3 - 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (-2:\u211d)) (x - (-1), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x\u2074 + 2x\u00b2 \u2212 4x + 4y\u00b3 \u2212 5y \u2212 c = 0 at the point (\u22121,\u22122) is (x\u2212(\u22121)) * (\u221212) + (y\u2212(\u22122)) * (43) = 0. The main idea is to compute the gradient (\u2207) of the function f(x, y) = x\u2074 + 2x\u00b2 \u2212 4x + 4y\u00b3 \u2212 5y \u2212 c at the point (\u22121,\u22122), then take the dot product with the vector (x\u2212(\u22121), y\u2212(\u22122)). Setting this dot product equal to 0 gives the equation of the tangent at this point, and we have to show it simplifies to the statement given. Introduce the hypothesis: the dot product of the gradient at (\u22121,\u22122) and (x\u2212(\u22121), y\u2212(\u22122)) is 0. Use the linearity of the derivative to split \u2207(x\u2074 + 2x\u00b2 \u2212 4x + 4y\u00b3 \u2212 5y \u2212 c) = \u2207(x\u2074 + 2x\u00b2 \u2212 4x + 4y\u00b3 \u2212 5y) \u2212 \u2207(c) Split the derivative further by defining a hypothesis that separates the x-terms and y-terms: \u2207(x\u2074 + 2x\u00b2 \u2212 4x + 4y\u00b3 \u2212 5y) = \u2207(x\u2074 + 2x\u00b2 \u2212 4x) + \u2207(4y\u00b3 \u2212 5y). Assume differentiability of both summands at the point. Use the above result to split the gradient and apply the appropriate linear maps to the input vector (x\u2212(\u22121), y\u2212(\u22122)). Show that the contribution from the x-terms is (x\u2212(\u22121)) * (\u221212): Express the x-term part as a composition to reduce to a one-variable function. Use derivative rules to compute the partial derivative with respect to x at x = \u22121. Apply algebraic and linear map simplifications to show the component simplifies as required. Justify differentiability of x\u2074 + 2x\u00b2 \u2212 4x at the point. Show that the contribution from the y-terms is (y\u2212(\u22122)) * (43): Express the y-term part as a composition to reduce to a one-variable function. Use derivative rules to compute the partial derivative with respect to y at y = \u22122. Apply algebraic and linear map simplifications to show the component simplifies as required. Justify differentiability of 4y\u00b3 \u2212 5y at the point. Show that the contribution from the constant term c is zero. Substitute the computed results into the equation and simplify. Show that the final equation becomes (x\u2212(\u22121))* (\u221212) + (y\u2212(\u22122))* (43) = 0. Justify all differentiability assumptions for each subexpression at the required point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 + 5 * p.1 + p.2 ^ 2 + 5 * p.2 - c) ((2:\u211d), (-1:\u211d)) (x-2, y-(-1)) = 0) \u2192 ((x-2) * (25) + (y-(-1)) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((2:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 + 5 * p.2) ((2:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 + 5 * p.1 + p.2 ^ 2 + 5 * p.2) ((2:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((2:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 + 5 * p.2) ((2:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((2:\u211d), (-1:\u211d))) (x - 2, y - (-1)) = (x-2) * (25)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 + 5 * p.1) = (fun x => 5 * x ^ 2 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 + 5 * p.2) ((2:\u211d), (-1:\u211d))) (x - 2, y - (-1)) = (y-(-1)) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 + 5 * p.2) = (fun x => x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (-1:\u211d)) (x - 2, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 + 5 * x + y^2 + 5 * y - c = 0 at the point (2, -1) is (x-2) * 25 + (y-(-1)) * 3 = 0. The idea is: calculate the gradient (\u2207) of the function f(x, y) = 5 * x^2 + 5 * x + y^2 + 5 * y - c at (2, -1), then take the dot product of this gradient with the vector (x-2, y-(-1)). Set this equal to 0 to get the tangent line, and show that this is equivalent to (x-2) * 25 + (y-(-1)) * 3 = 0.  Introduce the hypothesis, which asserts that the dot product of the gradient at (2, -1) with (x-2, y-(-1)) is zero. Use the derivative rule for subtraction to split \u2207(5 * x^2 + 5 * x + y^2 + 5 * y - c) into \u2207(5 * x^2 + 5 * x + y^2 + 5 * y) - \u2207(c). Introduce a hypothesis splitting \u2207(5 * x^2 + 5 * x + y^2 + 5 * y) = \u2207(5 * x^2 + 5 * x) + \u2207(y^2 + 5 * y), assuming differentiability of the pieces at (2, -1). Substitute and use the linearity properties to rewrite the gradient at (2, -1) as the sum of gradients of the x and y parts, minus the constant part. Show that \u2207(5 * x^2 + 5 * x) at (2, -1) dotted with (x-2, y-(-1)) is (x-2) * 25. Express this function as a composition and reduce to the one-variable case. Calculate the derivative with respect to x as needed. Use linearity of the maps and algebraic simplification to get the explicit coefficient. Verify differentiability of 5 * x^2 + 5 * x. Show that \u2207(y^2 + 5 * y) at (2, -1) dotted with (x-2, y-(-1)) is (y-(-1)) * 3. Express as a composition and reduce to the one-variable y case. Calculate the derivative with respect to y as needed. Use linearity of the maps and algebraic simplification to get the explicit coefficient. Verify differentiability of y^2 + 5 * y. Show that \u2207(c) at (2, -1) dotted with (x-2, y-(-1)) is 0 (since the derivative of a constant vanishes). Substitute all these results back into the original equation to get (x-2) * 25 + (y-(-1)) * 3 = 0. Throughout, justify differentiability of the component functions and the overall sum."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 + 5 * p.1 ^ 2 - 2 * p.1 + p.2 ^ 2 - 3 * p.2 - c) ((4:\u211d), (5:\u211d)) (x-4, y-5) = 0) \u2192 ((x-4) * (86) + (y-5) * (7) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 + 5 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 - 3 * p.2) ((4:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 + 5 * p.1 ^ 2 - 2 * p.1 + p.2 ^ 2 - 3 * p.2) ((4:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 + 5 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (5:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 - 3 * p.2) ((4:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 + 5 * p.1 ^ 2 - 2 * p.1) ((4:\u211d), (5:\u211d))) (x - 4, y - 5) = (x-4) * (86)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 + 5 * p.1 ^ 2 - 2 * p.1) = (fun x => x ^ 3 + 5 * x ^ 2 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 - 3 * p.2) ((4:\u211d), (5:\u211d))) (x - 4, y - 5) = (y-5) * (7)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 - 3 * p.2) = (fun x => x ^ 2 - 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (5:\u211d)) (x - 4, y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 + 5x^2 - 2x + y^2 - 3y - c = 0 at the point (4,5) is (x-4) * 86 + (y-5) * 7 = 0. The idea is to compute the gradient (\u2207) of f(x,y)=x^3 + 5x^2 - 2x + y^2 - 3y - c at (4,5), then evaluate the dot product with the vector (x-4, y-5). Setting that equal to zero gives the tangent equation, and we must show it matches the claimed result. Introduce the hypothesis that the derivative of the function at (4,5) evaluated on (x-4, y-5) is 0. Use the rule for derivatives with subtraction to split \u2207(x^3 + 5x^2 - 2x + y^2 - 3y - c) at (4,5) as: \u2207(x^3 + 5x^2 - 2x + y^2 - 3y) - \u2207(c) Define and use the fact that gradients of sums split, so that \u2207(x^3 + 5x^2 - 2x + y^2 - 3y) = \u2207(x^3 + 5x^2 - 2x) + \u2207(y^2 - 3y), assuming differentiability of the respective parts. Substitute these into the initial expression and use linear algebra rules for splitting and combining terms. Show \u2207(x^3 + 5x^2 - 2x) at (4,5) acting on (x-4, y-5) is (x-4) * 86. Express x-dependent part as a univariate function composed with projection and use chain rule for differentiation. Compute the gradient (partial derivatives) w.r.t x at the point (4,5). Combine results using properties of linear maps, and simplify to reach the coefficient 86. Confirm differentiability of x^3 + 5x^2 - 2x. Show \u2207(y^2 - 3y) at (4,5) acting on (x-4, y-5) is (y-5) * 7. Express y-dependent part as a univariate function composed with projection and use chain rule for differentiation. Compute the gradient (partial derivative) w.r.t y at the point (4,5). Combine using linearity and properties of the linear map, simplify to produce the coefficient 7. Confirm differentiability of y^2 - 3y. Show that the gradient of the constant term c evaluated at any vector is zero. Substitute all the results into the main equation and simplify to the intended tangent line equation. Check and state differentiability of the separate components and their sums where required."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 + p.2 ^ 3 + 2 * p.2 ^ 2 - 3 * p.2 - c) ((-6:\u211d), (2:\u211d)) (x-(-6), y-2) = 0) \u2192 ((x-(-6)) * (1) + (y-2) * (17) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1) ((-6:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 + 2 * p.2 ^ 2 - 3 * p.2) ((-6:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 + p.2 ^ 3 + 2 * p.2 ^ 2 - 3 * p.2) ((-6:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => p.1) ((-6:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 3 + 2 * p.2 ^ 2 - 3 * p.2) ((-6:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1) ((-6:\u211d), (2:\u211d))) (x - (-6), y - 2) = (x-(-6)) * (1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1) = (fun x => x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 + 2 * p.2 ^ 2 - 3 * p.2) ((-6:\u211d), (2:\u211d))) (x - (-6), y - 2) = (y-2) * (17)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 + 2 * p.2 ^ 2 - 3 * p.2) = (fun x => x ^ 3 + 2 * x ^ 2 - 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (2:\u211d)) (x - (-6), y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x + y^3 + 2*y^2 - 3*y - c = 0 at the point (-6,2) is (x-(-6)) * 1 + (y-2) * 17 = 0. The strategy is: compute the gradient (\u2207) of f(x,y) = x + y^3 + 2y^2 - 3y - c at the point (-6,2), then take the dot product with the displacement vector (x-(-6), y-2) and set that equal to zero, giving the equation of the tangent line. Introduce the hypothesis, which is that the dot product of the gradient at the point with (x-(-6), y-2) is zero. Apply the derivative rule for subtraction, splitting the total derivative into the main function and the constant part: \u2207(x + y^3 + 2y^2 - 3y - c) = \u2207(x + y^3 + 2y^2 - 3y) - \u2207(c). Define a hypothesis to further split \u2207(x + y^3 + 2y^2 - 3y) = \u2207(x) + \u2207(y^3 + 2y^2 - 3y). Assume differentiability of each piece at the relevant point. Use the above split and properties of linear maps to break the expression into the sum of fderiv(x), fderiv(y^3 + 2y^2 - 3y), and subtract the constant part. Show that \u2207(x) at (-6,2) dot (x-(-6), y-2) = (x-(-6)) * 1. Use function composition to write the function as a composition with projection onto the first coordinate. Use rules of derivative to identify the result. Use properties of linear maps to transform to the desired algebraic form. Argue differentiability of the relevant map. Show that \u2207(y^3 + 2y^2 - 3y) at (-6,2) dot (x-(-6), y-2) = (y-2) * 17. Use function composition with projection onto the second coordinate. Use derivative rules for addition, multiplication, and powers to simplify. Use linear map properties and direct computation to reach the correct coefficient. Argue differentiability. Show that \u2207(c), being constant, gives zero when evaluated in dot product with any vector. Substitute results from steps 5, 6, and 7 back into the expanded hypothesis and simplify to get (x-(-6)) * 1 + (y-2) * 17 = 0. Justify differentiability at all necessary points for each function considered and their sums, differences, and compositions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 - 4 * p.1 + 4 * p.2 ^ 2 + p.2 - c) ((0:\u211d), (1:\u211d)) (x-0, y-1) = 0) \u2192 ((x-0) * (-4) + (y-1) * (9) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 - 4 * p.1) ((0:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((0:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 - 4 * p.1 + 4 * p.2 ^ 2 + p.2) ((0:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 - 4 * p.1) ((0:\u211d), (1:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((0:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 - 4 * p.1) ((0:\u211d), (1:\u211d))) (x - 0, y - 1) = (x-0) * (-4)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 - 4 * p.1) = (fun x => x ^ 2 - 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((0:\u211d), (1:\u211d))) (x - 0, y - 1) = (y-1) * (9)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2 + p.2) = (fun x => 4 * x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (1:\u211d)) (x - 0, y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 - 4x + 4y^2 + y - c = 0 at the point (0,1) is (x-0)*(-4) + (y-1)*9 = 0. The method is to compute the gradient (\u2207) of f(x,y) = x^2 - 4x + 4y^2 + y - c at (0,1), then use its dot product with (x-0, y-1), the shifted position vector. Setting that equal to 0 gives the tangent line equation, and the aim is to show it's equivalent to (x-0)*(-4) + (y-1)*9 = 0.  Introduce the hypothesis: the dot product of the gradient at (0,1) with (x-0, y-1) is zero. Apply the derivative rule for subtraction to write \u2207(x^2 - 4x + 4y^2 + y - c) = \u2207(x^2 - 4x + 4y^2 + y) - \u2207(c) Define an intermediate hypothesis splitting \u2207(x^2 - 4x + 4y^2 + y) as \u2207(x^2 - 4x) + \u2207(4y^2 + y), given differentiability of the terms. Use the linearity of the total derivative to rewrite and split up the tangent equation and distribute over addition and subtraction. Show the result of evaluating the derivative of x^2 - 4x at (0,1) and applying it to (x-0, y-1) gives (x-0)*(-4): Observe that x^2 - 4x is a function of one variable, so its gradient in \u211d^2 is calculated via composition. Compute the one-variable derivative at the required point. Apply the structure of the linear map and verify the formula step by step. Argue differentiability of x^2 - 4x as required. Show that the derivative of 4y^2 + y at (0,1) applied to (x-0, y-1) is (y-1)*9: View 4y^2 + y via composition and reduce to a one-variable problem in y. Compute the one-variable derivative at the relevant point. Apply the linear map as above and simplify the result. Argue differentiability of 4y^2 + y. Prove that the derivative of the constant term c vanishes when applied to any vector. Substitute all the above into the main equation and simplify to reach the form (x-0)*(-4) + (y-1)*9 = 0. Justify the differentiability of all terms used along the way to ensure all steps are valid."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 - 4 * p.1 ^ 2 - 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - p.2 - c) ((2:\u211d), (1:\u211d)) (x-2, y-1) = 0) \u2192 ((x-2) * (44) - (y-1) * (6) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3 - 4 * p.1 ^ 2) ((2:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + p.2) ((2:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 - 4 * p.1 ^ 2 - 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - p.2) ((2:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3 - 4 * p.1 ^ 2) ((2:\u211d), (1:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + p.2) ((2:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3 - 4 * p.1 ^ 2) ((2:\u211d), (1:\u211d))) (x - 2, y - 1) = (x-2) * (44)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3 - 4 * p.1 ^ 2) = (fun x => 5 * x ^ 3 - 4 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + p.2) ((2:\u211d), (1:\u211d))) (x - 2, y - 1) = (y-1) * (6)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + p.2) = (fun x => 3 * x ^ 3 - 2 * x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (1:\u211d)) (x - 2, y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5x\u00b3 - 4x\u00b2 - 3y\u00b3 + 2y\u00b2 - y - c = 0 at the point (2,1) is (x-2) * 44 - (y-1) * 6 = 0. The main idea is to compute the gradient (\u2207) of the function f(x,y) = 5x\u00b3 - 4x\u00b2 - 3y\u00b3 + 2y\u00b2 - y - c at the point (2,1), and then take the dot product of this gradient with the vector (x-2, y-1), which gives the tangent line at (2,1). Setting this equal to zero yields the tangent equation, which we want to show matches (x-2)*44 - (y-1)*6=0.  Introduce the hypothesis, which sets the dot product of the gradient at (2,1) with the displacement vector (x-2, y-1) equal to 0. Use the rule for the derivative of a subtraction to split the gradient: \u2207(5x\u00b3 - 4x\u00b2 - 3y\u00b3 + 2y\u00b2 - y - c) = \u2207(5x\u00b3 - 4x\u00b2 - 3y\u00b3 + 2y\u00b2 - y) - \u2207(c) Create a helper claim to further split the gradient: \u2207(5x\u00b3 - 4x\u00b2 - 3y\u00b3 + 2y\u00b2 - y) = \u2207(5x\u00b3 - 4x\u00b2) - \u2207(3y\u00b3 - 2y\u00b2 + y). Assume differentiability at (2,1) for both component functions. Use this split and properties of linear maps to write the gradient as \u2207(5x\u00b3 - 4x\u00b2) - \u2207(3y\u00b3 - 2y\u00b2 + y) - \u2207(c). Show that evaluating \u2207(5x\u00b3 - 4x\u00b2) at (2,1) and applying it to (x-2, y-1) yields (x-2) * 44. Use composition of functions and corresponding rules of derivatives to reduce to a one-variable derivative with respect to x. Compute the partial derivative of 5x\u00b3 - 4x\u00b2 at x=2. By properties of linear maps, show this matches (x-2)*44. Justify differentiability of 5x\u00b3 - 4x\u00b2 at the required point. Show that evaluating \u2207(3y\u00b3 - 2y\u00b2 + y) at (2,1) and applying it to (x-2, y-1) yields (y-1)*6. Use composition rules and derivative rules to reduce to the one-variable case with respect to y. Compute the partial derivative of 3y\u00b3 - 2y\u00b2 + y at y=1. Using linear map properties, match this to (y-1)*6. Justify differentiability of 3y\u00b3 - 2y\u00b2 + y at the required point. Show that the gradient of the constant term c at (2,1), applied to (x-2, y-1), yields zero. Substitute these results back into the original hypothesis, simplify, and deduce the tangent equation. Provide justification for differentiability of each component function at the required points."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 + 4 * p.2 ^ 3 + p.2 - c) ((4:\u211d), (-1:\u211d)) (x-4, y-(-1)) = 0) \u2192 ((x-4) * (192) + (y-(-1)) * (13) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3) ((4:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 + p.2) ((4:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 + 4 * p.2 ^ 3 + p.2) ((4:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3) ((4:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 + p.2) ((4:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3) ((4:\u211d), (-1:\u211d))) (x - 4, y - (-1)) = (x-4) * (192)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3) = (fun x => 4 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 + p.2) ((4:\u211d), (-1:\u211d))) (x - 4, y - (-1)) = (y-(-1)) * (13)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 + p.2) = (fun x => 4 * x ^ 3 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (-1:\u211d)) (x - 4, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 + 4 * y^3 + y - c = 0 at the point (4,\u202f-1) is (x-4) * 192 + (y-(-1)) * 13 = 0. The idea is to calculate the gradient (\u2207) of the function f(x,\u202fy)\u202f=\u202f4 * x^3 + 4 * y^3 + y - c at the point (4,\u202f-1), then take the dot product of this gradient with the shifted positional vector (x-4,\u202fy-(-1)). Setting this equal to zero gives the equation of the tangent, and we must show this matches (x-4) * 192 + (y-(-1)) * 13 = 0. Introduce the hypothesis, which states that the dot product of the gradient with the shifted positional vector equals zero. Apply the rule for the derivative of a subtraction to separate the gradient as \u2207(4 * x^3 + 4 * y^3 + y - c) = \u2207(4 * x^3 + 4 * y^3 + y) - \u2207(c). Define a hypothesis splitting the gradient of the sum: \u2207(4 * x^3 + 4 * y^3 + y) = \u2207(4 * x^3) + \u2207(4 * y^3 + y). Assume differentiability for each summand at the point. Use this decomposition and properties of linear maps to split the directional derivative accordingly. Show that \u2207(4*x^3) at (4,-1), applied to (x-4,\u202fy-(-1)), gives (x-4) * 192. Use composition rules to recognize the partial w.r.t. the x variable. Compute the derivative w.r.t x at x=4 for 4*x^3. Apply the continuous linear map to the vector and simplify. Establish differentiability of 4*x^3 at the point. Show that \u2207(4*y^3 + y) at (4,-1), applied to (x-4,\u202fy-(-1)), gives (y-(-1)) * 13. Use composition rules to recognize the partial w.r.t. the y variable. Compute the derivative w.r.t y at y=-1 for 4*y^3 + y. Apply the continuous linear map to the vector and simplify. Establish differentiability of 4*y^3 + y at the point. Show that the gradient of the constant c applied to any vector is zero. Substitute all these computed values back into the original hypothesis and simplify the resulting equation. Justify all differentiability requirements used above for each function and the relevant composition."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 4 + 4 * p.1 ^ 2 + 3 * p.2 ^ 2 + 3 * p.2 - c) ((-3:\u211d), (-3:\u211d)) (x-(-3), y-(-3)) = 0) \u2192 ((x-(-3)) * (-240) + (y-(-3)) * (-15) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 4 + 4 * p.1 ^ 2) ((-3:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 2 + 3 * p.2) ((-3:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 4 + 4 * p.1 ^ 2 + 3 * p.2 ^ 2 + 3 * p.2) ((-3:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 4 + 4 * p.1 ^ 2) ((-3:\u211d), (-3:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2 ^ 2 + 3 * p.2) ((-3:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 4 + 4 * p.1 ^ 2) ((-3:\u211d), (-3:\u211d))) (x - (-3), y - (-3)) = (x-(-3)) * (-240)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 4 + 4 * p.1 ^ 2) = (fun x => 2 * x ^ 4 + 4 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 2 + 3 * p.2) ((-3:\u211d), (-3:\u211d))) (x - (-3), y - (-3)) = (y-(-3)) * (-15)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 2 + 3 * p.2) = (fun x => 3 * x ^ 2 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-3:\u211d)) (x - (-3), y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^4 + 4 * x^2 + 3 * y^2 + 3 * y - c = 0 at the point (-3, -3) is (x-(-3)) * (-240) + (y-(-3)) * (-15) = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = 2 * x^4 + 4 * x^2 + 3 * y^2 + 3 * y - c at the point (-3, -3), then form the dot product of this gradient with the shifted position vector (x-(-3), y-(-3)). Setting this equal to 0 yields the tangent line, which we must show matches the given equation. Introduce the hypothesis: the dot product of the gradient and the shifted positional vector is zero. Apply differentiation rules to split the gradient: \u2207(2 * x^4 + 4 * x^2 + 3 * y^2 + 3 * y - c) = \u2207(2 * x^4 + 4 * x^2 + 3 * y^2 + 3 * y) - \u2207(c). Define a hypothesis that further splits the sum part: \u2207(2 * x^4 + 4 * x^2 + 3 * y^2 + 3 * y) = \u2207(2 * x^4 + 4 * x^2) + \u2207(3 * y^2 + 3 * y), assuming differentiability of these parts. Use the above splitting and properties of linear maps to write the gradient as \u2207(2 * x^4 + 4 * x^2) + \u2207(3 * y^2 + 3 * y) - \u2207(c). Show that \u2207(2 * x^4 + 4 * x^2) at (-3, -3) evaluated on (x-(-3), y-(-3)) simplifies to (x-(-3)) * (-240): Express this function as a composition to reduce to a single-variable derivative. Apply single-variable derivative rules and evaluate at x = -3. Use the linear map properties and algebraic simplification to reach the answer. Prove differentiability of 2 * x^4 + 4 * x^2. Show that \u2207(3 * y^2 + 3 * y) at (-3, -3) evaluated on (x-(-3), y-(-3)) becomes (y-(-3)) * (-15): Write as a composition to reduce to single-variable in y. Apply single-variable differentiation at y = -3. Use the linear map properties and algebraic simplification. Prove differentiability of 3 * y^2 + 3 * y. Show that \u2207(c) at (-3, -3) evaluated on the vector is zero (the gradient of a constant is zero). Substitute the results from steps 5, 6, and 7 back into the original equation, and conclude by algebraic simplification. Verify the differentiability of all the constituent functions as needed."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 + p.1 + 4 * p.2 ^ 2 - c) ((2:\u211d), (-3:\u211d)) (x-2, y-(-3)) = 0) \u2192 ((x-2) * (17) + (y-(-3)) * (-24) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2 + p.1) ((2:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 + p.1 + 4 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2 + p.1) ((2:\u211d), (-3:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 2) ((2:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2 + p.1) ((2:\u211d), (-3:\u211d))) (x - 2, y - (-3)) = (x-2) * (17)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2 + p.1) = (fun x => 4 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2) ((2:\u211d), (-3:\u211d))) (x - 2, y - (-3)) = (y-(-3)) * (-24)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2) = (fun x => 4 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (-3:\u211d)) (x - 2, y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4*x^2 + x + 4*y^2 - c = 0 at the point (2, -3) is (x-2) * 17 + (y+3) * (-24) = 0 (noting y-(-3)=y+3). The idea is to compute the total derivative (gradient) of f(x, y) = 4*x^2 + x + 4*y^2 - c at (2, -3), then express the tangent line as the dot product of this gradient with the shift vector (x-2, y+3), set it equal to 0, and show that it matches the required equation. Introduce the hypothesis: the dot product of the gradient at (2, -3) with (x-2, y+3), set to 0. Use the derivative subtraction rule to split the gradient as \u2207(4*x^2 + x + 4*y^2 - c) = \u2207(4*x^2 + x + 4*y^2) - \u2207(c). Give a hypothesis that \u2207(4*x^2 + x + 4*y^2) = \u2207(4*x^2 + x) + \u2207(4*y^2), assuming differentiability at each piece. Rewrite the main hypothesis using the above splitting as sums of the directional derivatives, using properties of linear maps to split the operations on the sum. Show that \u2207(4*x^2 + x) at (2, -3) dotted with (x-2, y+3) gives (x-2)*17. Express (4*p.1^2 + p.1) as a composition and split the total derivative accordingly. Calculate the derivative with respect to x at the point of interest. Use appropriate linear map calculations to obtain the 17 coefficient. Justify differentiability. Show that \u2207(4*y^2) at (2, -3) dotted with (x-2, y+3) gives (y+3)*(-24). Express (4*p.2^2) as a composition and use chain rule accordingly. Calculate the derivative with respect to y at the point. Use linear map properties to connect to the -24 coefficient. Justify differentiability. Show that the derivative of the constant c with respect to (x, y) vanishes. Substitute the results for each term in the main hypothesis and simplify to obtain the target equation. Justify the differentiability of all component functions and their combinations throughout the computation."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 - p.2 ^ 4 - 2 * p.2 ^ 2 - 5 * p.2 - c) ((3:\u211d), (1:\u211d)) (x-3, y-1) = 0) \u2192 ((x-3) * (1) - (y-1) * (13) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1) ((3:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) ((3:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 - p.2 ^ 4 - 2 * p.2 ^ 2 - 5 * p.2) ((3:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1) ((3:\u211d), (1:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) ((3:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1) ((3:\u211d), (1:\u211d))) (x - 3, y - 1) = (x-3) * (1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1) = (fun x => x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) ((3:\u211d), (1:\u211d))) (x - 3, y - 1) = (y-1) * (13)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) = (fun x => x ^ 4 + 2 * x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (1:\u211d)) (x - 3, y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst\n  exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x - y^4 - 2y^2 - 5y - c = 0 at the point (3,1) is (x-3) * (1) - (y-1) * (13) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = x - y^4 - 2y^2 - 5y - c at the point (3,1), then take the dot product with the shifted positional vector (x-3, y-1). Setting this equal to 0 gives the equation of the tangent, which we need to show is (x-3) * (1) - (y-1) * (13) = 0. Introduce the hypothesis stating the gradient (at (3,1)) dotted with (x-3, y-1) is zero. Apply the rule for the derivative of a subtraction, splitting \u2207(x - y^4 - 2y^2 - 5y - c) as \u2207(x - y^4 - 2y^2 - 5y) - \u2207(c). Show that \u2207(x - y^4 - 2y^2 - 5y) = \u2207(x) - \u2207(y^4 + 2y^2 + 5y), assuming differentiability. Use this splitting together with properties of linear maps to obtain a form involving only the gradients of x, y^4 + 2y^2 + 5y, and c. Show that the gradient of x at (3,1), applied to (x-3, y-1), is (x-3) * (1): Recognize the function p \u21a6 p.1 as the composition of projection and identity. Compute its gradient and evaluate. Show that the gradient of y^4 + 2y^2 + 5y at (3,1), applied to (x-3, y-1), is (y-1) * (13): Recognize this as a function of one variable in the y-slot. Find the derivative with respect to y and evaluate at y = 1. Compute the linear map application using the previously computed value. Show that the gradient of c (a constant function) is zero when applied to (x-3, y-1). Substitute all the above evaluations back into the original hypothesis and simplify. Ensure differentiability for each relevant function at the required points to justify applying the above steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - 4 * p.1 ^ 2 + p.1 - 4 * p.2 ^ 4 - c) ((3:\u211d), (3:\u211d)) (x-3, y-3) = 0) \u2192 ((x-3) * (4) - (y-3) * (432) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + p.1) ((3:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 4) ((3:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - 4 * p.1 ^ 2 + p.1 - 4 * p.2 ^ 4) ((3:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + p.1) ((3:\u211d), (3:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 4) ((3:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - 4 * p.1 ^ 2 + p.1) ((3:\u211d), (3:\u211d))) (x - 3, y - 3) = (x-3) * (4)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - 4 * p.1 ^ 2 + p.1) = (fun x => x ^ 3 - 4 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 4) ((3:\u211d), (3:\u211d))) (x - 3, y - 3) = (y-3) * (432)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 4) = (fun x => 4 * x ^ 4) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (3:\u211d)) (x - 3, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 - 4x^2 + x - 4y^4 - c = 0 at the point (3,3) is (x-3) * 4 - (y-3) * 432 = 0. The method is to compute the gradient (\u2207) of the function f(x, y) = x^3 - 4x^2 + x - 4y^4 - c at (3, 3), then take the dot product with (x-3, y-3). Setting this equal to zero gives the tangent equation, which should simplify to the desired form.  Introduce the hypothesis: the dot product of the gradient (at (3, 3)) with the displacement vector (x-3, y-3) is zero. Use the differentiation rule for subtraction to split \u2207(x^3 - 4x^2 + x - 4y^4 - c) into \u2207(x^3 - 4x^2 + x - 4y^4) minus \u2207(c). Define a hypothesis that further splits \u2207(x^3 - 4x^2 + x - 4y^4) into \u2207(x^3 - 4x^2 + x) minus \u2207(4y^4), assuming differentiability of these components at (3, 3). Use this decomposition and linear map properties to re-express the gradient action at (3, 3). Show that \u2207(x^3 - 4x^2 + x) at (3, 3) dot (x-3, y-3) equals (x-3) * 4: Rewrite (x^3 - 4x^2 + x) as a function of x, then use composition and differentiation rules to reduce the fderiv to a simpler form. Compute the derivative with respect to x. Show how the linear map acts on the input vector, simplify, and check that the result is the claimed linear combination. Verify differentiability of x^3 - 4x^2 + x. Show that \u2207(4y^4) at (3, 3) dot (x-3, y-3) equals (y-3) * 432: Factor as a function of y, use composition and differentiation rules as above. Compute the derivative with respect to y. Simplify action of the linear map. Justify differentiability of 4y^4. Show that the derivative of the constant c is zero at (3, 3) for any input vector. Substitute these results back into your overall tangent equation, simplifying the linear combination step by step. At each relevant step, provide justification for differentiability of the compound expressions appearing throughout."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 4 - p.1 ^ 2 + 4 * p.2 ^ 3 + 4 * p.2 - c) ((3:\u211d), (0:\u211d)) (x-3, y-0) = 0) \u2192 ((x-3) * (426) + (y-0) * (4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 4 - p.1 ^ 2) ((3:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 + 4 * p.2) ((3:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 4 - p.1 ^ 2 + 4 * p.2 ^ 3 + 4 * p.2) ((3:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 4 - p.1 ^ 2) ((3:\u211d), (0:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 + 4 * p.2) ((3:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 4 - p.1 ^ 2) ((3:\u211d), (0:\u211d))) (x - 3, y - 0) = (x-3) * (426)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 4 - p.1 ^ 2) = (fun x => 4 * x ^ 4 - x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 + 4 * p.2) ((3:\u211d), (0:\u211d))) (x - 3, y - 0) = (y-0) * (4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 + 4 * p.2) = (fun x => 4 * x ^ 3 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (0:\u211d)) (x - 3, y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^4 - x^2 + 4 * y^3 + 4 * y - c = 0 at the point (3,0) is (x-3) * 426 + (y-0) * 4 = 0. The plan is to compute the gradient \u2207 of f(x,y) = 4 * x^4 - x^2 + 4 * y^3 + 4 * y - c at (3,0), take its dot product with the vector (x-3, y-0), and set that equal to 0; this gives the tangent line equation, which we must show is equivalent to the one above. Introduce the hypothesis, which states that the dot product of the gradient of the function at the base point with the shifted positional vector is 0. Apply the derivative rule for subtraction to split \u2207(4 * x^4 - x^2 + 4 * y^3 + 4 * y - c) into \u2207(4 * x^4 - x^2 + 4 * y^3 + 4 * y) minus the gradient of the constant term. Define a hypothesis splitting the gradient \u2207(4 * x^4 - x^2 + 4 * y^3 + 4 * y) into the sum of the gradients for x and y: Assume differentiability of both pieces at the point (3,0). Justify the sum formula for the gradient, regrouping the terms as needed. Use this splitting to rewrite the original hypothesis in terms of the gradients of x and y parts and subtracting the constant term's gradient. Compute the gradient of 4 * x^4 - x^2 at (3,0) applied to (x-3, y-0): Use composition and projection rules to write this as a composition. Reduce the multidimensional gradient to a single-variable derivative in x. Compute this derivative and evaluate at the relevant point, then express the effect via the linear map. Show differentiability of the x portion. Compute the gradient of 4 * y^3 + 4 * y at (3,0) applied to (x-3, y-0): Use composition and projection rules similarly to above, reduce to single-variable derivative in y. Compute and evaluate, interpret via the linear map. Show differentiability of the y portion. Show that the gradient of the constant c at (3,0) applied to (x-3, y-0) is 0. Substitute the simplified expressions into the main equality, finishing the algebra to obtain the claimed tangent line equation. Make sure to establish differentiability for all relevant parts: both x and y subfunctions as well as their combination and the constant function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 - 3 * p.1 + 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2 - c) ((-3:\u211d), (-1:\u211d)) (x-(-3), y-(-1)) = 0) \u2192 ((x-(-3)) * (-9) + (y-(-1)) * (23) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 - 3 * p.1) ((-3:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) ((-3:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 - 3 * p.1 + 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) ((-3:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 - 3 * p.1) ((-3:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) ((-3:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 - 3 * p.1) ((-3:\u211d), (-1:\u211d))) (x - (-3), y - (-1)) = (x-(-3)) * (-9)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 - 3 * p.1) = (fun x => x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) ((-3:\u211d), (-1:\u211d))) (x - (-3), y - (-1)) = (y-(-1)) * (23)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 - 3 * p.2 ^ 2 + 5 * p.2) = (fun x => 4 * x ^ 3 - 3 * x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-1:\u211d)) (x - (-3), y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 - 3x + 4y^3 - 3y^2 + 5y - c = 0 at the point (-3, -1) is (x-(-3)) * (-9) + (y-(-1)) * (23) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = x^2 - 3x + 4y^3 - 3y^2 + 5y - c at the point (-3, -1), then take the dot product of the gradient with the shifted position vector (x - (-3), y - (-1)). Setting that equation equal to 0 will give us the equation of the tangent, which needs to be shown to be equivalent to (x-(-3)) * (-9) + (y-(-1)) * (23) = 0.  Introduce the hypothesis, which is that the dot product of the gradient at the point with (x - (-3), y - (-1)) is 0. Use the derivative rule for subtraction to split the gradient: \u2207(x^2 - 3x + 4y^3 - 3y^2 + 5y - c) = \u2207(x^2 - 3x + 4y^3 - 3y^2 + 5y) - \u2207(c). Define a hypothesis to split \u2207(x^2 - 3x + 4y^3 - 3y^2 + 5y) = \u2207(x^2 - 3x) + \u2207(4y^3 - 3y^2 + 5y), assuming the function is differentiable at (x^2 - 3x) and (4y^3 - 3y^2 + 5y). Use the above and properties of linear maps to rewrite the gradient of the function as a sum/difference of the gradients of its parts. Show that \u2207(x^2 - 3x) at (-3, -1), acting on (x-(-3), y-(-1)), corresponds to (x-(-3)) * (-9). Use composition rules to reduce the partial gradient with respect to x to a simple derivative. Compute the derivative with respect to x. Expand using linearity to obtain the final form. Justify the differentiability of x^2 - 3x. Show that \u2207(4y^3 - 3y^2 + 5y) at (-3, -1), acting on (x-(-3), y-(-1)), corresponds to (y-(-1)) * (23). Use composition rules to reduce the partial gradient with respect to y to a simple derivative. Compute the derivative with respect to y. Expand using linearity to obtain the final form. Justify the differentiability of 4y^3 - 3y^2 + 5y. Show that \u2207(c) at (-3,-1), acting on (x-(-3), y-(-1)), is 0, since c is a constant. Substitute the computed results back and simplify the original equation. Prove the differentiability of all the relevant sub-functions used in the earlier steps to justify each gradient computation."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 + 4 * p.2 ^ 3 - 4 * p.2 ^ 2 - c) ((-6:\u211d), (5:\u211d)) (x-(-6), y-5) = 0) \u2192 ((x-(-6)) * (-36) + (y-5) * (260) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2) ((-6:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2) ((-6:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 + 4 * p.2 ^ 3 - 4 * p.2 ^ 2) ((-6:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2) ((-6:\u211d), (5:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2) ((-6:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2) ((-6:\u211d), (5:\u211d))) (x - (-6), y - 5) = (x-(-6)) * (-36)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2) = (fun x => 3 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2) ((-6:\u211d), (5:\u211d))) (x - (-6), y - 5) = (y-5) * (260)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 - 4 * p.2 ^ 2) = (fun x => 4 * x ^ 3 - 4 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (5:\u211d)) (x - (-6), y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 + 4 * y^3 - 4 * y^2 - c = 0 at the point (-6, 5) is (x-(-6)) * (-36) + (y-5) * (260) = 0. The main idea is to compute the gradient (\u2207) of the function f(x, y) = 3 * x^2 + 4 * y^3 - 4 * y^2 - c at the point (-6, 5), take its dot product with the shifted positional vector (x-(-6), y-5), and set the result to zero to find the equation of the tangent. We then need to show that this is equivalent to the explicit equation given.  Introduce the hypothesis: the value of the gradient at (-6, 5) applied to (x-(-6), y-5) is zero. Use the subtraction rule to split the derivative: \u2207(3 * x^2 + 4 * y^3 - 4 * y^2 - c) becomes \u2207(3 * x^2 + 4 * y^3 - 4 * y^2) - \u2207(c). Define a hypothesis to further split the derivative: \u2207(3 * x^2 + 4 * y^3 - 4 * y^2) = \u2207(3 * x^2) + \u2207(4 * y^3 - 4 * y^2), assuming differentiability for both pieces at the point. Use this splitting and linear map rules to write: \u2207(3 * x^2 + 4 * y^3 - 4 * y^2 - c) = \u2207(3 * x^2) + \u2207(4 * y^3 - 4 * y^2) - \u2207(c). Compute the first component: Show that \u2207(3 * x^2) at (-6, 5) applied to (x-(-6), y-5) gives (x-(-6)) * (-36). Use the appropriate composition and chain rules to reduce the computation to the simple derivative with respect to x. Compute the required derivatives and carry out the substitution at the given point. Use linear map simplifications. Confirm differentiability of 3 * x^2 at the point. Compute the second component: Show that \u2207(4 * y^3 - 4 * y^2) at (-6, 5) applied to (x-(-6), y-5) gives (y-5) * (260). Use composition and chain rules to reduce to the simple derivative with respect to y. Compute the necessary derivatives and substitute at the given point. Use linear map simplifications. Confirm differentiability of 4 * y^3 - 4 * y^2 at the point. Show that the derivative of the constant c part at the point applied to (x-(-6), y-5) is 0. Substitute the results from the above steps back into the earlier expressions, yielding the final tangent line equation. Justify all differentiability claims required for each of the split parts and combinations thereof."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 + 3 * p.2 - c) ((-3:\u211d), (-3:\u211d)) (x-(-3), y-(-3)) = 0) \u2192 ((x-(-3)) * (2) + (y-(-3)) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((-3:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2) ((-3:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 + 3 * p.2) ((-3:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((-3:\u211d), (-3:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2) ((-3:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((-3:\u211d), (-3:\u211d))) (x - (-3), y - (-3)) = (x-(-3)) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2) ((-3:\u211d), (-3:\u211d))) (x - (-3), y - (-3)) = (y-(-3)) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2) = (fun x => 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-3:\u211d)) (x - (-3), y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to 2x + 3y - c = 0 at the point (-3, -3) is (x-(-3)) * 2 + (y-(-3)) * 3 = 0. The idea is to compute the gradient of f(x, y) = 2x + 3y - c at the point (-3, -3), then take the dot product with the shifted positional vector (x-(-3), y-(-3)), and set it to zero, which yields the equation of the tangent. Introduce the hypothesis, which is that the dot product of the gradient (at (-3,-3)) with the shifted vector (x-(-3), y-(-3)) equals zero. Use the rule for the derivative of a subtraction to rewrite the gradient of (2x + 3y - c) as the gradient of (2x + 3y) minus the gradient of c. State a split lemma writing the gradient of (2x + 3y) as the sum of the gradients of (2x) and (3y), requiring differentiability at those points. Rewrite the original expression using this split and the corresponding linear map rules. Compute the gradient of (2x) at (-3,-3), applied to (x-(-3), y-(-3)), and show that it is (x-(-3))*2. Recognize the function as a composition, so use the chain rule for functions of several variables. Compute the necessary one-variable derivatives. Rewrite the linear map applications and do the simplification to reach the desired result. Argue differentiability as needed for validity. Compute the gradient of (3y) at (-3,-3), applied to (x-(-3), y-(-3)), and show that it is (y-(-3))*3. Interpret as composition and use chain rule for functions of several variables. Compute the derivative with respect to y. Rewrite the map applications and simplify to obtain result. Establish differentiability for this component. Show the constant term\u2019s gradient at (-3,-3) applied to the shifted vector is 0. Substitute results from 5, 6, and 7 into the original hypothesis and simplify. Justify differentiability for all functions used: (2x), (3y), their sum, and the constant."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 + p.2 ^ 2 + 2 * p.2 - c) ((-3:\u211d), (-6:\u211d)) (x-(-3), y-(-6)) = 0) \u2192 ((x-(-3)) * (27) + (y-(-6)) * (-10) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3) ((-3:\u211d), (-6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 + 2 * p.2) ((-3:\u211d), (-6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 + p.2 ^ 2 + 2 * p.2) ((-3:\u211d), (-6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3) ((-3:\u211d), (-6:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 + 2 * p.2) ((-3:\u211d), (-6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3) ((-3:\u211d), (-6:\u211d))) (x - (-3), y - (-6)) = (x-(-3)) * (27)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3) = (fun x => x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 + 2 * p.2) ((-3:\u211d), (-6:\u211d))) (x - (-3), y - (-6)) = (y-(-6)) * (-10)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 + 2 * p.2) = (fun x => x ^ 2 + 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-6:\u211d)) (x - (-3), y - (-6)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst.pow _\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 + y^2 + 2*y - c = 0 at the point (-3,-6) is (x-(-3)) * (27) + (y-(-6)) * (-10) = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = x^3 + y^2 + 2*y - c at the point (-3,-6), then form the dot product with the vector (x-(-3), y-(-6)). Setting this equal to 0 yields the tangent equation, which must be shown equivalent to the desired form. Introduce the hypothesis: the dot product of the gradient of f at (-3,-6) with the shift vector (x-(-3), y-(-6)) is 0. Apply the linearity of the derivative to split the derivative of the overall function as the sum of the derivatives of the parts: \u2207(x^3 + y^2 + 2*y - c) = \u2207(x^3 + y^2 + 2*y) - \u2207(c). Establish, using an auxiliary hypothesis, that the derivative of x^3 + y^2 + 2*y splits as the sum of the derivative of x^3 (in x) and y^2 + 2*y (in y), assuming the necessary differentiability. Substitute this sum of derivatives into the original hypothesis, and use properties of linear maps to break the application of the differential across the sum and difference. Show that the partial derivative with respect to x yields the term (x-(-3)) * (27): Write the function x^3 as a composition, to make use of derivative rules. Use the chain and power rules to compute the derivative at the point. Evaluate the result and obtain the claimed coefficient. Prove differentiability of x^3 at (-3,-6). Show that the partial derivative with respect to y of y^2 + 2*y gives (y-(-6)) * (-10): Write the function y^2 + 2*y as a composition in y. Use sum, constant multiple, and power rules to compute the derivative at the point. Evaluate and confirm the coefficient (-10). Prove differentiability of y^2 + 2*y at (-3,-6). Show that \u2207(c) at (-3,-6) applied to (x-(-3), y-(-6)) yields 0, as c is constant. Substitute and combine all previous results into the original expression, and simplify the equation. Prove all necessary differentiability conditions for the subfunctions to justify the above steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 - 5 * p.1 + p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2 - c) ((1:\u211d), (5:\u211d)) (x-1, y-5) = 0) \u2192 ((x-1) * (3) + (y-5) * (885) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2 - 5 * p.1) ((1:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2) ((1:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 - 5 * p.1 + p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2) ((1:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2 - 5 * p.1) ((1:\u211d), (5:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2) ((1:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2 - 5 * p.1) ((1:\u211d), (5:\u211d))) (x - 1, y - 5) = (x-1) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2 - 5 * p.1) = (fun x => 4 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2) ((1:\u211d), (5:\u211d))) (x - 1, y - 5) = (y-5) * (885)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2) = (fun x => x ^ 4 + 5 * x ^ 3 + x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (5:\u211d)) (x - 1, y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^2 - 5 * x + y^4 + 5 * y^3 + y^2 - c = 0 at the point (1,5) is (x-1) * 3 + (y-5) * 885 = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = 4 * x^2 - 5 * x + y^4 + 5 * y^3 + y^2 - c at (1,5), then form the dot product of this gradient with the shifted vector (x-1, y-5). Setting this to zero gives the tangent equation, and we aim to show this yields (x-1) * 3 + (y-5) * 885 = 0. Introduce the hypothesis: the dot product of the gradient at (1,5) with (x-1, y-5) is zero. Apply the rule of the derivative of a subtraction to break up the gradient: \u2207(4 * x^2 - 5 * x + y^4 + 5 * y^3 + y^2 - c) = \u2207(4 * x^2 - 5 * x + y^4 + 5 * y^3 + y^2) - \u2207(c). Define a statement splitting the gradient of the sum: \u2207(4 * x^2 - 5 * x + y^4 + 5 * y^3 + y^2) = \u2207(4 * x^2 - 5 * x) + \u2207(y^4 + 5 * y^3 + y^2), assuming differentiability at the right points. Apply the splitting and linearity rules to further expand the expression for the gradient at (1,5). Show that the directional derivative for the x-part at (1,5) with the direction (x-1, y-5) is (x-1) * 3: Use chain and product rules to express the gradient with respect to x as a single-variable derivative. Differentiate 4 * x^2 - 5 * x at x = 1 and compute the value. Use linearity properties and algebraic simplification to relate the directional derivative to (x-1) * 3. Demonstrate differentiability of 4 * x^2 - 5 * x at the given point. Show that the directional derivative for the y-part at (1,5) with the direction (x-1, y-5) is (y-5) * 885: Use the chain rule and sum rule to reduce the multi-variable gradient to a single-variable computation. Differentiate y^4 + 5 * y^3 + y^2 at y = 5 and substitute. Use properties of linear maps and arithmetic to establish the required result. Prove differentiability of y^4 + 5 * y^3 + y^2 at y = 5. Show that the directional derivative of the constant part c is zero, using properties of the derivative of a constant. Substitute the results for the x-part, y-part, and constant part into the original hypothesis, simplifying the resulting equation. Verify all claimed differentiabilities for the relevant expressions, ensuring the derivatives used above are valid."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 + 2 * p.1 - 2 * p.2 ^ 3 - 2 * p.2 ^ 2 - 3 * p.2 - c) ((6:\u211d), (-5:\u211d)) (x-6, y-(-5)) = 0) \u2192 ((x-6) * (38) - (y-(-5)) * (133) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 + 2 * p.1) ((6:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3 + 2 * p.2 ^ 2 + 3 * p.2) ((6:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 + 2 * p.1 - 2 * p.2 ^ 3 - 2 * p.2 ^ 2 - 3 * p.2) ((6:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 + 2 * p.1) ((6:\u211d), (-5:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 3 + 2 * p.2 ^ 2 + 3 * p.2) ((6:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 + 2 * p.1) ((6:\u211d), (-5:\u211d))) (x - 6, y - (-5)) = (x-6) * (38)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 + 2 * p.1) = (fun x => 3 * x ^ 2 + 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3 + 2 * p.2 ^ 2 + 3 * p.2) ((6:\u211d), (-5:\u211d))) (x - 6, y - (-5)) = (y-(-5)) * (133)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3 + 2 * p.2 ^ 2 + 3 * p.2) = (fun x => 2 * x ^ 3 + 2 * x ^ 2 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (-5:\u211d)) (x - 6, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 + 2 * x - 2 * y^3 - 2 * y^2 - 3 * y - c = 0 at the point (6, -5) is (x-6) * (38) - (y-(-5)) * (133) = 0. The main idea is to compute the gradient (\u2207) of the function f(x, y) = 3 * x^2 + 2 * x - 2 * y^3 - 2 * y^2 - 3 * y - c at (6, -5), then set the dot product of that gradient with (x-6, y-(-5)) equal to 0, and show this produces the required linear equation for the tangent. Introduce the main hypothesis, which states that the dot product of the gradient at the point with the shifted vector is zero. Apply the rule for differentiating a difference of functions to write the derivative of the whole function as the difference of derivatives. Give a hypothesis that splits the function into x-part and y-part, showing that the total derivative is the difference of the derivatives in x and y directions, assuming differentiation is valid at the point. Use the previous splitting to express the gradient as a difference, and apply properties of linearity for the derivative and linear maps. Show that the partial gradient in the x-direction at (6, -5) evaluated on (x-6, y-(-5)) yields (x-6) * (38) Express the x-part as a composition of functions of one variable. Compute the derivative with respect to x using standard rules. Use the structure of linear maps to extract the x-component and simplify. Justify the differentiability of the x-part at the point. Show that the partial gradient in the y-direction at (6, -5) evaluated on (x-6, y-(-5)) gives (y-(-5)) * (133) Express the y-part as a composition of functions of one variable. Compute the derivative with respect to y using standard rules. Use the structure of linear maps to extract the y-component and simplify. Justify the differentiability of the y-part at the point. Show explicitly that the gradient of the constant function c vanishes when paired with any vector. Substitute all these computations back into the hypothesis, simplify the result using algebra and logic to extract the required form. Provide justification for all differentiability claims asserted in previous steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 + p.2 ^ 4 + 3 * p.2 ^ 3 - 4 * p.2 - c) ((5:\u211d), (-4:\u211d)) (x-5, y-(-4)) = 0) \u2192 ((x-5) * (30) + (y-(-4)) * (-116) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2) ((5:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 - 4 * p.2) ((5:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 + p.2 ^ 4 + 3 * p.2 ^ 3 - 4 * p.2) ((5:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2) ((5:\u211d), (-4:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 - 4 * p.2) ((5:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2) ((5:\u211d), (-4:\u211d))) (x - 5, y - (-4)) = (x-5) * (30)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2) = (fun x => 3 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 3 - 4 * p.2) ((5:\u211d), (-4:\u211d))) (x - 5, y - (-4)) = (y-(-4)) * (-116)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 3 * p.2 ^ 3 - 4 * p.2) = (fun x => x ^ 4 + 3 * x ^ 3 - 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (-4:\u211d)) (x - 5, y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 + y^4 + 3 * y^3 - 4 * y - c = 0 at the point (5, -4) is (x-5) * 30 + (y-(-4)) * (-116) = 0. The plan is to compute the gradient (\u2207) of the function f(x,y) = 3 * x^2 + y^4 + 3 * y^3 - 4 * y - c at the point (5, -4), take the dot product with the shifted vector (x-5, y-(-4)), and show that setting this equal to zero gives the desired equation. Introduce the main hypothesis, which equates the dot product of the gradient at the given point with the shifted vector to zero. Apply the derivative rule for subtraction to split \u2207(3 * x^2 + y^4 + 3 * y^3 - 4 * y - c) into \u2207(3 * x^2 + y^4 + 3 * y^3 - 4 * y) - \u2207(c). Define and prove a statement splitting \u2207(3 * x^2 + y^4 + 3 * y^3 - 4 * y) into \u2207(3 * x^2) + \u2207(y^4 + 3 * y^3 - 4 * y). Assume differentiability at each step. Rewrite the gradient using the previous split, utilizing linear map rules to combine/split terms as necessary. Show that \u2207(3 * x^2) at (5, -4) acting on (x-5, y-(-4)) yields (x-5) * 30. Use the composition structure to reduce to differentiation with respect to x. Compute \u2202/\u2202x of 3 * x^2, plug in x = 5. Evaluate linear maps to extract the coefficient (the partial derivative at the point). Assert/prove the differentiability. Show that \u2207(y^4 + 3 * y^3 - 4 * y) at (5, -4) acting on (x-5, y-(-4)) yields (y-(-4)) * (-116). Use function composition to relate partial derivatives to simple derivatives in y. Compute \u2202/\u2202y of y^4 + 3 * y^3 - 4 * y, plug in y = -4. Use properties of linear maps to extract the result. Prove differentiability. Show that \u2207(c) at (5, -4) acting on (x-5, y-(-4)) is 0 (since c is constant). Substitute results from the previous steps to rewrite the original equation in terms of (x-5) and (y-(-4)). Use suitable algebraic and differentiability facts at each step to justify correctness: 9.1) The differentiability for \u2207(3 * x^2), \u2207(y^4 + 3 * y^3 - 4 * y), their sum, and the constant c."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 + 5 * p.2 ^ 3 + p.2 ^ 2 + p.2 - c) ((6:\u211d), (-2:\u211d)) (x-6, y-(-2)) = 0) \u2192 ((x-6) * (540) + (y-(-2)) * (57) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3) ((6:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3 + p.2 ^ 2 + p.2) ((6:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 + 5 * p.2 ^ 3 + p.2 ^ 2 + p.2) ((6:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3) ((6:\u211d), (-2:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 3 + p.2 ^ 2 + p.2) ((6:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3) ((6:\u211d), (-2:\u211d))) (x - 6, y - (-2)) = (x-6) * (540)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3) = (fun x => 5 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3 + p.2 ^ 2 + p.2) ((6:\u211d), (-2:\u211d))) (x - 6, y - (-2)) = (y-(-2)) * (57)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3 + p.2 ^ 2 + p.2) = (fun x => 5 * x ^ 3 + x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (-2:\u211d)) (x - 6, y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve 5 * x^3 + 5 * y^3 + y^2 + y - c = 0 at the point (6, -2) is (x-6) * 540 + (y-(-2)) * 57 = 0. The general idea is to compute the gradient (\u2207) of the function f(x, y) = 5 * x^3 + 5 * y^3 + y^2 + y - c at the point (6, -2), then take the dot product of this gradient with the shifted positional vector (x-6, y-(-2)). Setting the result equal to zero gives the equation of the tangent line, which must be shown to coincide with (x-6) * 540 + (y-(-2)) * 57 = 0.  Introduce the initial hypothesis, which is the statement that the dot product of the gradient at (6, -2) evaluated on (x-6, y-(-2)) is zero.  Apply the subtraction rule for derivatives to split the derivative of (5 * x^3 + 5 * y^3 + y^2 + y - c) as the derivative of (5 * x^3 + 5 * y^3 + y^2 + y) minus the derivative of the constant c.  Further split the gradient of (5 * x^3 + 5 * y^3 + y^2 + y) into two terms: The gradient of 5 * x^3 (depending only on x) The gradient of (5 * y^3 + y^2 + y) (depending only on y) - Prove that the constituent parts are differentiable at the given point.  Use the various linearity properties of the derivative and linear maps to rewrite and combine the terms, so the overall gradient becomes a sum of two parts at (6, -2), minus the constant part.  Show that the gradient of 5 * x^3 at (6, -2) evaluated on (x-6, y-(-2)) equals (x-6) * 540: Express the function as a composition and use the chain rule for differentiation. Compute the partial derivative with respect to x. Use the structure of continuous linear maps and algebraic simplification to demonstrate this equality. Justify the differentiability of 5 * x^3 at the relevant point.  Show that the gradient of (5 * y^3 + y^2 + y) at (6, -2) evaluated on (x-6, y-(-2)) equals (y-(-2)) * 57: Express the function as a composition and use the chain rule. Compute the partial derivative with respect to y. Use the structure of continuous linear maps and perform the necessary algebra to reach the result. Prove differentiability of 5 * y^3 + y^2 + y at the given point.  Show that the gradient of c at (6, -2) evaluated on (x-6, y-(-2)) is zero, since the derivative of a constant function is zero.  Substitute the above results back into the main hypothesis and algebraically simplify to obtain the desired tangent line equation.  Complete the proof by verifying the differentiability of any required functions at (6, -2), as used in steps above."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 - 2 * p.2 ^ 3 - 3 * p.2 - c) ((-1:\u211d), (0:\u211d)) (x-(-1), y-0) = 0) \u2192 ((x-(-1)) * (-2) - (y-0) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2) ((-1:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3 + 3 * p.2) ((-1:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 - 2 * p.2 ^ 3 - 3 * p.2) ((-1:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2) ((-1:\u211d), (0:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 3 + 3 * p.2) ((-1:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2) ((-1:\u211d), (0:\u211d))) (x - (-1), y - 0) = (x-(-1)) * (-2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2) = (fun x => x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3 + 3 * p.2) ((-1:\u211d), (0:\u211d))) (x - (-1), y - 0) = (y-0) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3 + 3 * p.2) = (fun x => 2 * x ^ 3 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (0:\u211d)) (x - (-1), y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst.pow _\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 - 2y^3 - 3y - c = 0 at the point (-1, 0) is (x-(-1)) * (-2) - (y-0) * (3) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = x^2 - 2y^3 - 3y - c at the point (-1, 0), then take the dot product of the gradient with the shifted position vector (x-(-1), y-0). Setting this equal to 0 gives the equation of the tangent, which we need to show is equivalent to (x-(-1)) * (-2) - (y-0) * (3) = 0.  Introduce the hypothesis, which is the claim that the dot product of the gradient at (-1,0) with (x-(-1), y-0) is zero. Use the rule for the derivative of a subtraction to split the gradient: \u2207(x^2 - 2y^3 - 3y - c) = \u2207(x^2) - \u2207(2y^3 + 3y) - \u2207(c). Define a hypothesis splitting the gradient: \u2207(x^2 - 2y^3 - 3y) = \u2207(x^2) - \u2207(2y^3 + 3y), assuming differentiability at each piece is established. Apply the hypothesis to rewrite the total derivative using linearity and the previous split. Compute the term \u2207(x^2) at (-1,0) dot (x-(-1), y-0) and show it equals (x-(-1)) * (-2): Express x^2 as a function composed with the projection onto the first coordinate. Apply the chain rule for differentiation and the property of the partial derivative. Calculate explicitly using the elementary derivative of x^2 (and evaluate at x = -1). Argue differentiability of the function x \u21a6 x^2. Compute the term \u2207(2y^3 + 3y) at (-1,0) dot (x-(-1), y-0) and show it equals (y-0) * (3): Express 2y^3 + 3y as a function composed with the projection onto the second coordinate. Apply the chain rule and property of the partial on the y-variable. Calculate explicitly using the derivative of 2y^3 + 3y (and evaluate at y = 0). Argue differentiability of the function y \u21a6 2y^3 + 3y. Show that the gradient of the constant c at (-1,0) (dot anything) is zero. Substitute back the explicit expressions from the previous two steps and simplify the resulting equation to get the tangent equation. Verify the differentiability of the constituent functions involved in the above computation."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 + p.2 ^ 2 - 2 * p.2 - c) ((-2:\u211d), (5:\u211d)) (x-(-2), y-5) = 0) \u2192 ((x-(-2)) * (3) + (y-5) * (8) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1) ((-2:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 - 2 * p.2) ((-2:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 + p.2 ^ 2 - 2 * p.2) ((-2:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1) ((-2:\u211d), (5:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 - 2 * p.2) ((-2:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1) ((-2:\u211d), (5:\u211d))) (x - (-2), y - 5) = (x-(-2)) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1) = (fun x => 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 - 2 * p.2) ((-2:\u211d), (5:\u211d))) (x - (-2), y - 5) = (y-5) * (8)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 - 2 * p.2) = (fun x => x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (5:\u211d)) (x - (-2), y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x + y^2 - 2 * y - c = 0 at the point (-2, 5) is (x-(-2)) * 3 + (y-5) * 8 = 0. The main idea is to compute the gradient (\u2207) of the function f(x, y) = 3 * x + y^2 - 2 * y - c at the point (-2, 5), and then to take the dot product of this gradient with the vector (x-(-2), y-5). Setting this expression to zero produces the equation of the tangent line; it remains to show this matches the desired form. Introduce the hypothesis that the dot product of the gradient at (-2,5) with the vector (x-(-2), y-5) is zero. Use the rule for the derivative of a subtraction to break up \u2207(3 * x + y^2 - 2 * y - c) into \u2207(3 * x + y^2 - 2 * y) - \u2207(c). Further decompose \u2207(3 * x + y^2 - 2 * y) into \u2207(3 * x) + \u2207(y^2 - 2 * y), using the rules for the derivative of a sum, and assume each part is differentiable at the given point. Use the above splitting and the properties of linear maps to write the full gradient as \u2207(3 * x) + \u2207(y^2 - 2 * y) - \u2207(c). Calculate the action of \u2207(3 * x) at (-2,5) on (x-(-2), y-5), showing it equals (x-(-2)) * 3. Note that this part only depends on the x-variable, so its partial derivative is 3. Use the composition properties of the derivative to express this as simple multiplication. Argue differentiability of the involved term. Similarly, show that \u2207(y^2 - 2 * y) at (-2,5) acting on (x-(-2), y-5) is (y-5) * 8. Note this function only depends on the y-variable, so its partial derivative is 2y - 2; plug in y = 5. Use the composition and product rules of derivatives to collect terms. Justify the differentiability of this component. Justify that \u2207(c), the gradient of a constant, applied to any vector, gives 0. Substitute the three previous calculations into the equation, reducing to (x-(-2))*3 + (y-5)*8 = 0. Provide differentiability justifications for all the relevant parts computed above."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 - 4 * p.2 ^ 4 - 3 * p.2 ^ 2 + 2 * p.2 - c) ((3:\u211d), (4:\u211d)) (x-3, y-4) = 0) \u2192 ((x-3) * (2) - (y-4) * (1046) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((3:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 4 + 3 * p.2 ^ 2 - 2 * p.2) ((3:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 - 4 * p.2 ^ 4 - 3 * p.2 ^ 2 + 2 * p.2) ((3:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((3:\u211d), (4:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 4 + 3 * p.2 ^ 2 - 2 * p.2) ((3:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((3:\u211d), (4:\u211d))) (x - 3, y - 4) = (x-3) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 4 + 3 * p.2 ^ 2 - 2 * p.2) ((3:\u211d), (4:\u211d))) (x - 3, y - 4) = (y-4) * (1046)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 4 + 3 * p.2 ^ 2 - 2 * p.2) = (fun x => 4 * x ^ 4 + 3 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (4:\u211d)) (x - 3, y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2*x - 4*y^4 - 3*y^2 + 2*y - c = 0 at the point (3,4) is (x-3) * 2 - (y-4) * 1046 = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = 2*x - 4*y^4 - 3*y^2 + 2*y - c at the point (3, 4), then take its dot product with the shifted vector (x-3, y-4). Setting this equal to zero gives the equation for the tangent, which we want to show matches the given explicit linear equation.  Introduce the hypothesis that the dot product of the gradient at (3,4) with (x-3, y-4) is zero. Apply the derivative rule for subtraction to split \u2207(2*x - 4*y^4 - 3*y^2 + 2*y - c) into \u2207(2*x - 4*y^4 - 3*y^2 + 2*y) - \u2207(c). Create a hypothesis that splits \u2207(2*x - 4*y^4 - 3*y^2 + 2*y) as \u2207(2*x) - \u2207(4*y^4 + 3*y^2 - 2*y), assuming each part is differentiable. Substitute this splitting into the main hypothesis and use rules for subtracting linear maps to split the computation up. Show that \u2207(2*x) at (3, 4) dot (x-3, y-4) equals (x-3)*2: Observe that 2*x depends only on x and its partial derivative with respect to x is constant. Use composition and product rules to get the gradient with respect to the first variable. Show that dotting this with (x-3, y-4) yields (x-3)*2. Prove differentiability for 2*x. Show that \u2207(4*y^4 + 3*y^2 - 2*y) at (3,4) dot (x-3, y-4) equals (y-4)*1046: Recognize this is a function of y only; compute its derivative with respect to y. The gradient is applied only to the second component; calculate the required coefficients. Conclude that applying the linear map to (x-3, y-4) gives (y-4)*1046. Prove differentiability for 4*y^4 + 3*y^2 - 2*y. Show that \u2207(c), being a constant function, applies to (x-3, y-4) as zero. Substitute the individual computed results from steps 5-7 into the main hypothesis. Use algebra (expanding, collecting like terms) to show that the resulting equation is (x-3)*2 - (y-4)*1046 = 0. 10) Check differentiability requirements for all subfunctions: \u2207(2*x), \u2207(4*y^4 + 3*y^2 - 2*y), the full function, and the constant."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 + 3 * p.2 ^ 3 - 4 * p.2 ^ 2 + p.2 - c) ((0:\u211d), (-4:\u211d)) (x-0, y-(-4)) = 0) \u2192 ((x-0) * (0) + (y-(-4)) * (177) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2) ((0:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3 - 4 * p.2 ^ 2 + p.2) ((0:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 + 3 * p.2 ^ 3 - 4 * p.2 ^ 2 + p.2) ((0:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2) ((0:\u211d), (-4:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2 ^ 3 - 4 * p.2 ^ 2 + p.2) ((0:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2) ((0:\u211d), (-4:\u211d))) (x - 0, y - (-4)) = (x-0) * (0)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2) = (fun x => 5 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3 - 4 * p.2 ^ 2 + p.2) ((0:\u211d), (-4:\u211d))) (x - 0, y - (-4)) = (y-(-4)) * (177)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3 - 4 * p.2 ^ 2 + p.2) = (fun x => 3 * x ^ 3 - 4 * x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (-4:\u211d)) (x - 0, y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 + 3 * y^3 - 4 * y^2 + y - c = 0 at the point (0, -4) is (x-0) * 0 + (y-(-4)) * 177 = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = 5 * x^2 + 3 * y^3 - 4 * y^2 + y - c at the given point, and then take the dot product of that gradient with the vector (x-0, y-(-4)). Setting this dot product to zero gives the tangent line equation, which we simplify as required.  Introduce the hypothesis, which asserts that the dot product of the gradient at (0, -4) with (x-0, y-(-4)) equals 0. Apply the derivative rule for subtraction to split \u2207(5 * x^2 + 3 * y^3 - 4 * y^2 + y - c) as \u2207(5 * x^2 + 3 * y^3 - 4 * y^2 + y) - \u2207(c). Define an intermediate result (via a `have` statement) that further splits \u2207(5 * x^2 + 3 * y^3 - 4 * y^2 + y) into the sum of \u2207(5 * x^2) and \u2207(3 * y^3 - 4 * y^2 + y), provided these parts are differentiable at (0, -4). Substitute this sum into the expression for the gradient, expanding the application of linear maps. Show that \u2207(5 * x^2) at (0, -4) evaluated on (x-0, y-(-4)) is (x-0) * 0: Express 5 * x^2 as a composition to make the differentiation with respect to x explicit. Use the chain rule and differentiation rules for polynomial functions to compute the derivative. Apply the linear map to the input vector and simplify to get zero. Justify the differentiability at this point. Show that \u2207(3 * y^3 - 4 * y^2 + y) at (0, -4) evaluated on (x-0, y-(-4)) is (y-(-4)) * 177: Express the function as a composition to enable differentiation with respect to y. Apply sum, difference, and polynomial differentiation rules to compute the derivative at y = -4. Apply the resulting gradient to the input vector to get the coefficient 177. Establish differentiability for this part at the relevant point. Show that the gradient of the constant function c evaluates to zero when applied to any vector. Substitute all these pieces back together, simplifying the calculation of the tangent line\u2019s left-hand side. Confirm differentiability of each component function at the specified point where necessary."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 5 * p.1 - 3 * p.2 ^ 3 - 5 * p.2 - c) ((0:\u211d), (-1:\u211d)) (x-0, y-(-1)) = 0) \u2192 ((x-0) * (-5) - (y-(-1)) * (14) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 5 * p.1) ((0:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3 + 5 * p.2) ((0:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 5 * p.1 - 3 * p.2 ^ 3 - 5 * p.2) ((0:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 5 * p.1) ((0:\u211d), (-1:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 3 + 5 * p.2) ((0:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 5 * p.1) ((0:\u211d), (-1:\u211d))) (x - 0, y - (-1)) = (x-0) * (-5)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 3 + 5 * p.1 ^ 2 - 5 * p.1) = (fun x => 3 * x ^ 3 + 5 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3 + 5 * p.2) ((0:\u211d), (-1:\u211d))) (x - 0, y - (-1)) = (y-(-1)) * (14)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3 + 5 * p.2) = (fun x => 3 * x ^ 3 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (-1:\u211d)) (x - 0, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^3 + 5 * x^2 - 5 * x - 3 * y^3 - 5 * y - c = 0 at the point (0, -1) is (x-0) * (-5) - (y-(-1)) * (14) = 0. The approach is to compute the gradient (\u2207) of f(x, y) = 3 * x^3 + 5 * x^2 - 5 * x - 3 * y^3 - 5 * y - c at the point (0, -1), then form the dot product with the shift vector (x-0, y-(-1)). Setting this equal to zero gives the tangent line equation, which we show is equivalent to the desired result. Introduce the hypothesis: the fact that this dot product of the gradient with the displacement vector equals zero. Apply the derivative rule for subtraction: split the derivative of (3 * x^3 + 5 * x^2 - 5 * x - 3 * y^3 - 5 * y - c) as the difference between the derivatives of (3 * x^3 + 5 * x^2 - 5 * x - 3 * y^3 - 5 * y) and c. Define a hypothesis splitting the gradient of (3 * x^3 + 5 * x^2 - 5 * x - 3 * y^3 - 5 * y) as the difference of the gradients of (3 * x^3 + 5 * x^2 - 5 * x) and (3 * y^3 + 5 * y). Assume differentiability at the needed points. Apply this split and use properties of linear maps to rewrite the original gradient as the difference between these parts. Show that the derivative in x: Use function composition and derivative rules to reduce the partial derivative to the one-variable case. Differentiate with respect to x. Use properties of the linear map and field simplification to get the explicit value (x-0) * (-5). Demonstrate why (3 * x^3 + 5 * x^2 - 5 * x) is differentiable. Show that the derivative in y: Similarly, use function composition and derivative rules to reduce the y-part to one variable. Differentiate with respect to y. Use properties of the linear map and field simplification to get (y-(-1)) * (14). Demonstrate why (3 * y^3 + 5 * y) is differentiable. Show that the derivative of the constant c under this operation is zero when applied to the shift vector. Substitute the explicit formulas just computed for both partials and the constant part and simplify; use algebraic manipulation to bring the equation to the stated tangent form. Supply justifications for all required differentiability hypotheses used in the intermediate steps."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 - 4 * p.2 ^ 2 - c) ((4:\u211d), (-5:\u211d)) (x-4, y-(-5)) = 0) \u2192 ((x-4) * (3) - (y-(-5)) * (-40) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1) ((4:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2) ((4:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 - 4 * p.2 ^ 2) ((4:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1) ((4:\u211d), (-5:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 2) ((4:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1) ((4:\u211d), (-5:\u211d))) (x - 4, y - (-5)) = (x-4) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1) = (fun x => 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2) ((4:\u211d), (-5:\u211d))) (x - 4, y - (-5)) = (y-(-5)) * (-40)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2) = (fun x => 4 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (-5:\u211d)) (x - 4, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to show that the equation of the tangent to the curve 3*x - 4*y^2 - c = 0 at the point (4, -5) is (x-4) * 3 - (y-(-5)) * (-40) = 0. The method is to compute the gradient \u2207 of the function f(x, y) = 3*x - 4*y^2 - c at (4, -5), and take its dot product with the displacement vector (x-4, y-(-5)). Setting this equal to zero gives the tangent equation, and we need to verify this matches the required form. Introduce the hypothesis: the gradient at (4, -5) dot (x-4, y-(-5)) is zero. Use the linearity property to split the derivative fderiv(3 * x - 4 * y^2 - c) into fderiv(3 * x - 4 * y^2) - fderiv(c). Define a hypothesis: fderiv(3 * x - 4 * y^2) = fderiv(3 * x) - fderiv(4 * y^2), assuming differentiability for both terms. Rewrite the derivative in terms of the sum/difference of derivatives, and apply the linearity of continuous linear maps. Explicitly compute the gradient of 3*x evaluated at the point (4, -5), and show its effect on the displacement vector yields (x-4)*3. Use function composition and the chain rule to reduce to single-variable differentiation. Compute the derivative with respect to x at the required point. After simplification, confirm this matches the claimed expression. Justify differentiability of the function 3*x at the point. Explicitly compute the gradient of 4*y^2 at (4, -5) and show its contribution is (y-(-5))*(-40). Use function composition and the chain rule, reducing to a derivative in the y-variable. Compute the appropriate partial derivative and plug in y = -5. Calculate, simplify, and confirm the result matches the expression. Justify differentiability of 4*y^2 at the point. Show that the derivative with respect to the constant c is zero for all inputs. Substitute all intermediate results into the main equation and simplify, confirming the equation matches the required format. Justify differentiability for each function appearing in the argument."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - p.1 ^ 2 - 4 * p.2 ^ 3 - c) ((-3:\u211d), (-6:\u211d)) (x-(-3), y-(-6)) = 0) \u2192 ((x-(-3)) * (33) - (y-(-6)) * (432) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - p.1 ^ 2) ((-3:\u211d), (-6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3) ((-3:\u211d), (-6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - p.1 ^ 2 - 4 * p.2 ^ 3) ((-3:\u211d), (-6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - p.1 ^ 2) ((-3:\u211d), (-6:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 3) ((-3:\u211d), (-6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - p.1 ^ 2) ((-3:\u211d), (-6:\u211d))) (x - (-3), y - (-6)) = (x-(-3)) * (33)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - p.1 ^ 2) = (fun x => x ^ 3 - x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3) ((-3:\u211d), (-6:\u211d))) (x - (-3), y - (-6)) = (y-(-6)) * (432)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3) = (fun x => 4 * x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-6:\u211d)) (x - (-3), y - (-6)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 - x^2 - 4y^3 - c = 0 at the point (-3, -6) is (x-(-3)) * 33 - (y-(-6)) * 432 = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = x^3 - x^2 - 4y^3 - c at the point (-3, -6), then take its dot product with the shifted vector (x-(-3), y-(-6)). Setting that resulting linear equation to zero gives the tangent line equation at the point; we need to show it reduces to (x-(-3)) * 33 - (y-(-6)) * 432 = 0. Introduce the hypothesis, which is the dot product of the gradient at the point with the shift vector being zero. Apply the derivative rule for subtraction to split the gradient: \u2207(x^3 - x^2 - 4y^3 - c) = \u2207(x^3 - x^2 - 4y^3) - \u2207(c). Define a hypothesis that splits further: \u2207(x^3 - x^2 - 4y^3) = \u2207(x^3 - x^2) - \u2207(4y^3). Assume the necessary differentiability at the relevant functions at the point. Use this splitting and properties of linear maps to express \u2207(x^3 - x^2 - 4y^3 - c) as the sum/difference of gradients of the simpler terms, applied to the shift vector. Show that \u2207(x^3 - x^2) at (-3, -6) dot (x-(-3), y-(-6)) = (x-(-3)) * 33: Use function composition and the structure of the function to reduce this to a one-variable derivative in x. Compute the derivative in x of x^3 - x^2 and evaluate it at x = -3. Use properties of linear maps and algebraic manipulation to arrive at the expression. Justify that x^3 - x^2 is differentiable at x = -3. Show that \u2207(4y^3) at (-3, -6) dot (x-(-3), y-(-6)) = (y-(-6)) * 432: Use composition and the structure of the function to reduce to a one-variable derivative in y. Compute the derivative in y of 4y^3 and evaluate it at y = -6. Apply linear map properties and arithmetic simplification. Justify differentiability of 4y^3 at y = -6. Show that \u2207(c) at (-3, -6) dot (x-(-3), y-(-6)) = 0 since c is a constant and its gradient vanishes. Substitute the previous results into the original hypothesis and simplify to obtain the claimed equation. Prove the differentiability of all intermediate functions needed: x^3 - x^2, 4y^3, the sum/difference functions above, and the constant function c."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 - 5 * p.1 - 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 4 * p.2 - c) ((-5:\u211d), (-4:\u211d)) (x-(-5), y-(-4)) = 0) \u2192 ((x-(-5)) * (-35) - (y-(-4)) * (164) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 - 5 * p.1) ((-5:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 - 5 * p.1 - 3 * p.2 ^ 3 + 2 * p.2 ^ 2 - 4 * p.2) ((-5:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 - 5 * p.1) ((-5:\u211d), (-4:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 - 5 * p.1) ((-5:\u211d), (-4:\u211d))) (x - (-5), y - (-4)) = (x-(-5)) * (-35)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 - 5 * p.1) = (fun x => 3 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + 4 * p.2) ((-5:\u211d), (-4:\u211d))) (x - (-5), y - (-4)) = (y-(-4)) * (164)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 3 - 2 * p.2 ^ 2 + 4 * p.2) = (fun x => 3 * x ^ 3 - 2 * x ^ 2 + 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (-4:\u211d)) (x - (-5), y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 - 5 * x - 3 * y^3 + 2 * y^2 - 4 * y - c = 0 at the point (-5, -4) is (x - (-5)) * (-35) - (y - (-4)) * (164) = 0. The plan is to compute the gradient (\u2207) of f(x, y) = 3 * x^2 - 5 * x - 3 * y^3 + 2 * y^2 - 4 * y - c at the point (-5, -4), then consider its action (dot product) on the vector (x - (-5), y - (-4)). Setting this to 0 gives the tangent line, and we need to recognize that this coincides with the provided equation. Introduce the hypothesis, which is that the action of the gradient at (-5, -4) on (x - (-5), y - (-4)) is zero. Apply the derivative rule for subtraction to split the gradient: - \u2207(3 * x^2 - 5 * x - 3 * y^3 + 2 * y^2 - 4 * y - c) = \u2207(3 * x^2 - 5 * x - 3 * y^3 + 2 * y^2 - 4 * y) - \u2207(c) Further split the difference into x- and y- dependent parts with a new hypothesis: - Show that \u2207(3 * x^2 - 5 * x - 3 * y^3 + 2 * y^2 - 4 * y) at (-5, -4) = \u2207(3 * x^2 - 5 * x) at (-5, -4) - \u2207(3 * y^3 - 2 * y^2 + 4 * y) at (-5, -4) Assume differentiability at the relevant points. Use this splitting and properties of linear maps to express the action of the total gradient as the difference of the actions of the x-part and y-part gradients. Show that the x-part: - The action of \u2207(3 * x^2 - 5 * x) at (-5, -4) on (x - (-5), y - (-4)) is (x - (-5)) * (-35) Identify that the function depends only on x and derive the formula for the gradient. Compute the relevant derivative at x = -5. Use simplifications for this variable and show the result. Justify differentiability of the x-part. Show that the y-part: - The action of \u2207(3 * y^3 - 2 * y^2 + 4 * y) at (-5, -4) on (x - (-5), y - (-4)) is (y - (-4)) * (164) Identify that the function depends only on y and derive the formula for the gradient. Compute the relevant derivative at y = -4. Simplify to obtain the result. Justify differentiability of the y-part. Show that the gradient of the constant part, \u2207(c), applied to the shift vector is zero. Substitute the computed x and y parts and constant into the earlier expression, and simplify the resulting equation. Ensure and state the differentiability of all required function components at the evaluation point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 + 2 * p.1 ^ 3 - 5 * p.1 + p.2 ^ 4 + 4 * p.2 ^ 2 - 2 * p.2 - c) ((-1:\u211d), (4:\u211d)) (x-(-1), y-4) = 0) \u2192 ((x-(-1)) * (-3) + (y-4) * (286) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 3 - 5 * p.1) ((-1:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 4 * p.2 ^ 2 - 2 * p.2) ((-1:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 + 2 * p.1 ^ 3 - 5 * p.1 + p.2 ^ 4 + 4 * p.2 ^ 2 - 2 * p.2) ((-1:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 3 - 5 * p.1) ((-1:\u211d), (4:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + 4 * p.2 ^ 2 - 2 * p.2) ((-1:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 3 - 5 * p.1) ((-1:\u211d), (4:\u211d))) (x - (-1), y - 4) = (x-(-1)) * (-3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 + 2 * p.1 ^ 3 - 5 * p.1) = (fun x => x ^ 4 + 2 * x ^ 3 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 4 * p.2 ^ 2 - 2 * p.2) ((-1:\u211d), (4:\u211d))) (x - (-1), y - 4) = (y-4) * (286)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 4 * p.2 ^ 2 - 2 * p.2) = (fun x => x ^ 4 + 4 * x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (4:\u211d)) (x - (-1), y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 + 2x^3 - 5x + y^4 + 4y^2 - 2y - c = 0 at the point (-1, 4) is (x-(-1)) * (-3) + (y-4) * (286) = 0. The main idea is to compute the gradient (\u2207) of the function f(x, y) = x^4 + 2x^3 - 5x + y^4 + 4y^2 - 2y - c at (-1, 4), and use the dot product with the shift vector (x-(-1), y-4). Setting this to zero gives the tangent equation; you then verify that it matches the expression given in the conclusion.  Introduce the assumption: The dot product of the gradient with (x-(-1), y-4) is zero. Use the rule for differentiating a difference to write \u2207(x^4 + 2x^3 - 5x + y^4 + 4y^2 - 2y - c) as [\u2207(other terms)] - \u2207(c). Define an intermediate result splitting \u2207(x^4 + 2x^3 - 5x + y^4 + 4y^2 - 2y) as the sum of two gradients: \u2207(x^4 + 2x^3 - 5x) and \u2207(y^4 + 4y^2 - 2y). For this, assert differentiability for those pieces. Using this decomposition, split the original expression (including linear map properties) into a sum/difference of gradient terms. Show that the expression (fderiv \u211d (fun p => p.1 ^ 4 + 2 * p.1 ^ 3 - 5 * p.1) ((-1, 4))) acting on (x + 1, y - 4) equals (x-(-1)) * (-3). Use chain and derivative rules to express the gradient with respect to x. Explicitly compute the required derivatives at x = -1. Follow through the composition and algebraic simplifications to reach the coefficient. Establish differentiability of x^4 + 2x^3 - 5x. Do the same for the y-expression: (fderiv \u211d (fun p => p.2 ^ 4 + 4 * p.2 ^ 2 - 2 * p.2) ((-1, 4))) acting on (x + 1, y - 4) equals (y-4) * (286). Use chain and derivative rules for y. Explicitly compute the derivatives at y = 4. Follow linear map simplifications to show the resulting value. Assert differentiability of y^4 + 4y^2 - 2y. Show that \u2207(c) at (-1, 4) acting on (x+1, y-4) is zero. Combine the results: Substitute the expressions found in steps 5\u20137 to simplify the main hypothesis to (x-(-1)) * (-3) + (y-4) * (286) = 0. Observe and finish with differentiability assertions for all functions used."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - 5 * p.1 ^ 2 - 3 * p.1 + 5 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 + 3 * p.2 - c) ((6:\u211d), (-5:\u211d)) (x-6, y-(-5)) = 0) \u2192 ((x-6) * (45) + (y-(-5)) * (-2582) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - 5 * p.1 ^ 2 - 3 * p.1) ((6:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) ((6:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - 5 * p.1 ^ 2 - 3 * p.1 + 5 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) ((6:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - 5 * p.1 ^ 2 - 3 * p.1) ((6:\u211d), (-5:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) ((6:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - 5 * p.1 ^ 2 - 3 * p.1) ((6:\u211d), (-5:\u211d))) (x - 6, y - (-5)) = (x-6) * (45)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - 5 * p.1 ^ 2 - 3 * p.1) = (fun x => x ^ 3 - 5 * x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) ((6:\u211d), (-5:\u211d))) (x - 6, y - (-5)) = (y-(-5)) * (-2582)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2 + 3 * p.2) = (fun x => 5 * x ^ 4 - x ^ 3 + x ^ 2 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (-5:\u211d)) (x - 6, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 - 5*x^2 - 3*x + 5*y^4 - y^3 + y^2 + 3*y - c = 0 at the point (6, -5) is (x-6) * 45 + (y-(-5)) * (-2582) = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = x^3 - 5*x^2 - 3*x + 5*y^4 - y^3 + y^2 + 3*y - c at the point (6, -5), then form the tangent equation via the dot product of this gradient with the shifted vector (x-6, y-(-5)). We must demonstrate this equation is equivalent to the target linear equation for the tangent. Introduce the hypothesis, encoding the tangent condition: the dot product of the gradient at (6, -5) with (x-6, y-(-5)) is zero. Apply the rule for differentiating the subtraction to split the gradient as \u2207(f - c) = \u2207f - \u2207c, where f(x, y) = x^3 - 5*x^2 - 3*x + 5*y^4 - y^3 + y^2 + 3*y. Define a hypothesis for decomposing the gradient of f into x-dependent and y-dependent parts, i.e., \u2207f = \u2207(x^3 - 5*x^2 - 3*x) + \u2207(5*y^4 - y^3 + y^2 + 3*y), given differentiability. Substitute the gradient decomposition and apply linearity properties to express \u2207f - \u2207c as the sum of the two main gradient terms minus the constant term. Compute the contribution from the x-variable part: Use the chain rule structure to reduce the partial derivative to a univariate derivative. Differentiate x^3 - 5*x^2 - 3*x with respect to x and evaluate at x = 6. Apply the result to (x-6, y-(-5)), using properties of linear maps to isolate the (x-6) dependency. Show that the x-component is (x-6) * 45. Compute the contribution from the y-variable part: Similarly express the partial y-derivative as a univariate derivative in y. Differentiate 5*y^4 - y^3 + y^2 + 3*y with respect to y, evaluated at y = -5. Apply the result to (x-6, y-(-5)), so that this term is (y-(-5)) times a constant. Confirm this constant evaluates to -2582. Show that the constant c is irrelevant since its derivative (with respect to both variables) is zero, so \u2207c at any point dotted with (x-6, y-(-5)) is 0. Substitute the above results into the tangent equation, showing it reduces exactly to (x-6) * 45 + (y-(-5)) * (-2582) = 0. Ensure all partial functions are differentiable at the required points so the computation of the gradient is justified."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 + 2 * p.1 + 4 * p.2 ^ 2 + p.2 - c) ((0:\u211d), (5:\u211d)) (x-0, y-5) = 0) \u2192 ((x-0) * (2) + (y-5) * (41) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((0:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((0:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 + 2 * p.1 + 4 * p.2 ^ 2 + p.2) ((0:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((0:\u211d), (5:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((0:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((0:\u211d), (5:\u211d))) (x - 0, y - 5) = (x-0) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 + 2 * p.1) = (fun x => x ^ 2 + 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((0:\u211d), (5:\u211d))) (x - 0, y - 5) = (y-5) * (41)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2 + p.2) = (fun x => 4 * x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (5:\u211d)) (x - 0, y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 + 2*x + 4*y^2 + y - c = 0 at the point (0,5) is (x-0) * (2) + (y-5) * (41) = 0. The approach is to compute the gradient (\u2207) of the function f(x,y) = x^2 + 2*x + 4*y^2 + y - c at (0,5), take its dot product with the vector (x-0, y-5), then show the resulting equation reduces to the desired tangent equation. Introduce the hypothesis: the gradient of the function at (0,5) dotted with (x-0, y-5) equals 0. Use the linearity of the derivative to separate the derivative of the sum / difference into individual parts: \u2207(x^2 + 2*x + 4*y^2 + y - c) = \u2207(x^2 + 2*x + 4*y^2 + y) - \u2207(c). Define an intermediate result splitting the derivative of (x^2 + 2*x + 4*y^2 + y) into two components: one depending only on x and one on y. Assume the relevant differentiability. Substitute the above decomposition into the hypothesis, and expand the linear map applications using the properties of addition and subtraction. Compute the directional derivative of (x^2 + 2*x) at (0,5), applied to (x-0, y-5), and show that this component equals (x-0) * 2. Recognize that (x^2 + 2*x) only depends on the first coordinate, so use the composition properties to reduce the problem to one variable. Calculate the ordinary derivative with respect to x at x=0. Use properties of linear maps and field simplification to justify the final evaluation. Verify the differentiability of x^2 + 2*x. Compute the directional derivative of (4*y^2 + y) at (0,5), applied to (x-0, y-5), and show this equals (y-5) * 41. Recognize that (4*y^2 + y) only depends on the second coordinate, so use similar function composition reasoning. Calculate the derivative with respect to y at y=5. Use properties of linear maps and field simplification for evaluation. Verify the differentiability of 4*y^2 + y. Show that the directional derivative of the constant function c is zero. Substitute the above results into the hypothesis and simplify to the required tangent equation. Establish all necessary differentiability assumptions for each partial function and for the total function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 - p.1 - 5 * p.2 ^ 2 - c) ((-5:\u211d), (1:\u211d)) (x-(-5), y-1) = 0) \u2192 ((x-(-5)) * (-11) - (y-1) * (10) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 - p.1) ((-5:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2) ((-5:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 - p.1 - 5 * p.2 ^ 2) ((-5:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 - p.1) ((-5:\u211d), (1:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 2) ((-5:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 - p.1) ((-5:\u211d), (1:\u211d))) (x - (-5), y - 1) = (x-(-5)) * (-11)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 - p.1) = (fun x => x ^ 2 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2) ((-5:\u211d), (1:\u211d))) (x - (-5), y - 1) = (y-1) * (10)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2) = (fun x => 5 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (1:\u211d)) (x - (-5), y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 - x - 5y^2 - c = 0 at the point (-5,1) is (x-(-5)) * (-11) - (y-1) * (10) = 0. The general strategy is to compute the gradient (\u2207) of the function f(x,y) = x^2 - x - 5y^2 - c at the given point, then express the tangent line as the vanishing of the dot product between this gradient and the vector (x-(-5), y-1), and show this gives the claimed equation. Introduce the hypothesis: assume that the dot product of the gradient at (-5, 1) with (x-(-5), y-1) is zero. Use the fact that the derivative (gradient) of a sum/difference splits accordingly, so \u2207(x^2 - x - 5y^2 - c) = \u2207(x^2 - x - 5y^2) - \u2207(c). Define a helper result to split \u2207(x^2 - x - 5y^2) as \u2207(x^2 - x) - \u2207(5y^2). For this, assume appropriate differentiability of the relevant functions. Rewrite the gradient and its dot product with the direction vector using the above split and properties of linear maps. Evaluate \u2207(x^2 - x) at (-5,1) applied to (x-(-5), y-1), and show it results in (x-(-5)) * (-11). Use composition and chain rules to relate multivariable gradient to the ordinary derivative with respect to x. Compute the derivative at the specific value, and plug in x-(-5) as the corresponding direction. Complete this calculation with proper application of linear map properties. Evaluate \u2207(5y^2) at (-5,1) applied to (x-(-5), y-1), and show it is (y-1) * (10). Use composition and chain rules to relate multivariable gradient to the ordinary derivative with respect to y. Compute the derivative at the specific value, and plug in y-1 as the corresponding direction. Justify the algebraic simplification with properties of linear maps. Show that \u2207(c) at (-5,1) applied to the tangent direction is zero. Substitute the above computations back into the main equation, simplify, and deduce the tangent line equation as claimed. Conclude by justifying the differentiability conditions for all constituent functions used above."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 + 3 * p.1 - 4 * p.2 ^ 4 + 2 * p.2 ^ 3 + 5 * p.2 ^ 2 + 3 * p.2 - c) ((6:\u211d), (6:\u211d)) (x-6, y-6) = 0) \u2192 ((x-6) * (15) - (y-6) * (3177) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 + 3 * p.1) ((6:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 4 - 2 * p.2 ^ 3 - 5 * p.2 ^ 2 - 3 * p.2) ((6:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 + 3 * p.1 - 4 * p.2 ^ 4 + 2 * p.2 ^ 3 + 5 * p.2 ^ 2 + 3 * p.2) ((6:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 + 3 * p.1) ((6:\u211d), (6:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 4 - 2 * p.2 ^ 3 - 5 * p.2 ^ 2 - 3 * p.2) ((6:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 + 3 * p.1) ((6:\u211d), (6:\u211d))) (x - 6, y - 6) = (x-6) * (15)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 + 3 * p.1) = (fun x => x ^ 2 + 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 4 - 2 * p.2 ^ 3 - 5 * p.2 ^ 2 - 3 * p.2) ((6:\u211d), (6:\u211d))) (x - 6, y - 6) = (y-6) * (3177)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 4 - 2 * p.2 ^ 3 - 5 * p.2 ^ 2 - 3 * p.2) = (fun x => 4 * x ^ 4 - 2 * x ^ 3 - 5 * x ^ 2 - 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (6:\u211d)) (x - 6, y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 + 3x - 4y^4 + 2y^3 + 5y^2 + 3y - c = 0 at the point (6,6) is (x-6) * 15 - (y-6) * 3177 = 0. The idea is to compute the gradient (\u2207) of f(x, y) = x^2 + 3x - 4y^4 + 2y^3 + 5y^2 + 3y - c at (6,6) and take the dot product with the shifted vector (x-6, y-6). Setting this to zero yields the tangent equation at (6,6), and the proof confirms this matches (x-6) * 15 - (y-6) * 3177 = 0.  Introduce the hypothesis, representing the fact that the directional derivative (the dot product of the gradient evaluated at (6,6) with the vector (x-6, y-6)) equals zero. Apply the rule for derivatives of a function minus a constant and split up the main function as a difference of two differentiable functions, allowing the gradient computation to be broken up. Construct a hypothesis that further splits the first function f(x, y) into its x-part and y-part, specifically splitting as the sum/difference of f\u2081(x) = x^2 + 3x and f\u2082(y) = 4y^4 - 2y^3 - 5y^2 - 3y (all as functions on \u211d \u00d7 \u211d). Assume the needed differentiability. Substitute this split into the main equation and use properties of linear maps to split the evaluation of the fderiv at the given vector. Compute the value of the x-part of the gradient at the point and apply it to (x-6, y-6). Show it equals (x-6) * 15. Use function composition properties and the chain rule (for functions of one variable composed with projections). Take the derivative with respect to x at x = 6. Evaluate the linear map, simplify algebraically, and verify the result. Justify differentiability of x^2 + 3x at the point. Compute the value of the y-part of the gradient at the point and apply it to (x-6, y-6). Show it equals (y-6) * 3177. Use function composition and chain rule, and suitable projections for the y-variable. Take the derivative with respect to y at y = 6 of the expression 4y^4 - 2y^3 - 5y^2 - 3y. Evaluate the linear map, simplify algebraically, and verify the result. Prove differentiability of 4y^4 - 2y^3 - 5y^2 - 3y at the point. Show that the gradient of the constant c at (6,6) is zero when applied to any direction vector. Plug in the computed values from steps 5\u20137, simplify the resulting equation, and confirm it matches the desired tangent equation. Intersperse all differentiability statements required for the application of chain rule, sum/difference rules, and the overall multivariable result."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 - 3 * p.2 ^ 2 + p.2 - c) ((2:\u211d), (5:\u211d)) (x-2, y-5) = 0) \u2192 ((x-2) * (2) - (y-5) * (29) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((2:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 2 - p.2) ((2:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 - 3 * p.2 ^ 2 + p.2) ((2:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((2:\u211d), (5:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 2 - p.2) ((2:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((2:\u211d), (5:\u211d))) (x - 2, y - 5) = (x-2) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 2 - p.2) ((2:\u211d), (5:\u211d))) (x - 2, y - 5) = (y-5) * (29)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 2 - p.2) = (fun x => 3 * x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (5:\u211d)) (x - 2, y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x - 3y^2 + y - c = 0 at the point (2,5) is (x-2) * 2 - (y-5) * 29 = 0. The general approach is to compute the gradient (\u2207) of the function f(x, y) = 2x - 3y^2 + y - c at (2, 5), then take the dot product of the gradient with the vector (x-2, y-5). Setting this equal to zero gives the tangent equation, which we show is equivalent to the required form. Introduce the hypothesis: the dot product of the gradient with the vector (x-2, y-5) is zero. Use the linearity and subtraction rules for the derivative to separate the gradient as \u2207(2x - 3y^2 + y - c) = \u2207(2x - 3y^2 + y) - \u2207(c). Introduce a split that further writes \u2207(2x - 3y^2 + y) = \u2207(2x) - \u2207(3y^2 - y). Assume the differentiability of both functions at the required point. Apply this split and expand the expression using the rules for continuous linear maps (subtraction). Show that the gradient of 2x at (2,5), applied to (x-2, y-5), is (x-2) * 2. Use the composition of functions to reduce to the one-variable derivative. Compute the derivative of 2x with respect to x. Use evaluation and simplification to arrive at the result. Confirm differentiability of 2x. Show that the gradient of (3y^2 - y) at (2,5), applied to (x-2, y-5), is (y-5) * 29. Use the composition of functions to reduce to the one-variable derivative. Compute the derivative of 3y^2 - y with respect to y. Use evaluation at y = 5 and simplification to obtain the coefficient. Confirm differentiability of 3y^2 - y. Show that the gradient of the constant c at (2,5), applied to (x-2, y-5), is zero. Substitute the results from steps 5, 6, and 7 into the original hypothesis, and simplify to obtain (x-2) * 2 - (y-5) * 29 = 0. Check differentiability of each function component as required to ensure the previous steps are valid."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 - 2 * p.1 + 2 * p.2 ^ 4 + 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 5 * p.2 - c) ((5:\u211d), (-5:\u211d)) (x-5, y-(-5)) = 0) \u2192 ((x-5) * (18) + (y-(-5)) * (-815) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2 - 2 * p.1) ((5:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 4 + 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 5 * p.2) ((5:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 - 2 * p.1 + 2 * p.2 ^ 4 + 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 5 * p.2) ((5:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2 - 2 * p.1) ((5:\u211d), (-5:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 4 + 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 5 * p.2) ((5:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2 - 2 * p.1) ((5:\u211d), (-5:\u211d))) (x - 5, y - (-5)) = (x-5) * (18)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2 - 2 * p.1) = (fun x => 2 * x ^ 2 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 4 + 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 5 * p.2) ((5:\u211d), (-5:\u211d))) (x - 5, y - (-5)) = (y-(-5)) * (-815)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 4 + 2 * p.2 ^ 3 - 4 * p.2 ^ 2 - 5 * p.2) = (fun x => 2 * x ^ 4 + 2 * x ^ 3 - 4 * x ^ 2 - 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (-5:\u211d)) (x - 5, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^2 - 2 * x + 2 * y^4 + 2 * y^3 - 4 * y^2 - 5 * y - c = 0 at the point (5, -5) is (x-5) * 18 + (y-(-5)) * (-815) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 2 * x^2 - 2 * x + 2 * y^4 + 2 * y^3 - 4 * y^2 - 5 * y - c at the point (5, -5), then take the dot product of this with the shifted positional vector (x-5, y-(-5)), and set it to zero, producing the tangent equation. We must show this leads to the claimed form. Introduce the hypothesis, expressing the condition that the gradient at the point, applied to the shifted position vector, is zero. Apply the derivative rule for subtraction to break up \u2207(2 * x^2 - 2 * x + 2 * y^4 + 2 * y^3 - 4 * y^2 - 5 * y - c) into \u2207(2 * x^2 - 2 * x + 2 * y^4 + 2 * y^3 - 4 * y^2 - 5 * y) minus the gradient of the constant function c. Introduce a hypothesis that further splits \u2207(2 * x^2 - 2 * x + 2 * y^4 + 2 * y^3 - 4 * y^2 - 5 * y) into the sum of the gradients \u2207(2 * x^2 - 2 * x) and \u2207(2 * y^4 + 2 * y^3 - 4 * y^2 - 5 * y) at the point (5, -5), assuming differentiability of these functions at that point. Use the above decomposition and properties of linear maps to rewrite \u2207(full expression) as \u2207(2 * x^2 - 2 * x) + \u2207(2 * y^4 + 2 * y^3 - 4 * y^2 - 5 * y) - \u2207(c). Compute the action of \u2207(2 * x^2 - 2 * x) at (5, -5), applied to (x-5, y-(-5)), and show it equals (x-5) * 18. Note that the gradient with respect to x is obtained using the chain and composition rules, reducing to the ordinary derivative in x. Take the derivative with respect to x and substitute x = 5. Use linear map rules and rearrangement to show the result. Check differentiability of 2 * x^2 - 2 * x. Compute the action of \u2207(2 * y^4 + 2 * y^3 - 4 * y^2 - 5 * y) at (5, -5), applied to (x-5, y-(-5)), and show it equals (y-(-5)) * (-815). Apply chain and composition rules so only the y-variable matters. Differentiate with respect to y, and plug in y = -5. Use linear map rules and algebraic simplification for the coefficient. Establish differentiability of the y-part of the function. Show that the gradient of the constant function c is zero, and so the term \u2207(c) disappears. Assemble the split parts and substitute the computed values into the overall equation, reducing to the form provided. Justify all differentiability conditions for the component functions at the given point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 - 5 * p.2 - c) ((3:\u211d), (1:\u211d)) (x-3, y-1) = 0) \u2192 ((x-3) * (3) - (y-1) * (5) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1) ((3:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2) ((3:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 - 5 * p.2) ((3:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1) ((3:\u211d), (1:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2) ((3:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1) ((3:\u211d), (1:\u211d))) (x - 3, y - 1) = (x-3) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1) = (fun x => 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2) ((3:\u211d), (1:\u211d))) (x - 3, y - 1) = (y-1) * (5)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2) = (fun x => 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (1:\u211d)) (x - 3, y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the line 3 * x - 5 * y - c = 0 at the point (3,1) is (x-3) * 3 - (y-1) * 5 = 0. The idea is to compute the gradient of the function f(x, y) = 3 * x - 5 * y - c at (3,1), and then take the dot product with the vector (x-3, y-1). Equating this to zero gives the tangent equation, and we need to simplify to the desired form. Introduce the hypothesis: the dot product of the gradient at (3,1) with (x-3, y-1) equals zero. Apply the rule for the derivative of a subtraction to split the gradient: \u2207(3 * x - 5 * y - c) = \u2207(3 * x - 5 * y) - \u2207(c). Introduce a hypothesis to split \u2207(3 * x - 5 * y) = \u2207(3 * x) - \u2207(5 * y), assuming the components are differentiable at the point. Break the dot product (fderiv) into components using the linearity of the map. Show that the gradient for 3 * x at (3,1) paired with (x-3, y-1) gives (x-3) * 3: Write 3 * x as a composition and apply the chain rule for differentiation. Compute the required derivatives and show via linear maps that you get (x-3) * 3. Check differentiability of 3 * x at the point. Show that the gradient for 5 * y at (3,1) paired with (x-3, y-1) gives (y-1) * 5: Write 5 * y as a composition and apply the chain rule for differentiation. Compute the required derivatives and show via linear maps that you get (y-1) * 5. Check differentiability of 5 * y at the point. Show that the gradient of the constant c at (3,1) with (x-3, y-1) gives 0. Substitute all previous computations into the initial equation, and simplify using algebraic rules to get the final form (x-3) * 3 - (y-1) * 5 = 0. Prove differentiability of each component and sum as required."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 + 3 * p.1 - 3 * p.2 ^ 4 - p.2 ^ 2 + 2 * p.2 - c) ((2:\u211d), (1:\u211d)) (x-2, y-1) = 0) \u2192 ((x-2) * (11) - (y-1) * (12) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2 + 3 * p.1) ((2:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 4 + p.2 ^ 2 - 2 * p.2) ((2:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 + 3 * p.1 - 3 * p.2 ^ 4 - p.2 ^ 2 + 2 * p.2) ((2:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2 + 3 * p.1) ((2:\u211d), (1:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 4 + p.2 ^ 2 - 2 * p.2) ((2:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2 + 3 * p.1) ((2:\u211d), (1:\u211d))) (x - 2, y - 1) = (x-2) * (11)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2 + 3 * p.1) = (fun x => 2 * x ^ 2 + 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 4 + p.2 ^ 2 - 2 * p.2) ((2:\u211d), (1:\u211d))) (x - 2, y - 1) = (y-1) * (12)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 4 + p.2 ^ 2 - 2 * p.2) = (fun x => 3 * x ^ 4 + x ^ 2 - 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (1:\u211d)) (x - 2, y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^2 + 3 * x - 3 * y^4 - y^2 + 2 * y - c = 0 at the point (2,1) is (x-2) * 11 - (y-1) * 12 = 0. The general idea is to compute the gradient (\u2207) of the function f(x,y) = 2 * x^2 + 3 * x - 3 * y^4 - y^2 + 2 * y - c at (2,1), dot it with the shifted vector (x-2, y-1), set to 0 to obtain the tangent, and simplify to the desired result.  Introduce the hypothesis, which says that the dot product of \u2207f at (2,1) with (x-2, y-1) is 0. Use a derivative rule to split the gradient of the total expression: \u2207(2 * x^2 + 3 * x - 3 * y^4 - y^2 + 2 * y - c) = \u2207(2 * x^2 + 3 * x - 3 * y^4 - y^2 + 2 * y) - \u2207(c) Formulate a hypothesis that splits the gradient: \u2207(2 * x^2 + 3 * x - 3 * y^4 - y^2 + 2 * y) = \u2207(2 * x^2 + 3 * x) - \u2207(3 * y^4 + y^2 - 2 * y) Assume the function is differentiable at both components. Substitute the result of step 3, and use linearity of the gradient and properties of linear maps to re-write the overall expression. Show that the gradient of 2 * x^2 + 3 * x, evaluated at (2,1) and dotted with (x-2, y-1), is (x-2) * 11: Use the composition of functions to justify reduction to a single-variable computation. Compute the derivative with respect to x. Apply linear map rules and algebraic simplification. Prove differentiability of 2 * x^2 + 3 * x. Show that the gradient of 3 * y^4 + y^2 - 2 * y, evaluated at (2,1) and dotted with (x-2, y-1), is (y-1) * 12: Use the composition of functions to justify reduction to a single-variable computation (with respect to y). Compute the derivative with respect to y\u2014be careful with the negative signs from the original subtraction. Apply the rules of linear maps and algebraic simplification. Prove differentiability of 3 * y^4 + y^2 - 2 * y. Show that the gradient of the constant c term is zero when dotted with any vector. Substitute the results for the x-part, y-part, and constant term into the main equation, simplify using algebraic manipulation, and conclude that this is equivalent to the desired tangent equation. At each step, justify all differentiability assumptions used for the functions in question."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 - 3 * p.1 + 5 * p.2 ^ 3 + 4 * p.2 ^ 2 - c) ((-2:\u211d), (1:\u211d)) (x-(-2), y-1) = 0) \u2192 ((x-(-2)) * (-19) + (y-1) * (23) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2 - 3 * p.1) ((-2:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3 + 4 * p.2 ^ 2) ((-2:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 - 3 * p.1 + 5 * p.2 ^ 3 + 4 * p.2 ^ 2) ((-2:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2 - 3 * p.1) ((-2:\u211d), (1:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 3 + 4 * p.2 ^ 2) ((-2:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2 - 3 * p.1) ((-2:\u211d), (1:\u211d))) (x - (-2), y - 1) = (x-(-2)) * (-19)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2 - 3 * p.1) = (fun x => 4 * x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3 + 4 * p.2 ^ 2) ((-2:\u211d), (1:\u211d))) (x - (-2), y - 1) = (y-1) * (23)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3 + 4 * p.2 ^ 2) = (fun x => 5 * x ^ 3 + 4 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (1:\u211d)) (x - (-2), y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^2 - 3 * x + 5 * y^3 + 4 * y^2 - c = 0 at the point (-2,1) is (x-(-2)) * (-19) + (y-1) * (23) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 4 * x^2 - 3 * x + 5 * y^3 + 4 * y^2 - c at (-2, 1), then take the dot product of this gradient with the displacement vector (x-(-2), y-1). Setting this to zero gives the tangent equation, which we show is equivalent to the desired result.  Introduce the hypothesis, which is that the dot product of the gradient at the specified point with the shifted positional vector is zero. Use the rule for the derivative of a subtraction to split the gradient of the original function as \u2207(4 * x^2 - 3 * x + 5 * y^3 + 4 * y^2 - c) = \u2207(4 * x^2 - 3 * x + 5 * y^3 + 4 * y^2) - \u2207(c). State a hypothesis giving that the gradient of (4 * x^2 - 3 * x + 5 * y^3 + 4 * y^2) further splits as the sum of the gradients of (4 * x^2 - 3 * x) and (5 * y^3 + 4 * y^2). Assume both are differentiable at the point. Substitute this hypothesis and manipulate using linearity of the derivative to rewrite in terms of these split gradients. Show that the gradient of (4 * x^2 - 3 * x) at (-2, 1), evaluated along (x-(-2), y-1), gives (x-(-2)) * (-19). Express this function as a composition to extract x-derivative. Compute the needed derivatives using differentiation rules for powers, multiplication, and constants. Use properties of linear maps and algebraic simplification to complete the computation. Confirm differentiability of (4 * x^2 - 3 * x). Show that the gradient of (5 * y^3 + 4 * y^2) at (-2, 1), evaluated along (x-(-2), y-1), gives (y-1) * (23). Express this as composition to extract y-derivative. Compute the derivatives using differentiation rules for powers and constants. Use linear map application and algebraic simplification to finish. Confirm differentiability of (5 * y^3 + 4 * y^2). Show that the gradient of the constant c vanishes when applied to any vector: \u2207(c) = 0. Substitute back all computed pieces into the hypothesis and simplify algebraically to derive (x-(-2)) * (-19) + (y-1) * (23) = 0. Justify the differentiability of all split components and the total function at the required point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 2 - p.1 - 3 * p.2 ^ 2 - 3 * p.2 - c) ((-6:\u211d), (5:\u211d)) (x-(-6), y-5) = 0) \u2192 ((x-(-6)) * (-37) - (y-5) * (33) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 2 - p.1) ((-6:\u211d), (5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 2 + 3 * p.2) ((-6:\u211d), (5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 2 - p.1 - 3 * p.2 ^ 2 - 3 * p.2) ((-6:\u211d), (5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 2 - p.1) ((-6:\u211d), (5:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 2 + 3 * p.2) ((-6:\u211d), (5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 2 - p.1) ((-6:\u211d), (5:\u211d))) (x - (-6), y - 5) = (x-(-6)) * (-37)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 2 - p.1) = (fun x => 3 * x ^ 2 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 2 + 3 * p.2) ((-6:\u211d), (5:\u211d))) (x - (-6), y - 5) = (y-5) * (33)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 2 + 3 * p.2) = (fun x => 3 * x ^ 2 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-6:\u211d), (5:\u211d)) (x - (-6), y - 5) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^2 - x - 3 * y^2 - 3 * y - c = 0 at the point (-6, 5) is (x-(-6)) * (-37) - (y-5) * (33) = 0. The approach is to compute the gradient \u2207 of the function f(x, y) = 3 * x^2 - x - 3 * y^2 - 3 * y - c at the point (-6, 5), and then use its dot product with the vector (x-(-6), y-5). This gives the tangent line at the point, which we must show is equivalent to the desired formula. Introduce the hypothesis: the dot product of the gradient at the point, with the shifted vector (x-(-6), y-5), is zero. Apply the derivative rule for subtraction to split the gradient: \u2207(3 * x^2 - x - 3 * y^2 - 3 * y - c) = \u2207(3 * x^2 - x - 3 * y^2 - 3 * y) - \u2207(c) Define a hypothesis that \u2207(3 * x^2 - x - 3 * y^2 - 3 * y) = \u2207(3 * x^2 - x) - \u2207(3 * y^2 + 3 * y); assume differentiability of the relevant pieces. Use the above result and properties of continuous linear maps to rewrite the tangent expression in terms of these components. Compute \u2207(3 * x^2 - x) at (-6, 5) and evaluate it on (x-(-6), y-5), and show it equals (x-(-6)) * (-37): Use function composition properties and rules for differentiating polynomials in one variable, Apply the chain, product, and sum rules to calculate the derivative with respect to x, Substitute and simplify to see the numerical coefficient, Check differentiability of 3 * x^2 - x. Compute \u2207(3 * y^2 + 3 * y) at (-6, 5) and evaluate it on (x-(-6), y-5), and show it equals (y-5) * (33): Use function composition properties and differentiation rules, Apply product, power, and sum rules for the y-variable, Substitute and simplify to obtain the coefficient 33, Confirm differentiability of 3 * y^2 + 3 * y. Show that \u2207(c) at (-6, 5) applied to (x-(-6), y-5) is 0, using properties of the constant function. Substitute these results back into the original expression, combine and simplify to obtain (x-(-6)) * (-37) - (y-5) * (33) = 0. Justify all differentiability statements used throughout for the involved functions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 + 5 * p.1 - 4 * p.2 - c) ((3:\u211d), (-4:\u211d)) (x-3, y-(-4)) = 0) \u2192 ((x-3) * (35) - (y-(-4)) * (4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((3:\u211d), (-4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2) ((3:\u211d), (-4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 + 5 * p.1 - 4 * p.2) ((3:\u211d), (-4:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((3:\u211d), (-4:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2) ((3:\u211d), (-4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 + 5 * p.1) ((3:\u211d), (-4:\u211d))) (x - 3, y - (-4)) = (x-3) * (35)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 + 5 * p.1) = (fun x => 5 * x ^ 2 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2) ((3:\u211d), (-4:\u211d))) (x - 3, y - (-4)) = (y-(-4)) * (4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2) = (fun x => 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (-4:\u211d)) (x - 3, y - (-4)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 + 5 * x - 4 * y - c = 0 at the point (3, -4) is (x-3) * (35) - (y-(-4)) * (4) = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = 5x^2 + 5x - 4y - c at the point (3, -4), take the dot product with the shifted vector (x-3, y-(-4)), set that equal to zero, and show it reduces to the claimed equation. Introduce the hypothesis: that the dot product of the gradient at (3, -4) with (x-3, y-(-4)) is zero. Use the linearity of the derivative to split up the gradient: \u2207(5x^2 + 5x - 4y - c) = \u2207(5x^2 + 5x - 4y) - \u2207(c). Define a hypothesis splitting \u2207(5x^2 + 5x - 4y) = \u2207(5x^2 + 5x) - \u2207(4y), assuming differentiability of the pieces. Substitute this split and expand the application of linear operators and the structure of the gradient into the dot product. Show that \u2207(5x^2 + 5x) at (3, -4) acting on (x-3, y-(-4)) is (x-3) * 35: Re-express the function as a composition so the gradient reduces to derivatives with respect to x. Compute the derivative with respect to x by applying the appropriate rules. Carefully expand all multiplications and apply simplification to see the coefficient matches 35. Check and mention the differentiability of 5x^2 + 5x. Show that \u2207(4y) at (3, -4) acting on (x-3, y-(-4)) is (y-(-4)) * 4: Again, express as a composition to introduce derivatives with respect to y. Compute the derivative with respect to y and simplify. Verify differentiability for 4y. Show that \u2207(c) at (3, -4) acting on (x-3, y-(-4)) is 0, since the derivative of a constant is zero. Substitute the evaluated results back into the original hypothesis. Combine and simplify the equality, reducing to the claimed tangent equation. Check all implied differentiability conditions for the functions involved."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 3 - p.2 ^ 3 - 3 * p.2 - c) ((-3:\u211d), (-2:\u211d)) (x-(-3), y-(-2)) = 0) \u2192 ((x-(-3)) * (81) - (y-(-2)) * (15) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 3) ((-3:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 3 + 3 * p.2) ((-3:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 3 - p.2 ^ 3 - 3 * p.2) ((-3:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 3) ((-3:\u211d), (-2:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 3 + 3 * p.2) ((-3:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 3) ((-3:\u211d), (-2:\u211d))) (x - (-3), y - (-2)) = (x-(-3)) * (81)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 3) = (fun x => 3 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 3 + 3 * p.2) ((-3:\u211d), (-2:\u211d))) (x - (-3), y - (-2)) = (y-(-2)) * (15)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 3 + 3 * p.2) = (fun x => x ^ 3 + 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-2:\u211d)) (x - (-3), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^3 - y^3 - 3*y - c = 0 at the point (-3, -2) is (x-(-3)) * (81) - (y-(-2)) * (15) = 0. The approach is to calculate the gradient (\u2207) of the function f(x, y) = 3 * x^3 - y^3 - 3*y - c at the point (-3, -2), then consider the dot product with the vector (x-(-3), y-(-2)), and show that this tangent condition is equivalent to the specified equation. Here are the main steps: Introduce the hypothesis that states the dot product of the gradient at the required point with (x-(-3), y-(-2)) equals 0. Use linearity of differentiation to separate the gradient of (3 * x^3 - y^3 - 3*y - c) into the sum/difference of the gradients of its terms. Further split the terms so that \u2207(3 * x^3 - y^3 - 3*y) = \u2207(3 * x^3) - \u2207(y^3 + 3*y), assuming differentiability at each stage. Apply the linear map properties to express the original gradient as the difference between the x-term and y-term contributions. Compute \u2207(3 * x^3) evaluated at the point, and show that its dot product with (x-(-3), y-(-2)) gives (x-(-3)) * 81: Use function composition to view this as a single-variable function composed with a coordinate projection. Apply the chain rule and the rules for derivatives of powers and constants. Use properties of continuous linear maps and basic algebra to arrive at the result. Check and ensure differentiability as needed for these steps. Similarly, compute \u2207(y^3 + 3*y) at the point so that the result is (y-(-2)) * 15: Use function composition as before, for the y-coordinate. Apply the relevant differentiation rules (sum, power, multiplication by constant). Use the linear map properties and algebraic simplification to show the equality. Verify differentiability as needed. Compute the gradient of the constant c, showing that \u2207(c) at any point with any vector is 0. Substitute the results for all terms into the main hypothesis, and apply algebraic simplification to arrive at the target equation for the tangent. Confirm differentiability of all the constituent expressions at the necessary points to ensure that the use of the differential is valid."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + p.1 + p.2 ^ 4 - 3 * p.2 - c) ((-3:\u211d), (-1:\u211d)) (x-(-3), y-(-1)) = 0) \u2192 ((x-(-3)) * (106) + (y-(-1)) * (-7) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + p.1) ((-3:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 - 3 * p.2) ((-3:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 3 + 5 * p.1 ^ 2 + p.1 + p.2 ^ 4 - 3 * p.2) ((-3:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + p.1) ((-3:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 - 3 * p.2) ((-3:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + p.1) ((-3:\u211d), (-1:\u211d))) (x - (-3), y - (-1)) = (x-(-3)) * (106)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 3 + 5 * p.1 ^ 2 + p.1) = (fun x => 5 * x ^ 3 + 5 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 - 3 * p.2) ((-3:\u211d), (-1:\u211d))) (x - (-3), y - (-1)) = (y-(-1)) * (-7)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 - 3 * p.2) = (fun x => x ^ 4 - 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-1:\u211d)) (x - (-3), y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^3 + 5 * x^2 + x + y^4 - 3 * y - c = 0 at the point (-3, -1) is (x-(-3)) * (106) + (y-(-1)) * (-7) = 0. The idea is to calculate the gradient (\u2207) of the function f(x, y) = 5 * x^3 + 5 * x^2 + x + y^4 - 3 * y - c at the point (-3, -1), then take its dot product with the shifted positional vector (x-(-3), y-(-1)), set that equal to 0, and show this matches the desired equation. Introduce the hypothesis, which is that the directional derivative (i.e., the dot product of the gradient at the point with the shifted vector) is zero. Use the derivative rule for subtraction to write \u2207(5 * x^3 + 5 * x^2 + x + y^4 - 3 * y - c) = \u2207(5 * x^3 + 5 * x^2 + x + y^4 - 3 * y) - \u2207(c). Define a hypothesis to split the gradient of (5 * x^3 + 5 * x^2 + x + y^4 - 3 * y) into a sum of \u2207(5 * x^3 + 5 * x^2 + x) and \u2207(y^4 - 3 * y). Assume differentiability of both component functions at the point. Substitute this split into the equation, and apply the rules for linear maps (i.e., addition, subtraction) accordingly. Show that the directional derivative of \u2207(5 * x^3 + 5 * x^2 + x) at (-3, -1) along (x-(-3), y-(-1)) is (x-(-3)) * (106): Use the composition rule to express the function as a composition with projection, and apply the chain rule for the gradient (fderiv). Compute the derivative with respect to x. Apply linear map rules and algebraic simplification to obtain the coefficient 106. Make sure to note (and later provide) the differentiability of 5 * x^3 + 5 * x^2 + x. Show that the directional derivative of \u2207(y^4 - 3 * y) at (-3, -1) along (x-(-3), y-(-1)) is (y-(-1)) * (-7): Use the composition rule to express the function as a composition with projection, and apply the chain rule for the gradient (fderiv). Compute the derivative with respect to y. Apply linear map rules and simplification to obtain -7. Provide the differentiability of y^4 - 3 * y. Show that the gradient of the constant c evaluated at (-3, -1) and any vector is zero. Substitute the above results back into the expression, obtaining the equation involving the given coefficients. At the end, make sure to provide differentiability hypotheses for all relevant component functions and their combinations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 + 4 * p.1 ^ 2 + 5 * p.2 - c) ((-3:\u211d), (0:\u211d)) (x-(-3), y-0) = 0) \u2192 ((x-(-3)) * (30) + (y-0) * (5) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-3:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2) ((-3:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 + 4 * p.1 ^ 2 + 5 * p.2) ((-3:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-3:\u211d), (0:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2) ((-3:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3 + 4 * p.1 ^ 2) ((-3:\u211d), (0:\u211d))) (x - (-3), y - 0) = (x-(-3)) * (30)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3 + 4 * p.1 ^ 2) = (fun x => 2 * x ^ 3 + 4 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2) ((-3:\u211d), (0:\u211d))) (x - (-3), y - 0) = (y-0) * (5)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2) = (fun x => 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (0:\u211d)) (x - (-3), y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^3 + 4 * x^2 + 5 * y - c = 0 at the point (-3,0) is (x-(-3)) * (30) + (y-0) * (5) = 0. The general approach is to compute the gradient (\u2207) of the function f(x, y) = 2 * x^3 + 4 * x^2 + 5 * y - c at the point (-3, 0), then take its dot product with the shifted vector (x-(-3), y-0), meaning the vector from the basepoint to (x, y). Setting this equation equal to zero results in the equation of the tangent, and we will show that this simplifies to (x-(-3)) * (30) + (y-0) * (5) = 0.  Introduce the hypothesis, which is the dot product of the gradient evaluated at the basepoint with the shifted vector set to zero. Apply the derivative rule for subtraction to split \u2207(2 * x^3 + 4 * x^2 + 5 * y - c) = \u2207(2 * x^3 + 4 * x^2 + 5 * y) - \u2207(c). Split the gradient further: express \u2207(2 * x^3 + 4 * x^2 + 5 * y) as \u2207(2 * x^3 + 4 * x^2) + \u2207(5 * y), assuming differentiability at each part. Substitute these expressions and use linearity of the gradient. Show \u2207(2 * x^3 + 4 * x^2) at (-3, 0) dotted with (x-(-3), y-0) equals (x-(-3)) * 30: Note that this function depends only on x, so the gradient is just with respect to x. Compute the required univariate derivatives. Apply the chain rule structure for functions of two variables where only one variable is involved. Justify differentiability of 2 * x^3 + 4 * x^2 at -3. Show that \u2207(5 * y) at (-3, 0) dotted with (x-(-3), y-0) equals (y-0) * 5: Recognize this function only depends on y, so gradient is with respect to y. Compute the required univariate derivative. Again, use the structure of gradients for functions that depend on one variable. Justify differentiability of 5 * y at 0. Show that the gradient of the constant c at any point dotted with any vector is zero. Substitute the above results into the hypothesis, simplify, and deduce the final form of the tangent equation. Check and conclude differentiability of each function involved to ensure the calculation is justified."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 + 5 * p.1 + 2 * p.2 - c) ((-3:\u211d), (6:\u211d)) (x-(-3), y-6) = 0) \u2192 ((x-(-3)) * (-1) + (y-6) * (2) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 + 5 * p.1) ((-3:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2) ((-3:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 + 5 * p.1 + 2 * p.2) ((-3:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 + 5 * p.1) ((-3:\u211d), (6:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2) ((-3:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 + 5 * p.1) ((-3:\u211d), (6:\u211d))) (x - (-3), y - 6) = (x-(-3)) * (-1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 + 5 * p.1) = (fun x => x ^ 2 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2) ((-3:\u211d), (6:\u211d))) (x - (-3), y - 6) = (y-6) * (2)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2) = (fun x => 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (6:\u211d)) (x - (-3), y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 + 5x + 2y - c = 0 at the point (-3, 6) is (x-(-3)) * (-1) + (y-6) * (2) = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = x^2 + 5x + 2y - c at the point (-3, 6), then take the dot product of this gradient with the shifted positional vector (x-(-3), y-6). Setting this equal to 0 gives the equation of the tangent, which should correspond to (x-(-3)) * (-1) + (y-6) * (2) = 0.  Introduce the hypothesis that the dot product of the gradient and the shifted positional vector equals 0. Apply the rule for the derivative of a subtraction to split \u2207(x^2 + 5x + 2y - c) into \u2207(x^2 + 5x + 2y) - \u2207(c). Define a hypothesis to split \u2207(x^2 + 5x + 2y) into \u2207(x^2 + 5x) + \u2207(2y), assuming differentiability at each part. Use linearity of the gradient and rules for linear maps to write the sum and difference of gradients acting on the shifted vector. Show that \u2207(x^2 + 5x) at (-3, 6) acting on (x-(-3), y-6) gives (x-(-3)) * (-1): Use composition and derivative rules to reduce the gradient to a single-variable derivative in x. Compute the derivative with respect to x and substitute (-3). Use properties of linear maps to get the final result of (x-(-3)) * (-1). Justify differentiability of x^2 + 5x. Show that \u2207(2y) at (-3, 6) acting on (x-(-3), y-6) gives (y-6) * (2): Use composition and derivative rules to reduce the gradient to a single-variable derivative in y. Compute the derivative with respect to y. Use properties of linear maps to get the result (y-6) * (2). Justify differentiability of 2y. Show that \u2207(c) at (-3, 6) acting on (x-(-3), y-6) is 0 by using properties of the derivative of a constant. Substitute all previous results into the equation to obtain the necessary statement, and simplify. Justify differentiability for all previously used component functions and combinations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 3 + 4 * p.1 + 4 * p.2 - c) ((1:\u211d), (-6:\u211d)) (x-1, y-(-6)) = 0) \u2192 ((x-1) * (13) + (y-(-6)) * (4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 3 + 4 * p.1) ((1:\u211d), (-6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2) ((1:\u211d), (-6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 3 + 4 * p.1 + 4 * p.2) ((1:\u211d), (-6:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 3 + 4 * p.1) ((1:\u211d), (-6:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2) ((1:\u211d), (-6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 3 + 4 * p.1) ((1:\u211d), (-6:\u211d))) (x - 1, y - (-6)) = (x-1) * (13)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 3 + 4 * p.1) = (fun x => 3 * x ^ 3 + 4 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2) ((1:\u211d), (-6:\u211d))) (x - 1, y - (-6)) = (y-(-6)) * (4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2) = (fun x => 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((1:\u211d), (-6:\u211d)) (x - 1, y - (-6)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x^3 + 4 * x + 4 * y - c = 0 at the point (1, -6) is (x-1) * 13 + (y-(-6)) * 4 = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = 3x^3 + 4x + 4y - c at (1, -6), then take its dot product with the vector (x-1, y-(-6)). Setting this equal to zero gives the tangent equation, which we show is equivalent to (x-1) * 13 + (y-(-6)) * 4 = 0. Introduce the hypothesis: the gradient at (1, -6) dot product (x-1, y-(-6)) equals zero. Use the derivative rule for subtraction to split the gradient: \u2207(3x^3 + 4x + 4y - c) = \u2207(3x^3 + 4x + 4y) - \u2207(c). Introduce a hypothesis that splits \u2207(3x^3 + 4x + 4y) into \u2207(3x^3 + 4x) + \u2207(4y), given differentiability at each part. Use the above splitting and linearity to expand the gradient expression across the components. Show that \u2207(3x^3 + 4x) at (1, -6) dot (x-1, y-(-6)) = (x-1) * 13: Express 3x^3 + 4x as a composition with the first variable, to reduce the fderiv to a one-variable derivative. Apply the sum, constant multiple, and power rules for differentiation. Use rules for linear maps and algebra to simplify to the required result. Prove differentiability of 3x^3 + 4x in x. Show that \u2207(4y) at (1, -6) dot (x-1, y-(-6)) = (y-(-6)) * 4: Express 4y as a composition with the second variable, again reducing to a one-variable derivative. Apply constant multiple and identity rules for differentiation. Use linear map rules and simplify to get the desired result. Prove differentiability of 4y in y. Show that \u2207(c) at (1, -6) dot (x-1, y-(-6)) = 0, since c is a constant. Substitute these results back into the equation, simplify, and deduce the final tangent equation. Justify the differentiability for all component functions involved: 3x^3 + 4x, 4y, their sum, and the constant function c."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 4 + 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 3 * p.1 + 5 * p.2 ^ 3 - c) ((3:\u211d), (3:\u211d)) (x-3, y-3) = 0) \u2192 ((x-3) * (528) + (y-3) * (135) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 4 + 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 3 * p.1) ((3:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3) ((3:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 4 + 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 3 * p.1 + 5 * p.2 ^ 3) ((3:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 4 + 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 3 * p.1) ((3:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 3) ((3:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 4 + 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 3 * p.1) ((3:\u211d), (3:\u211d))) (x - 3, y - 3) = (x-3) * (528)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 4 + 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 3 * p.1) = (fun x => 4 * x ^ 4 + 3 * x ^ 3 + 3 * x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3) ((3:\u211d), (3:\u211d))) (x - 3, y - 3) = (y-3) * (135)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3) = (fun x => 5 * x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (3:\u211d)) (x - 3, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^4 + 3 * x^3 + 3 * x^2 - 3 * x + 5 * y^3 - c = 0 at the point (3,3) is (x-3) * 528 + (y-3) * 135 = 0. The idea is to compute the gradient (\u2207) of the function f(x,y) = 4 * x^4 + 3 * x^3 + 3 * x^2 - 3 * x + 5 * y^3 - c at (3,3), take its dot product with the shifted position vector (x-3, y-3), and set that equal to 0, deriving the tangent equation. Introduce the hypothesis, which is the dot product of the gradient at (3,3) with the vector (x-3, y-3), set to 0. Use the rule for derivatives of differences to rewrite the gradient of f(x,y) as the gradient of 4 * x^4 + 3 * x^3 + 3 * x^2 - 3 * x + 5 * y^3 minus the gradient of the constant c. Introduce a splitting statement for the gradient of 4 * x^4 + 3 * x^3 + 3 * x^2 - 3 * x + 5 * y^3, separating it into the x-dependent part and the y-dependent part. Assume differentiability where needed. Rewrite and combine the terms according to linearity of the gradient and properties of linear maps. Show that the x-part (\u2207 with respect to x of 4 * x^4 + 3 * x^3 + 3 * x^2 - 3 * x) at (3,3) dotted with (x-3, y-3) yields (x-3) * 528. Express the composite function and expand it using rules for derivatives of sums and multiples. Take the derivative with respect to x for each summand, substitute x = 3, and use computation to simplify. Argue that only the x-component survives, and the result is proportional to (x-3). Check the differentiability of the x-polynomial. Show that the y-part (\u2207 with respect to y of 5 * y^3) at (3,3) dotted with (x-3, y-3) yields (y-3) * 135. Express the function and compute the derivative with respect to y, then substitute y = 3. Argue that only the y-component survives, and the result is proportional to (y-3). Check the differentiability of y^3. Show that the gradient of the constant term c at any point dotted with (x-3, y-3) is zero. Substitute results from steps 5, 6, and 7 back into the equation, simplify, and derive the tangent equation. Along the way, establish the necessary differentiability conditions for all pieces involved."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1 - 5 * p.2 - c) ((-5:\u211d), (-5:\u211d)) (x-(-5), y-(-5)) = 0) \u2192 ((x-(-5)) * (-1330) - (y-(-5)) * (5) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1) ((-5:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2) ((-5:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1 - 5 * p.2) ((-5:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1) ((-5:\u211d), (-5:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2) ((-5:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1) ((-5:\u211d), (-5:\u211d))) (x - (-5), y - (-5)) = (x-(-5)) * (-1330)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 4 - 5 * p.1 ^ 3 - 5 * p.1 ^ 2 - 5 * p.1) = (fun x => 2 * x ^ 4 - 5 * x ^ 3 - 5 * x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2) ((-5:\u211d), (-5:\u211d))) (x - (-5), y - (-5)) = (y-(-5)) * (5)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2) = (fun x => 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (-5:\u211d)) (x - (-5), y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^4 - 5 * x^3 - 5 * x^2 - 5 * x - 5 * y - c = 0 at the point (-5, -5) is (x-(-5)) * (-1330) - (y-(-5)) * (5) = 0. The approach is to compute the gradient (\u2207) of f(x, y) = 2x^4 - 5x^3 - 5x^2 - 5x - 5y - c at (-5, -5), then use its dot product with the vector (x-(-5), y-(-5)), set that equal to zero, and show it yields the required form. Introduce the hypothesis, stating that the dot product of the gradient at the shifted point with the vector (x-(-5), y-(-5)) is zero. Use linearity and subtraction rules of derivatives to split the total derivative into fderiv of (2x^4 - 5x^3 - 5x^2 - 5x) minus fderiv of (5y), assuming differentiability at (-5, -5). Use the formal splitting to rewrite the derivative at (-5, -5). Show that \u2207(2x^4 - 5x^3 - 5x^2 - 5x)\u00b7(x-(-5), y-(-5)) = (x-(-5)) * (-1330): 4.1) Express the part depending only on x as a composition and use appropriate rules for partial derivatives. 4.2) Reduce the computation to one variable and compute the derivative with respect to x at x = -5. 4.3) Use algebraic simplification and the rules for applying the linear map to the positional difference vector. 4.4) Justify all differentiability assumptions for this component. Show that \u2207(5y)\u00b7(x-(-5), y-(-5)) = (y-(-5)) * (5): Represent the y-part as a composition; use the rules for the partial derivative with respect to y. Reduce the calculation to one variable, find the derivative at y = -5. Apply the linear map to the appropriate component of the vector. Justify differentiability of this part. Show that \u2207(c), being a constant, contributes 0 to the directional derivative along any vector at any point. Substitute the explicit calculated values for the derivatives at (-5, -5) and simplify the equation fully. Use simplification and arithmetic reasoning to show the equation obtained is equivalent to the claimed tangent equation. Throughout, ensure all differentiability conditions required for splitting and composing the total derivative are justified."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 + p.1 + 3 * p.2 - c) ((-4:\u211d), (2:\u211d)) (x-(-4), y-2) = 0) \u2192 ((x-(-4)) * (-39) + (y-2) * (3) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 + p.1) ((-4:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2) ((-4:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 + p.1 + 3 * p.2) ((-4:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 + p.1) ((-4:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => 3 * p.2) ((-4:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 + p.1) ((-4:\u211d), (2:\u211d))) (x - (-4), y - 2) = (x-(-4)) * (-39)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 + p.1) = (fun x => 5 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2) ((-4:\u211d), (2:\u211d))) (x - (-4), y - 2) = (y-2) * (3)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2) = (fun x => 3 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (2:\u211d)) (x - (-4), y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 + x + 3 * y - c = 0 at the point (-4,2) is (x-(-4)) * (-39) + (y-2) * (3) = 0. The approach is to compute the gradient (\u2207) of the function f(x,y)=5 * x^2 + x + 3 * y - c at the point (-4,2), take the dot product of this gradient with the shifted vector (x-(-4), y-2), and show that the equation obtained is equivalent to the specified one.  Introduce the hypothesis: this is the gradient (the total derivative as a linear map) of the function evaluated at the point (-4,2), applied to the vector (x-(-4), y-2), and set equal to 0. Apply the rule for differentiating a subtraction, which allows you to write the derivative of (5 * x^2 + x + 3 * y - c) as the derivative of (5 * x^2 + x + 3 * y) minus the derivative of c. State and use a splitting hypothesis that allows you to rewrite the derivative of (5 * x^2 + x + 3 * y) as the sum of the derivatives: one with respect to x (5 * x^2 + x) and one with respect to y (3 * y). This step relies on the respective differentiability at the point. Use the above to split the total derivative as a sum of two terms (one in x and one in y), minus the term in c (the constant). Show the following intermediate result: the derivative with respect to x (i.e. of 5 * x^2 + x) at (-4,2) applied to (x-(-4), y-2) gives (x-(-4)) * (-39). Decompose the function into a composition with the projection to the first coordinate. Use rules of chain rule and product rule for differentiation to compute the derivative with respect to x and express it in terms of the input vector. Expand and simplify using linear algebra rules and simplifications. Show the function's differentiability at the required point. Show the following intermediate result: the derivative with respect to y (i.e. of 3 * y) at (-4,2) applied to (x-(-4), y-2) gives (y-2) * (3). Again, use the split into the second coordinate projection, and compute the derivative. Use differentiation rules to get the result. Apply linear algebraic simplification as necessary. Show the function's differentiability at the required point. Show that the derivative with respect to c at any point applied to any vector is zero since c is a constant. Substitute all these previous results into the main hypothesis and simplify the equation to obtain the required form. Justify the differentiability assumptions for each function as required throughout the proof."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 - 5 * p.2 ^ 2 - c) ((6:\u211d), (-5:\u211d)) (x-6, y-(-5)) = 0) \u2192 ((x-6) * (3) - (y-(-5)) * (-50) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1) ((6:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2) ((6:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 - 5 * p.2 ^ 2) ((6:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1) ((6:\u211d), (-5:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 2) ((6:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1) ((6:\u211d), (-5:\u211d))) (x - 6, y - (-5)) = (x-6) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1) = (fun x => 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2) ((6:\u211d), (-5:\u211d))) (x - 6, y - (-5)) = (y-(-5)) * (-50)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2) = (fun x => 5 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (-5:\u211d)) (x - 6, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3 * x - 5 * y^2 - c = 0 at the point (6, -5) is (x-6) * 3 - (y-(-5)) * (-50) = 0. The idea is to compute the gradient (\u2207) of f(x, y) = 3x - 5y^2 - c at the point (6, -5), then take the dot product with the vector (x-6, y-(-5)). Setting this dot product equal to 0 gives the equation of the tangent line, which you need to show matches the claimed form. Introduce the hypothesis, which says the dot product of the gradient with the directional vector (x-6, y-(-5)) is 0. Apply the derivative rule for subtraction to split the gradient: \u2207(3x - 5y^2 - c) = \u2207(3x - 5y^2) - \u2207(c). Define a hypothesis that further splits \u2207(3x - 5y^2) = \u2207(3x) - \u2207(5y^2). Assume differentiability of the respective components. Rewrite the initial expression using the split into three terms: \u2207(3x), \u2207(5y^2), and \u2207(c), applying the relevant rules for subtracting linear maps. Show that \u2207(3x) evaluated at (6, -5) and applied to (x-6, y-(-5)) gives (x-6) * 3. Express 3x as a composition, apply chain rule, and reduce to the derivative in x. Use the rules for evaluating the linear map, and handle the arithmetic. Confirm differentiability of 3x. Show that \u2207(5y^2) evaluated at (6, -5) and applied to (x-6, y-(-5)) gives (y-(-5)) * (-50). Express 5y^2 as a composition, apply chain rule, and reduce to the derivative in y. Use the rules for evaluating the linear map, and handle the arithmetic and sign. Confirm differentiability of 5y^2. Show that \u2207(c) at (6, -5) applied to (x-6, y-(-5)) is 0, since c is a constant. Substitute all the above simplifications back into the original expression, using algebra to reorder and combine terms. Verify differentiability of the entire function and its components at the appropriate points."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 + 5 * p.2 ^ 2 - c) ((2:\u211d), (6:\u211d)) (x-2, y-6) = 0) \u2192 ((x-2) * (1) + (y-6) * (60) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1) ((2:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2) ((2:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 + 5 * p.2 ^ 2) ((2:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1) ((2:\u211d), (6:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 2) ((2:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1) ((2:\u211d), (6:\u211d))) (x - 2, y - 6) = (x-2) * (1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1) = (fun x => x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2) ((2:\u211d), (6:\u211d))) (x - 2, y - 6) = (y-6) * (60)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2) = (fun x => 5 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (6:\u211d)) (x - 2, y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (differentiableAt_fst) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x + 5y\u00b2 - c = 0 at the point (2,6) is (x-2)*(1) + (y-6)*(60) = 0. The idea is to compute the gradient (\u2207) of f(x, y) = x + 5y\u00b2 - c at (2, 6), then take the dot product of this gradient with the shifted vector (x-2, y-6). Setting this equal to 0 gives the tangent equation, which we must show matches the desired form. Introduce the hypothesis: the directional derivative (dot product of the gradient at (2,6) with (x-2, y-6)) equals 0. Use the derivative rule for subtraction to split \u2207(x + 5y\u00b2 - c) = \u2207(x + 5y\u00b2) - \u2207(c). Establish that \u2207(x + 5y\u00b2) = \u2207(x) + \u2207(5y\u00b2) by assuming differentiability at both parts. Use rules of linear maps to express the directional derivative as the sum and difference of these derivatives and apply them to (x-2, y-6). Show that the directional derivative (gradient) of x at (2,6) applied to (x-2, y-6) gives (x-2) * 1. Use function composition and differentiation rules to relate the partial derivative to the one-variable derivative. Explicitly compute and justify the linear map calculation. Prove differentiability of the function x. Show that the directional derivative (gradient) of 5y\u00b2 at (2,6) applied to (x-2, y-6) gives (y-6) * 60. Use function composition and differentiation rules to relate the partial derivative to the one-variable derivative for y. Explicitly compute and justify the linear map calculation. Prove differentiability of 5y\u00b2. Compute the derivative of the constant c at (2,6); show it is 0. Substitute back to combine all pieces into the desired tangent equation and use algebraic simplifications where necessary. Confirm the differentiability of all involved component functions for full rigor."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 - 5 * p.1 ^ 2 + 4 * p.2 ^ 2 + p.2 - c) ((2:\u211d), (3:\u211d)) (x-2, y-3) = 0) \u2192 ((x-2) * (28) + (y-3) * (25) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3 - 5 * p.1 ^ 2) ((2:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((2:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 - 5 * p.1 ^ 2 + 4 * p.2 ^ 2 + p.2) ((2:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3 - 5 * p.1 ^ 2) ((2:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((2:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3 - 5 * p.1 ^ 2) ((2:\u211d), (3:\u211d))) (x - 2, y - 3) = (x-2) * (28)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3 - 5 * p.1 ^ 2) = (fun x => 4 * x ^ 3 - 5 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2 + p.2) ((2:\u211d), (3:\u211d))) (x - 2, y - 3) = (y-3) * (25)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2 + p.2) = (fun x => 4 * x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (3:\u211d)) (x - 2, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 - 5 * x^2 + 4 * y^2 + y - c = 0 at the point (2,3) is (x-2) * 28 + (y-3) * 25 = 0. The goal is to compute the gradient (\u2207) of the function f(x, y) = 4 * x^3 - 5 * x^2 + 4 * y^2 + y - c at (2, 3), take its dot product with the vector (x-2, y-3), set it equal to 0, and arrive at the desired tangent line equation. Introduce the hypothesis that the dot product of the gradient with (x-2, y-3) is 0. Use the rule for the derivative of a difference to split \u2207(4 * x^3 - 5 * x^2 + 4 * y^2 + y - c) as \u2207(4 * x^3 - 5 * x^2 + 4 * y^2 + y) - \u2207(c). Define a step that splits \u2207(4 * x^3 - 5 * x^2 + 4 * y^2 + y) = \u2207(4 * x^3 - 5 * x^2) + \u2207(4 * y^2 + y). Assume differentiability for each part. Apply the decomposition and linearity properties of the derivative to express the tangent expression in terms of these gradients. Show that \u2207(4 * x^3 - 5 * x^2) at (2,3), applied to (x-2, y-3), equals (x-2) * 28. Express \u2207 with respect to x as a composition; use the chain rule. Compute the x-derivative of 4 * x^3 - 5 * x^2 at x = 2. Apply the result to the input vector using properties of linear maps. Establish differentiability for 4 * x^3 - 5 * x^2. Show that \u2207(4 * y^2 + y) at (2,3), applied to (x-2, y-3), equals (y-3) * 25. Express \u2207 with respect to y as a composition; use the chain rule. Compute the y-derivative of 4 * y^2 + y at y = 3. Apply the result to the input vector using properties of linear maps. Establish differentiability for 4 * y^2 + y. Show that the gradient of the constant c, applied to anything, is 0. Substitute the results from steps 5, 6, and 7 back into the main equation. Conclude by establishing the differentiability of all relevant functions and simplifying to obtain the tangent line equation."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 - 4 * p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2 + p.2 - c) ((0:\u211d), (6:\u211d)) (x-0, y-6) = 0) \u2192 ((x-0) * (0) - (y-6) * (2903) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3) ((0:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - p.2 ^ 2 - p.2) ((0:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 - 4 * p.2 ^ 4 + 5 * p.2 ^ 3 + p.2 ^ 2 + p.2) ((0:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3) ((0:\u211d), (6:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - p.2 ^ 2 - p.2) ((0:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3) ((0:\u211d), (6:\u211d))) (x - 0, y - 6) = (x-0) * (0)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3) = (fun x => 2 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - p.2 ^ 2 - p.2) ((0:\u211d), (6:\u211d))) (x - 0, y - 6) = (y-6) * (2903)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 4 - 5 * p.2 ^ 3 - p.2 ^ 2 - p.2) = (fun x => 4 * x ^ 4 - 5 * x ^ 3 - x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (6:\u211d)) (x - 0, y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2\u22c5x\u00b3 - 4\u22c5y\u2074 + 5\u22c5y\u00b3 + y\u00b2 + y - c = 0 at the point (0,6) is (x-0)\u22c50 - (y-6)\u22c52903 = 0. The main idea is to compute the gradient (\u2207) of the function f(x, y) = 2\u22c5x\u00b3 - 4\u22c5y\u2074 + 5\u22c5y\u00b3 + y\u00b2 + y - c at the point (0, 6), then take the dot product with the shifted vector (x-0, y-6), set that equal to 0, and check that the resulting equation matches the one we want. Introduce the hypothesis, which is that the dot product of the gradient at (0, 6) with (x-0, y-6) is zero. Use the rule for the derivative of a subtraction to separate the fderiv of the full function into fderiv (2\u22c5x\u00b3 - 4\u22c5y\u2074 + 5\u22c5y\u00b3 + y\u00b2 + y) minus fderiv (c). Define a hypothesis splitting fderiv (2\u22c5x\u00b3 - 4\u22c5y\u2074 + 5\u22c5y\u00b3 + y\u00b2 + y) into the sum/difference of fderiv (2\u22c5x\u00b3) and fderiv (4\u22c5y\u2074 - 5\u22c5y\u00b3 - y\u00b2 - y), assuming differentiability at the relevant pieces. Substitute this splitting into the main hypothesis, and expand the derivatives using the linearity of the fderiv and the properties of the ContinuousLinearMap. Compute the contribution from the x-direction: Show that the fderiv of 2\u22c5x\u00b3 at (0, 6) applied to (x-0, y-6) reduces to (x-0) times the directional derivative with respect to x, evaluated at 0. Use single-variable differentiation, noting that all terms are evaluated at x=0, so the result will be (x-0)\u22c50. Justify differentiability at the relevant places. Compute the contribution from the y-direction: Show that the fderiv of 4\u22c5y\u2074 - 5\u22c5y\u00b3 - y\u00b2 - y at (0, 6) applied to (x-0, y-6) reduces to (y-6) times the total derivative in the y-direction, evaluated at y=6. Perform the computation in terms of the single-variable derivatives and sum the results to show that this equals (y-6)\u22c52903. Justify differentiability at the relevant places. Show that fderiv of the constant function c is zero when applied to any vector. Substitute the results from the above computations into the main equation, and simplify algebraically to derive the required equation. Justify all differentiability conditions needed for the previous computations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 2 + 2 * p.1 + p.2 ^ 2 + p.2 - c) ((3:\u211d), (-1:\u211d)) (x-3, y-(-1)) = 0) \u2192 ((x-3) * (8) + (y-(-1)) * (-1) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((3:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 + p.2) ((3:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 2 + 2 * p.1 + p.2 ^ 2 + p.2) ((3:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((3:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 + p.2) ((3:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 2 + 2 * p.1) ((3:\u211d), (-1:\u211d))) (x - 3, y - (-1)) = (x-3) * (8)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 2 + 2 * p.1) = (fun x => x ^ 2 + 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 + p.2) ((3:\u211d), (-1:\u211d))) (x - 3, y - (-1)) = (y-(-1)) * (-1)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 + p.2) = (fun x => x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (-1:\u211d)) (x - 3, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^2 + 2x + y^2 + y - c = 0 at the point (3, -1) is (x-3) * 8 + (y-(-1)) * (-1) = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = x^2 + 2x + y^2 + y - c at point (3, -1), then take the dot product with the position vector (x-3, y-(-1)). Setting this equation to zero gives the equation of the tangent at that point. Introduce the initial hypothesis that the dot product of the gradient at the point (3, -1) with (x-3, y-(-1)) is zero. Apply the rule for the derivative of a difference to split the total derivative as the difference between the derivative of the sum and the derivative of the constant c. Construct a hypothesis that further splits the sum inside the derivative: show that the derivative of (x^2 + 2x + y^2 + y) is the sum of the derivatives of (x^2 + 2x) and (y^2 + y), assuming both are differentiable at the relevant point. Substitute these results into the computation, and use properties of linear maps (like how the derivative of a sum splits) to further expand the formula. Show that the contribution from the x-part, i.e., (fderiv of x^2 + 2x at (3, -1) applied to (x-3, y-(-1))), equals (x-3) * 8. To do this: Use composition and single-variable differentiation rules to reduce the partial derivative to the regular derivative wrt x. Compute the relevant derivatives and substitute the point (3, -1) into the formula. Show, step by step, how the linear map gives the claimed numerical result. Make sure to show differentiability of x^2 + 2x at the point. Do the same for the y-part: show that the derivative with respect to y, evaluated at (y - (-1)), gives (y-(-1)) * (-1). Use similar composition and differentiation reasoning as in the x-part. Compute the derivative wrt y, substitute values, and confirm the algebra yields the claimed result. Argue via linearity of the map. Show differentiability of y^2 + y at the point. Show that the derivative of c (a constant function) applied to the vector is zero. Use these intermediate results to rewrite and simplify the expression for the gradient dot the displacement vector. Show the differentiability of all the involved functions at the relevant points for completeness."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 - p.1 + p.2 ^ 4 - 5 * p.2 ^ 2 - c) ((5:\u211d), (4:\u211d)) (x-5, y-4) = 0) \u2192 ((x-5) * (19) + (y-4) * (216) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2 - p.1) ((5:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 - 5 * p.2 ^ 2) ((5:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 - p.1 + p.2 ^ 4 - 5 * p.2 ^ 2) ((5:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2 - p.1) ((5:\u211d), (4:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 - 5 * p.2 ^ 2) ((5:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2 - p.1) ((5:\u211d), (4:\u211d))) (x - 5, y - 4) = (x-5) * (19)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2 - p.1) = (fun x => 2 * x ^ 2 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 - 5 * p.2 ^ 2) ((5:\u211d), (4:\u211d))) (x - 5, y - 4) = (y-4) * (216)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 - 5 * p.2 ^ 2) = (fun x => x ^ 4 - 5 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (4:\u211d)) (x - 5, y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^2 - x + y^4 - 5 * y^2 - c = 0 at the point (5,4) is (x-5) * 19 + (y-4) * 216 = 0. The approach is to compute the gradient (\u2207) of the function f(x, y) = 2 * x^2 - x + y^4 - 5 * y^2 - c at the point (5, 4), then take the dot product of this gradient with (x-5, y-4), and set it to 0. We need to show that this gives the claimed equation. Introduce the hypothesis: the dot product of the gradient with the shifted vector is 0. Use the rule for the derivative of a difference to split \u2207(2 * x^2 - x + y^4 - 5 * y^2 - c) = \u2207(2 * x^2 - x + y^4 - 5 * y^2) - \u2207(c). State a key intermediate that \u2207(2 * x^2 - x + y^4 - 5 * y^2) = \u2207(2 * x^2 - x) + \u2207(y^4 - 5 * y^2), assuming differentiability of both parts. Apply this splitting, and linearity of the map, to rewrite the original equation in terms of separate x and y contributions minus the constant part. Show that \u2207(2 * x^2 - x) at (5, 4) dotted with (x-5, y-4) = (x-5) * 19 Use a composition argument to treat (2 * x^2 - x) as a function of x alone. Compute the derivative with respect to x. Calculate the application of the resulting continuous linear map. Justify differentiability at the required point. Show that \u2207(y^4 - 5 * y^2) at (5, 4) dotted with (x-5, y-4) = (y-4) * 216 Use a composition argument to treat (y^4 - 5 * y^2) as a function of y alone. Compute the derivative with respect to y. Calculate the application of the resulting continuous linear map. Justify differentiability at the required point. Show that \u2207(c) at (5, 4) dotted with (x-5, y-4) = 0. Substitute in the previously computed expressions for the derivatives into the hypothesis, simplifying the sum. Justify differentiability at each step for the component and composite functions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 2 - p.1 - 4 * p.2 ^ 3 + 4 * p.2 ^ 2 - 2 * p.2 - c) ((4:\u211d), (4:\u211d)) (x-4, y-4) = 0) \u2192 ((x-4) * (31) - (y-4) * (162) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 2 - p.1) ((4:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2 + 2 * p.2) ((4:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 2 - p.1 - 4 * p.2 ^ 3 + 4 * p.2 ^ 2 - 2 * p.2) ((4:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 2 - p.1) ((4:\u211d), (4:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2 + 2 * p.2) ((4:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 2 - p.1) ((4:\u211d), (4:\u211d))) (x - 4, y - 4) = (x-4) * (31)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 2 - p.1) = (fun x => 4 * x ^ 2 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2 ^ 2 + 2 * p.2) ((4:\u211d), (4:\u211d))) (x - 4, y - 4) = (y-4) * (162)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 - 4 * p.2 ^ 2 + 2 * p.2) = (fun x => 4 * x ^ 3 - 4 * x ^ 2 + 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((4:\u211d), (4:\u211d)) (x - 4, y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^2 - x - 4 * y^3 + 4 * y^2 - 2 * y - c = 0 at the point (4,4) is (x-4) * (31) - (y-4) * (162) = 0. The method is to calculate the gradient (\u2207) of the function f(x,y) = 4 * x^2 - x - 4 * y^3 + 4 * y^2 - 2 * y - c at the point (4,4), then take the dot product with the vector (x-4, y-4). Setting this equal to zero gives the tangent line, which you need to show is equivalent to (x-4) * (31) - (y-4) * (162) = 0.  Introduce the initial hypothesis, which states that the dot product of the gradient at (4,4) with the shifted positional vector (x-4, y-4) equals zero. Apply the rule for the derivative of a subtraction to rewrite the gradient of the whole function as the gradient of the sum minus the gradient of the constant term: \u2207(4 * x^2 - x - 4 * y^3 + 4 * y^2 - 2 * y - c) = \u2207(4 * x^2 - x - 4 * y^3 + 4 * y^2 - 2 * y) - \u2207(c). Introduce an intermediate result that splits the gradient of (4 * x^2 - x - 4 * y^3 + 4 * y^2 - 2 * y) as the difference of two gradients: one depending only on x and the other only on y. Assume differentiability of both parts. Rewrite the gradient of the original function at (4,4) as the difference of the gradients of the x-part and the y-part, minus the constant's gradient. Show that the gradient of 4 * x^2 - x at (4,4), evaluated at (x-4, y-4), is (x-4) * (31). Use composition and differentiation rules to reduce the partial derivative with respect to x to a one-variable derivative at x=4. Perform the necessary differentiation and simplification. Show the computation is valid using linear map rules. Justify differentiability of 4 * x^2 - x. Show that the gradient of 4 * y^3 - 4 * y^2 + 2 * y at (4,4), evaluated at (x-4, y-4), is (y-4) * (162). Use composition and differentiation rules to reduce the partial derivative with respect to y to a one-variable derivative at y=4. Perform the necessary differentiation and simplification. Show the computation is valid using linear map rules. Justify differentiability of 4 * y^3 - 4 * y^2 + 2 * y. Show that the gradient of the constant term c at (4,4), applied to (x-4, y-4), is zero. Substitute the previous results into the hypothesis to simplify the equation to the desired tangent form. Justify overall differentiability of all component functions and their combinations as used above."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 - 5 * p.2 ^ 3 - p.2 - c) ((5:\u211d), (3:\u211d)) (x-5, y-3) = 0) \u2192 ((x-5) * (300) - (y-3) * (136) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3) ((5:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3 + p.2) ((5:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 - 5 * p.2 ^ 3 - p.2) ((5:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3) ((5:\u211d), (3:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 3 + p.2) ((5:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3) ((5:\u211d), (3:\u211d))) (x - 5, y - 3) = (x-5) * (300)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3) = (fun x => 4 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3 + p.2) ((5:\u211d), (3:\u211d))) (x - 5, y - 3) = (y-3) * (136)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3 + p.2) = (fun x => 5 * x ^ 3 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (3:\u211d)) (x - 5, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4*x^3 - 5*y^3 - y - c = 0 at the point (5,3) is (x-5) * 300 - (y-3) * 136 = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 4*x^3 - 5*y^3 - y - c at the point (5,3), then take the dot product of this gradient with the shifted vector (x-5, y-3). Setting that equal to 0 gives the tangent\u2019s equation, which we want to show simplifies to the claimed equation. Introduce the hypothesis: the dot product of the gradient at (5,3) with the vector (x-5, y-3) is zero. Apply the rule for taking the derivative of a difference to split the gradient: \u2207(4*x^3 - 5*y^3 - y - c) = \u2207(4*x^3 - 5*y^3 - y) - \u2207(c). Define a key intermediate result that splits \u2207(4*x^3 - 5*y^3 - y) as \u2207(4*x^3) - \u2207(5*y^3 + y), assuming differentiability of these components. Use this result and linear map rules to further break down the original gradient: \u2207(4*x^3 - 5*y^3 - y - c) = \u2207(4*x^3) - \u2207(5*y^3 + y) - \u2207(c). Show that \u2207(4*x^3) at (5,3), when applied to (x-5, y-3), gives (x-5) * 300. Use function composition and the chain rule to reduce the partial derivative with respect to x to a standard derivative calculation. Calculate the derivative with respect to x at x=5. Carry through the linear maps and algebra to finish the calculation. Justify differentiability of 4*x^3 at the relevant point. Show that \u2207(5*y^3 + y) at (5,3), when applied to (x-5, y-3), gives (y-3) * 136. Use function composition and the chain rule for the y-variable. Calculate the derivative with respect to y at y=3. Work through the linear map application and simplify algebraically. Justify differentiability of 5*y^3 + y at the relevant point. Show that \u2207(c) at (5,3), when applied to (x-5, y-3), is 0. Substitute the results from steps 5\u20137 into the main equation to simplify. Justify the differentiability of all needed pieces: \u2207(4*x^3), \u2207(5*y^3 + y), \u2207(4*x^3 - 5*y^3 - y), and \u2207(c)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 - p.2 ^ 4 - 3 * p.2 ^ 2 - c) ((3:\u211d), (-6:\u211d)) (x-3, y-(-6)) = 0) \u2192 ((x-3) * (2) - (y-(-6)) * (-900) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((3:\u211d), (-6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 2) ((3:\u211d), (-6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 - p.2 ^ 4 - 3 * p.2 ^ 2) ((3:\u211d), (-6:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((3:\u211d), (-6:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 2) ((3:\u211d), (-6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((3:\u211d), (-6:\u211d))) (x - 3, y - (-6)) = (x-3) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 3 * p.2 ^ 2) ((3:\u211d), (-6:\u211d))) (x - 3, y - (-6)) = (y-(-6)) * (-900)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 3 * p.2 ^ 2) = (fun x => x ^ 4 + 3 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (-6:\u211d)) (x - 3, y - (-6)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x - y^4 - 3 * y^2 - c = 0 at the point (3, -6) is (x-3) * 2 - (y-(-6)) * (-900) = 0. The strategy is to compute the gradient (\u2207) of f(x,y) = 2x - y^4 - 3y^2 - c at (3, -6), then take its dot product with the vector (x-3, y-(-6)), set it to 0, and show this is equivalent to the desired tangent equation.  Introduce the assumption that the dot product of the gradient at (3, -6) with (x-3, y-(-6)) is 0. Apply the derivative rule for subtraction to divide the gradient of 2 * x - y^4 - 3 * y^2 - c into two parts: the gradient of 2 * x - y^4 - 3 * y^2 and the gradient of c. Introduce an intermediate step to further split the first gradient using the rule for subtraction: \u2207(2 * x - y^4 - 3 * y^2) = \u2207(2 * x) - \u2207(y^4 + 3 * y^2). Assume differentiability at these stages. Use the previous splitting and linearity rules to isolate the desired derivatives on each variable. Compute the gradient of 2 * x at (3, -6), dotted with (x-3, y-(-6)), and show it gives (x-3) * 2. Use composition and the derivative rules to reduce the gradient in x to an ordinary derivative. Differentiate 2 * x with respect to x. Use linearity and simplification to establish the result. Justify differentiability of 2 * x. Compute the gradient of y^4 + 3 * y^2 at (3, -6), dotted with (x-3, y-(-6)), and show it gives (y-(-6)) * (-900). Use composition and the derivative rules to reduce the gradient in y to an ordinary derivative. Differentiate y^4 + 3 * y^2 with respect to y. Use linearity and simplification to establish the result. Justify differentiability of y^4 + 3 * y^2. Show that \u2207(c) at (3,-6), dotted with (x-3, y-(-6)), is 0. Substitute all results into the original assumption to simplify the expression. Justify differentiability for all components used in the chain of computations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 + p.1 - 4 * p.2 ^ 3 + 4 * p.2 - c) ((5:\u211d), (-5:\u211d)) (x-5, y-(-5)) = 0) \u2192 ((x-5) * (76) - (y-(-5)) * (296) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 + p.1) ((5:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2) ((5:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 + p.1 - 4 * p.2 ^ 3 + 4 * p.2) ((5:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 + p.1) ((5:\u211d), (-5:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2) ((5:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 + p.1) ((5:\u211d), (-5:\u211d))) (x - 5, y - (-5)) = (x-5) * (76)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 + p.1) = (fun x => x ^ 3 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 3 - 4 * p.2) ((5:\u211d), (-5:\u211d))) (x - 5, y - (-5)) = (y-(-5)) * (296)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 3 - 4 * p.2) = (fun x => 4 * x ^ 3 - 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (-5:\u211d)) (x - 5, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (differentiableAt_fst)\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 + x - 4y^3 + 4y - c = 0 at the point (5, -5) is (x-5) * 76 - (y-(-5)) * 296 = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = x^3 + x - 4y^3 + 4y - c at (5, -5), then take the dot product of this gradient with the vector (x-5, y-(-5)). Setting that equal to 0 gives the tangent line equation, and the goal is to simplify and confirm that it matches (x-5) * 76 - (y-(-5)) * 296 = 0.  Introduce the hypothesis, which is the dot product of the gradient evaluated at (5, -5) with (x-5, y-(-5)), set to 0. Apply the derivative rule for subtraction to write \u2207(x^3 + x - 4y^3 + 4y - c) as \u2207(x^3 + x - 4y^3 + 4y) - \u2207(c). Define a hypothesis to further split the gradient: show \u2207(x^3 + x - 4y^3 + 4y) = \u2207(x^3 + x) - \u2207(4y^3 - 4y), assuming differentiability at each part. Use this split and properties of linear maps to expand the gradient of the full sum/difference at the relevant point, reducing the problem to evaluating the gradients of each part. Show that \u2207(x^3 + x) at (5, -5), evaluated on (x-5, y-(-5)), gives (x-5) * 76. Use composition and derivative rules to reduce to a single-variable derivative in x. Compute the derivatives and substitute in x = 5. Apply properties of linear maps and algebraic simplification. Justify differentiability of x^3 + x. Show that \u2207(4y^3 - 4y) at (5, -5), evaluated on (x-5, y-(-5)), gives (y-(-5)) * 296. Use composition and derivative rules for a single-variable function in y. Compute the derivatives and substitute in y = -5. Apply properties of linear maps and algebraic simplification. Justify differentiability of 4y^3 - 4y. Show that the gradient of the constant function c is zero at any input, and so contributes nothing. Substitute the results from steps 5, 6, and 7 back into the original hypothesis and simplify the resulting equation so that it matches the target: (x-5) * 76 - (y-(-5)) * 296 = 0. Justify all necessary differentiability statements for each split in the chain."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 - p.2 ^ 2 + 4 * p.2 - c) ((3:\u211d), (0:\u211d)) (x-3, y-0) = 0) \u2192 ((x-3) * (1) - (y-0) * (-4) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1) ((3:\u211d), (0:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((3:\u211d), (0:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 - p.2 ^ 2 + 4 * p.2) ((3:\u211d), (0:\u211d))\n      = \n      fderiv \u211d (fun p => p.1) ((3:\u211d), (0:\u211d)) -\n      fderiv \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((3:\u211d), (0:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1) ((3:\u211d), (0:\u211d))) (x - 3, y - 0) = (x-3) * (1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1) = (fun x => x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((3:\u211d), (0:\u211d))) (x - 3, y - 0) = (y-0) * (-4)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 - 4 * p.2) = (fun x => x ^ 2 - 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (0:\u211d)) (x - 3, y - 0) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_fst) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x - y^2 + 4y - c = 0 at the point (3,0) is (x-3) * (1) - (y-0) * (-4) = 0. The idea is to compute the gradient (\u2207) of the function f(x,y) = x - y^2 + 4y - c at the point (3,0), and then take the dot product of this gradient with the shifted vector (x-3, y-0). Setting this equal to zero yields the equation of the tangent, which we have to show is equivalent to (x-3) * (1) - (y-0) * (-4) = 0. Introduce the hypothesis, which states that the dot product of the gradient at (3,0) with the vector (x-3, y-0) is zero. Use the derivative rule for subtraction to split the gradient: \u2207(x - y^2 + 4y - c) = \u2207(x - y^2 + 4y) - \u2207(c). Define a hypothesis splitting \u2207(x - y^2 + 4y) = \u2207(x) - \u2207(y^2 - 4y), assuming differentiability at each part. Use the above hypothesis and linearity properties of the total derivative to rewrite the main expression. Show that \u2207(x) at (3,0) dotted with (x-3, y-0) is equal to (x-3) * 1. Use composition properties and the chain rule to reduce to a simple derivative. Compute the (simple) derivative with respect to x. Use the rules of linear maps to evaluate at the point and simplify. Justify differentiability of the function x. Show that \u2207(y^2 - 4y) at (3,0) dotted with (x-3, y-0) equals (y-0) * (-4). Use composition properties and the chain rule to reduce to a simple derivative. Compute the derivative with respect to y. Use the rules of linear maps to evaluate at the point and simplify. Justify differentiability of the function y^2 - 4y. Show that \u2207(c) at (3,0) dotted with (x-3, y-0) yields 0. Substitute in the results from 5, 6, and 7 and simplify the resulting expression. Justify the differentiability of each needed part: \u2207(x), \u2207(y^2 - 4y), \u2207(x - y^2 + 4y), and \u2207(c)."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 2 * p.1 + p.2 ^ 2 - 4 * p.2 - c) ((6:\u211d), (3:\u211d)) (x-6, y-3) = 0) \u2192 ((x-6) * (358) + (y-3) * (2) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 2 * p.1) ((6:\u211d), (3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((6:\u211d), (3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 2 * p.1 + p.2 ^ 2 - 4 * p.2) ((6:\u211d), (3:\u211d))\n      = \n      fderiv \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 2 * p.1) ((6:\u211d), (3:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((6:\u211d), (3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 2 * p.1) ((6:\u211d), (3:\u211d))) (x - 6, y - 3) = (x-6) * (358)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 3 * p.1 ^ 3 + 3 * p.1 ^ 2 - 2 * p.1) = (fun x => 3 * x ^ 3 + 3 * x ^ 2 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 - 4 * p.2) ((6:\u211d), (3:\u211d))) (x - 6, y - 3) = (y-3) * (2)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 - 4 * p.2) = (fun x => x ^ 2 - 4 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((6:\u211d), (3:\u211d)) (x - 6, y - 3) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 3x\u00b3 + 3x\u00b2 - 2x + y\u00b2 - 4y - c = 0 at the point (6,3) is (x-6) * 358 + (y-3) * 2 = 0. The strategy is to compute the gradient (\u2207) of the function f(x,y) = 3x\u00b3 + 3x\u00b2 - 2x + y\u00b2 - 4y - c at (6,3), then take the dot product with the shift vector (x-6, y-3), set it to zero, and show this simplifies to the desired equation.  Introduce the hypothesis that the dot product of the gradient at (6,3) with the vector (x-6, y-3) is zero. Use the derivative rule for subtraction to rewrite the gradient: \u2207(3x\u00b3 + 3x\u00b2 - 2x + y\u00b2 - 4y - c) = \u2207(3x\u00b3 + 3x\u00b2 - 2x + y\u00b2 - 4y) - \u2207(c) Write a hypothesis splitting \u2207(3x\u00b3 + 3x\u00b2 - 2x + y\u00b2 - 4y) into the sum of gradients: \u2207(3x\u00b3 + 3x\u00b2 - 2x + y\u00b2 - 4y) = \u2207(3x\u00b3 + 3x\u00b2 - 2x) + \u2207(y\u00b2 - 4y), under appropriate differentiability assumptions. Now, by linearity of the differential, express the overall gradient in terms of the pieces and use this to rewrite the original expression. Compute the component of the gradient for x at (6,3) and show that the dot product with (x-6, y-3) gives (x-6) * 358: Use the fact that the function of x only depends on the first coordinate, and use chain and product rules. Find the partial derivative with respect to x and plug in x=6 to compute. Use linearity and identify the result as (x-6) times that derivative. Check the differentiability at each step for the function of x. Compute the component of the gradient for y at (6,3) and show that the dot product with (x-6, y-3) gives (y-3) * 2: Use the structure for y-dependent part\u2014again using the chain and product rules. Find the partial derivative with respect to y and substitute y=3. The calculation will give you (y-3) times that derivative. Argue differentiability at point (6,3) for this portion. Show that the gradient of the constant c is zero regardless of input, so the dot product term for c vanishes. Substitute the explicit results from Steps 5, 6, and 7 into the original hypothesis and simplify the expression to obtain (x-6) * 358 + (y-3) * 2 = 0. Throughout, affirm the differentiability of the respective function combinations, as required."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - p.1 ^ 2 - 5 * p.1 + 5 * p.2 ^ 2 - 5 * p.2 - c) ((2:\u211d), (-1:\u211d)) (x-2, y-(-1)) = 0) \u2192 ((x-2) * (3) + (y-(-1)) * (-15) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3 - p.1 ^ 2 - 5 * p.1) ((2:\u211d), (-1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2 - 5 * p.2) ((2:\u211d), (-1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - p.1 ^ 2 - 5 * p.1 + 5 * p.2 ^ 2 - 5 * p.2) ((2:\u211d), (-1:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3 - p.1 ^ 2 - 5 * p.1) ((2:\u211d), (-1:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 2 - 5 * p.2) ((2:\u211d), (-1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3 - p.1 ^ 2 - 5 * p.1) ((2:\u211d), (-1:\u211d))) (x - 2, y - (-1)) = (x-2) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3 - p.1 ^ 2 - 5 * p.1) = (fun x => x ^ 3 - x ^ 2 - 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_pow _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2 - 5 * p.2) ((2:\u211d), (-1:\u211d))) (x - 2, y - (-1)) = (y-(-1)) * (-15)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2 - 5 * p.2) = (fun x => 5 * x ^ 2 - 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (-1:\u211d)) (x - 2, y - (-1)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.sub (differentiableAt_fst.pow _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x\u00b3 - x\u00b2 - 5x + 5y\u00b2 - 5y - c = 0 at the point (2, -1) is (x-2) * 3 + (y-(-1)) * (-15) = 0. The idea is, to calculate the gradient (\u2207) of the function f(x, y) = x\u00b3 - x\u00b2 - 5x + 5y\u00b2 - 5y - c at the point (2, -1), then form the dot product of this gradient with the shifted vector (x-2, y-(-1)). Setting this equal to 0 gives an equation for the tangent, which we must show simplifies to the stated claim. Introduce the hypothesis, which states that the dot product of the gradient with the shifted positional vector is zero. Apply the derivative rule of subtraction to split \u2207(x\u00b3 - x\u00b2 - 5x + 5y\u00b2 - 5y - c) into \u2207(x\u00b3 - x\u00b2 - 5x + 5y\u00b2 - 5y) - \u2207(c). Give a hypothesis to further split the derivative of x\u00b3 - x\u00b2 - 5x + 5y\u00b2 - 5y into two parts: - The x-dependent part: x\u00b3 - x\u00b2 - 5x - The y-dependent part: 5y\u00b2 - 5y - Assume that both subfunctions are differentiable at the point. Use the hypothesis to substitute and expand, then apply linearity of the gradient to further separate the terms. Show that \u2207(x\u00b3 - x\u00b2 - 5x) at (2,-1) dotted with (x-2, y-(-1)) produces (x-2) * 3: Use composition and single-variable differentiation rules to reduce the gradient to a simple partial derivative with respect to x. Compute the required derivative at x=2, and substitute for the dot product. Use properties of linear maps and algebraic manipulation to simplify to the claimed coefficient. Show differentiability of x\u00b3 - x\u00b2 - 5x. Show that \u2207(5y\u00b2 - 5y) at (2,-1) dotted with (x-2, y-(-1)) gives (y-(-1)) * (-15): Use function composition and partial derivative rules to reduce to a derivative with respect to y. Compute the derivative at y = -1 and substitute. Use algebra and linear map properties to get the coefficient -15. Show differentiability of 5y\u00b2 - 5y with respect to y. Show that the derivative term corresponding to c yields zero when dotted with (x-2, y-(-1)). Substitute these simplifications into your expression and combine like terms for the final simplification. Provide justification for all differentiability assumptions made for the relevant partials and their combinations."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 + 2 * p.2 - c) ((-3:\u211d), (-5:\u211d)) (x-(-3), y-(-5)) = 0) \u2192 ((x-(-3)) * (108) + (y-(-5)) * (2) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3) ((-3:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2) ((-3:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 + 2 * p.2) ((-3:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3) ((-3:\u211d), (-5:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2) ((-3:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3) ((-3:\u211d), (-5:\u211d))) (x - (-3), y - (-5)) = (x-(-3)) * (108)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3) = (fun x => 4 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2) ((-3:\u211d), (-5:\u211d))) (x - (-3), y - (-5)) = (y-(-5)) * (2)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2) = (fun x => 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-3:\u211d), (-5:\u211d)) (x - (-3), y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 + 2 * y - c = 0 at the point (-3, -5) is (x - (-3)) * (108) + (y - (-5)) * (2) = 0. The idea is to calculate the gradient (\u2207) of f(x, y) = 4 * x^3 + 2 * y - c at the point (-3, -5), then take the dot product of this gradient with the shifted position vector (x - (-3), y - (-5)). Setting the result to 0 gives the equation of the tangent, and we want to show this is equivalent to (x - (-3)) * (108) + (y - (-5)) * (2) = 0. Introduce the hypothesis that the dot product of the gradient with the shifted positional vector is 0 at the given point. Use the rule for the derivative of a subtraction to rewrite the gradient as \u2207(4 * x^3 + 2 * y - c) = \u2207(4 * x^3 + 2 * y) - \u2207(c). State a hypothesis splitting the gradient of the sum: \u2207(4 * x^3 + 2 * y) = \u2207(4 * x^3) + \u2207(2 * y), assuming differentiability at each function. Use linearity of the derivative and linear maps to expand out the composed derivatives and split terms accordingly. Show that \u2207(4 * x^3) at (-3, -5) dot-product (x - (-3), y - (-5)) equals (x - (-3)) * 108. Use the composition structure of the function to express the derivative as the univariate derivative with respect to x. Compute the derivative with respect to x at the given point. Use linearity and algebraic simplification to arrive at the stated coefficient. Prove that 4 * x^3 is differentiable at the required point. Show that \u2207(2 * y) at (-3, -5) dot-product (x - (-3), y - (-5)) equals (y - (-5)) * 2. Use the composition structure for the y-coordinate to write the derivative as a univariate function of y. Compute the derivative with respect to y at the required point. Simplify the result to match the claimed coefficient. Prove that 2 * y is differentiable at the required point. Show that \u2207(c), the gradient of a constant function at any point, when dotted with any vector, gives zero. Substitute the results of steps 5, 6, and 7 into the main equation and simplify. Conclude by giving the differentiability conditions needed for the above steps to hold."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 3 + 5 * p.1 - 5 * p.2 ^ 3 + 2 * p.2 ^ 2 - c) ((3:\u211d), (6:\u211d)) (x-3, y-6) = 0) \u2192 ((x-3) * (59) - (y-6) * (516) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 3 + 5 * p.1) ((3:\u211d), (6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 3 - 2 * p.2 ^ 2) ((3:\u211d), (6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 3 + 5 * p.1 - 5 * p.2 ^ 3 + 2 * p.2 ^ 2) ((3:\u211d), (6:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 3 + 5 * p.1) ((3:\u211d), (6:\u211d)) -\n      fderiv \u211d (fun p => 5 * p.2 ^ 3 - 2 * p.2 ^ 2) ((3:\u211d), (6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 3 + 5 * p.1) ((3:\u211d), (6:\u211d))) (x - 3, y - 6) = (x-3) * (59)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 3 + 5 * p.1) = (fun x => 2 * x ^ 3 + 5 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 3 - 2 * p.2 ^ 2) ((3:\u211d), (6:\u211d))) (x - 3, y - 6) = (y-6) * (516)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 3 - 2 * p.2 ^ 2) = (fun x => 5 * x ^ 3 - 2 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (6:\u211d)) (x - 3, y - 6) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x^3 + 5x - 5y^3 + 2y^2 - c = 0 at the point (3,6) is (x-3) * 59 - (y-6) * 516 = 0. The idea is to compute the gradient (\u2207) of the function f(x,y) = 2x^3 + 5x - 5y^3 + 2y^2 - c at (3,6), and use its dot product with the vector (x-3, y-6). Setting this expression to 0 gives the tangent line equation, and the goal is to show this is the same as (x-3) * 59 - (y-6) * 516 = 0.  Start by introducing the hypothesis stating that the dot product between the gradient and the shifted positional vector is 0. Use the derivative rule for subtraction to split the total derivative: \u2207(2x^3 + 5x - 5y^3 + 2y^2 - c) = \u2207(2x^3 + 5x - 5y^3 + 2y^2) - \u2207(c). Introduce a lemma to further decompose: \u2207(2x^3 + 5x - 5y^3 + 2y^2) = \u2207(2x^3 + 5x) - \u2207(5y^3 - 2y^2). Assume differentiability for these functions at (3,6). Rewrite the original hypothesis using these decompositions, using linearity properties to express the computation in terms of the above gradients minus the constant term. Show that \u2207(2x^3 + 5x) at (3,6) evaluated on (x-3, y-6) gives (x-3) * 59: Express this partial derivative as a composition, reducing to a single-variable function. Compute the required partial derivative with respect to x. Substitute x=3 into the derivative, and simplify. Confirm the differentiability of 2x^3 + 5x. Show that \u2207(5y^3 - 2y^2) at (3,6) evaluated on (x-3, y-6) gives (y-6) * 516: Express this partial derivative as a composition, reducing to a single-variable function. Compute the required partial derivative with respect to y. Substitute y=6 into the derivative, and simplify. Confirm the differentiability of 5y^3 - 2y^2. Show that the derivative with respect to the constant c is zero at this point. Substitute all computed pieces back into the hypothesis, and simplify the equation to obtain (x-3) * 59 - (y-6) * 516 = 0. Confirm differentiability at all steps: \u2207(2x^3 + 5x), \u2207(5y^3 - 2y^2), and the full expression, as well as the constant function."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 - 2 * p.1 - 3 * p.2 ^ 4 - 5 * p.2 ^ 3 - 5 * p.2 - c) ((-2:\u211d), (-5:\u211d)) (x-(-2), y-(-5)) = 0) \u2192 ((x-(-2)) * (-10) - (y-(-5)) * (-1120) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2 - 2 * p.1) ((-2:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 4 + 5 * p.2 ^ 3 + 5 * p.2) ((-2:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 - 2 * p.1 - 3 * p.2 ^ 4 - 5 * p.2 ^ 3 - 5 * p.2) ((-2:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2 - 2 * p.1) ((-2:\u211d), (-5:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 4 + 5 * p.2 ^ 3 + 5 * p.2) ((-2:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2 - 2 * p.1) ((-2:\u211d), (-5:\u211d))) (x - (-2), y - (-5)) = (x-(-2)) * (-10)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2 - 2 * p.1) = (fun x => 2 * x ^ 2 - 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 4 + 5 * p.2 ^ 3 + 5 * p.2) ((-2:\u211d), (-5:\u211d))) (x - (-2), y - (-5)) = (y-(-5)) * (-1120)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 4 + 5 * p.2 ^ 3 + 5 * p.2) = (fun x => 3 * x ^ 4 + 5 * x ^ 3 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (-5:\u211d)) (x - (-2), y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x^2 - 2x - 3y^4 - 5y^3 - 5y - c = 0 at the point (-2, -5) is (x-(-2)) * (-10) - (y-(-5)) * (-1120) = 0. The idea is to compute the gradient (\u2207) of f(x, y) = 2x^2 - 2x - 3y^4 - 5y^3 - 5y - c at the point (-2, -5), then take the dot product of this gradient with the vector (x-(-2), y-(-5)). Setting this equal to zero gives an equation for the tangent, which we need to relate to the given result. Introduce the hypothesis, which states that the dot product of the gradient evaluated at (-2, -5) with the vector (x-(-2), y-(-5)) is zero. Use the rule for the derivative of a subtraction to split the gradient of the full expression into \u2207(2x^2 - 2x - 3y^4 - 5y^3 - 5y) minus \u2207(c). Introduce a hypothesis which further splits the expression: the gradient of 2x^2 - 2x - 3y^4 - 5y^3 - 5y is equal to the gradient of 2x^2 - 2x minus the gradient of 3y^4 + 5y^3 + 5y, given differentiability of each component. Use this structural splitting and rules for application of linear maps to rewrite everything in terms of gradients of the simpler pieces. Show that the gradient of 2x^2 - 2x at the point (-2, -5) dotted with (x-(-2), y-(-5)) equals (x-(-2)) * (-10). Identify the function as a composition in terms of the x-variable, so that differentiation w.r.t x reduces to differentiation of 2x^2 - 2x. Compute the relevant derivatives for each term contributing to the x-component. Use the structure of the linear map given by the gradient to extract the x-part and simplify. Confirm differentiability of 2x^2 - 2x with respect to x. Show that the gradient of 3y^4 + 5y^3 + 5y at the point (-2, -5) dotted with (x-(-2), y-(-5)) equals (y-(-5)) * (-1120). Express the function as a composition in terms of the y-variable, so differentiation w.r.t y becomes computation of the derivative of 3y^4 + 5y^3 + 5y. Calculate each term's derivative relevant to the y-component. Use the effect of the linear gradient operator to collect y-terms. Confirm differentiability of 3y^4 + 5y^3 + 5y with respect to y. Verify that the gradient of the constant c at the point (-2, -5), dotted with any vector, is zero. Substitute all the individually computed results back into the hypothesis to write the tangent equation in the explicit linear form. Justify differentiability for all components: 2x^2 - 2x, 3y^4 + 5y^3 + 5y, their sums and differences, and c, as used in the steps above."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 4 - 4 * p.1 ^ 3 + 2 * p.2 ^ 3 - c) ((2:\u211d), (-6:\u211d)) (x-2, y-(-6)) = 0) \u2192 ((x-2) * (112) + (y-(-6)) * (216) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 4 - 4 * p.1 ^ 3) ((2:\u211d), (-6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3) ((2:\u211d), (-6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 4 - 4 * p.1 ^ 3 + 2 * p.2 ^ 3) ((2:\u211d), (-6:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 4 - 4 * p.1 ^ 3) ((2:\u211d), (-6:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 3) ((2:\u211d), (-6:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 4 - 4 * p.1 ^ 3) ((2:\u211d), (-6:\u211d))) (x - 2, y - (-6)) = (x-2) * (112)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 4 - 4 * p.1 ^ 3) = (fun x => 5 * x ^ 4 - 4 * x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3) ((2:\u211d), (-6:\u211d))) (x - 2, y - (-6)) = (y-(-6)) * (216)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3) = (fun x => 2 * x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (-6:\u211d)) (x - 2, y - (-6)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^4 - 4 * x^3 + 2 * y^3 - c = 0 at the point (2, -6) is (x-2) * 112 + (y-(-6)) * 216 = 0. The idea is to compute the gradient (\u2207) of the function f(x, y) = 5 * x^4 - 4 * x^3 + 2 * y^3 - c at the point (2, -6), then take the dot product with the shifted position vector (x-2, y-(-6)). Setting that equal to 0 gives the tangent equation, and we need to show this matches the claimed answer. Introduce the hypothesis, which equates the dot product of the gradient (evaluated at (2, -6)) with (x-2, y-(-6)) to 0. Use subtraction and addition rules for the derivative to split the gradient: \u2207(5 * x^4 - 4 * x^3 + 2 * y^3 - c) = \u2207(5 * x^4 - 4 * x^3 + 2 * y^3) - \u2207(c). Define a hypothesis that splits \u2207(5 * x^4 - 4 * x^3 + 2 * y^3) as \u2207(5 * x^4 - 4 * x^3) + \u2207(2 * y^3), assuming each is differentiable at the given point. Substitute this decomposition into the main equation, and expand using the rules of linear maps. Show that the contribution from the x-variable part is (x-2) * 112: Express 5 * x^4 - 4 * x^3 as a function of the first variable, composed with the appropriate projection. Use the chain rule and derivative rules (including the sum and difference rules, product rule, and power rule) to calculate the x-derivative at x=2. Show that plugging in (x-2, y-(-6)) yields the claimed expression. Justify differentiability of 5 * x^4 - 4 * x^3 as needed. Show that the contribution from the y-variable part is (y-(-6)) * 216: Express 2 * y^3 in terms of function composition with the second variable. Apply the derivative rules to get the y-derivative at y = -6. Confirm that the linear map yields (y-(-6)) * 216 after evaluating at (x-2, y-(-6)). Justify differentiability of 2 * y^3 as needed. Show that the contribution from -c is 0, since the derivative of a constant is 0. Combine the components to obtain the overall dot product expression, and then use algebraic simplification to conclude. In supporting steps, justify differentiability at each function at the given point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 + p.2 ^ 4 - 3 * p.2 ^ 3 + p.2 ^ 2 + 2 * p.2 - c) ((2:\u211d), (-3:\u211d)) (x-2, y-(-3)) = 0) \u2192 ((x-2) * (1) + (y-(-3)) * (-193) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1) ((2:\u211d), (-3:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 - 3 * p.2 ^ 3 + p.2 ^ 2 + 2 * p.2) ((2:\u211d), (-3:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 + p.2 ^ 4 - 3 * p.2 ^ 3 + p.2 ^ 2 + 2 * p.2) ((2:\u211d), (-3:\u211d))\n      = \n      fderiv \u211d (fun p => p.1) ((2:\u211d), (-3:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 - 3 * p.2 ^ 3 + p.2 ^ 2 + 2 * p.2) ((2:\u211d), (-3:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1) ((2:\u211d), (-3:\u211d))) (x - 2, y - (-3)) = (x-2) * (1)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1) = (fun x => x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_id\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 - 3 * p.2 ^ 3 + p.2 ^ 2 + 2 * p.2) ((2:\u211d), (-3:\u211d))) (x - 2, y - (-3)) = (y-(-3)) * (-193)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 - 3 * p.2 ^ 3 + p.2 ^ 2 + 2 * p.2) = (fun x => x ^ 4 - 3 * x ^ 3 + x ^ 2 + 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((2:\u211d), (-3:\u211d)) (x - 2, y - (-3)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst\n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x + y^4 - 3y^3 + y^2 + 2y - c = 0 at the point (2, -3) is (x-2) * 1 + (y-(-3)) * (-193) = 0. The idea is to compute the gradient (\u2207) of f(x, y) = x + y^4 - 3y^3 + y^2 + 2y - c at the point (2, -3), then take the dot product with the vector (x-2, y-(-3)). Setting this equal to 0 gives the tangent equation, which we need to show is exactly (x-2) * 1 + (y-(-3)) * (-193) = 0.  Introduce the hypothesis that the dot product of the gradient at (2, -3) with (x-2, y+3) is zero. Use the rule for the differential of a subtraction to split the derivative: \u2207(x + y^4 - 3y^3 + y^2 + 2y - c) = \u2207(x + y^4 - 3y^3 + y^2 + 2y) - \u2207(c). Define a hypothesis splitting the first term: \u2207(x + y^4 - 3y^3 + y^2 + 2y) = \u2207(x) + \u2207(y^4 - 3y^3 + y^2 + 2y). Assume differentiability as needed. Apply the above splitting so the main differential is now a sum and difference of differentials of the component functions. Compute the gradient of x at (2, -3) acting on (x-2, y+3): show this is (x-2) * 1. Express x as a function of p.1 and use composition rules. Reduce the question to differentiation in one variable as appropriate. Use the linear map rules to get the desired result. Justify differentiability. Compute the gradient of y^4 - 3y^3 + y^2 + 2y at (2, -3) acting on (x-2, y+3): show this is (y+3) * (-193). Express the function as depending only on p.2, use composition and single-variable differentiation rules. Calculate the required derivative with respect to y. Use the linear map rules and evaluate/extract in this context. Justify differentiability of this combined y function. Show that the derivative of the constant c is zero when evaluated, as expected. After substituting the component results into the original equation, simplify to obtain the required tangent equation. Make sure that differentiability is established for all components and combined pieces as required."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 + p.1 + p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2 - c) ((-1:\u211d), (-2:\u211d)) (x-(-1), y-(-2)) = 0) \u2192 ((x-(-1)) * (-9) + (y-(-2)) * (-35) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 + p.1) ((-1:\u211d), (-2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) ((-1:\u211d), (-2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 + p.1 + p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) ((-1:\u211d), (-2:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 + p.1) ((-1:\u211d), (-2:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) ((-1:\u211d), (-2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 + p.1) ((-1:\u211d), (-2:\u211d))) (x - (-1), y - (-2)) = (x-(-1)) * (-9)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 + p.1) = (fun x => 5 * x ^ 2 + x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) ((-1:\u211d), (-2:\u211d))) (x - (-1), y - (-2)) = (y-(-2)) * (-35)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 4 + 2 * p.2 ^ 2 + 5 * p.2) = (fun x => x ^ 4 + 2 * x ^ 2 + 5 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (-2:\u211d)) (x - (-1), y - (-2)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.add (DifferentiableAt.add (differentiableAt_snd.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 + x + y^4 + 2 * y^2 + 5 * y - c = 0 at the point (-1, -2) is (x-(-1)) * (-9) + (y-(-2)) * (-35) = 0. The overall strategy is to compute the gradient (\u2207) of the function f(x, y) = 5x^2 + x + y^4 + 2y^2 + 5y - c at the point (-1, -2), take the dot product with the vector (x-(-1), y-(-2)), set that to 0, and show this gives the required equation. Introduce the hypothesis: the dot product of the gradient evaluated at (-1, -2) with (x-(-1), y-(-2)) equals 0. Apply the rule for the derivative of a subtraction to split \u2207(5x^2 + x + y^4 + 2y^2 + 5y - c) = \u2207(5x^2 + x + y^4 + 2y^2 + 5y) - \u2207(c). Create a hypothesis to split the derivative \u2207(5x^2 + x + y^4 + 2y^2 + 5y) = \u2207(5x^2 + x) + \u2207(y^4 + 2y^2 + 5y), assuming differentiability at those parts. Use linearity of the derivative to rewrite and expand the gradient expression in terms of the identified partials. Show that \u2207(5x^2 + x) at (-1, -2) dotted with (x-(-1), y-(-2)) is (x-(-1)) * (-9). Use composition and the single-variable derivative rule for functions of p.1. Compute the derivative with respect to x. Apply the continuous linear map and do algebraic simplification to obtain the coefficient. Confirm differentiability of 5x^2 + x. Show that \u2207(y^4 + 2y^2 + 5y) at (-1, -2) dotted with (x-(-1), y-(-2)) is (y-(-2)) * (-35). Use composition and the single-variable derivative rule for functions of p.2. Compute the derivative with respect to y. Apply the continuous linear map and do algebraic simplification to obtain the coefficient. Confirm differentiability of y^4 + 2y^2 + 5y. Show that \u2207(c) at (-1, -2) dotted with (x-(-1), y-(-2)) = 0. Substitute the previously established pieces into the main hypothesis and simplify the expression. Justify all differentiability conditions for the required functions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 5 * p.1 ^ 2 - 3 * p.1 + 2 * p.2 ^ 2 - p.2 - c) ((3:\u211d), (-5:\u211d)) (x-3, y-(-5)) = 0) \u2192 ((x-3) * (27) + (y-(-5)) * (-21) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 5 * p.1 ^ 2 - 3 * p.1) ((3:\u211d), (-5:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((3:\u211d), (-5:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      5 * p.1 ^ 2 - 3 * p.1 + 2 * p.2 ^ 2 - p.2) ((3:\u211d), (-5:\u211d))\n      = \n      fderiv \u211d (fun p => 5 * p.1 ^ 2 - 3 * p.1) ((3:\u211d), (-5:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((3:\u211d), (-5:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 5 * p.1 ^ 2 - 3 * p.1) ((3:\u211d), (-5:\u211d))) (x - 3, y - (-5)) = (x-3) * (27)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 5 * p.1 ^ 2 - 3 * p.1) = (fun x => 5 * x ^ 2 - 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 2 - p.2) ((3:\u211d), (-5:\u211d))) (x - 3, y - (-5)) = (y-(-5)) * (-21)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 2 - p.2) = (fun x => 2 * x ^ 2 - x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((3:\u211d), (-5:\u211d)) (x - 3, y - (-5)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 5 * x^2 - 3 * x + 2 * y^2 - y - c = 0 at the point (3, -5) is (x-3) * (27) + (y-(-5)) * (-21) = 0. The strategy is to compute the gradient (\u2207) of the function f(x, y) = 5 * x^2 - 3 * x + 2 * y^2 - y - c at (3, -5), then use its dot product with the shifted positional vector (x - 3, y - (-5)), set this equal to 0, and then show this equation is equivalent to (x-3) * 27 + (y+5) * (-21) = 0. Introduce the hypothesis that the dot product of the gradient at (3, -5) with (x-3, y-(-5)) is 0. Apply the rule for the derivative of a subtraction to break up \u2207(5x^2 - 3x + 2y^2 - y - c) into \u2207(5x^2 - 3x + 2y^2 - y) - \u2207(c). Introduce an intermediate result splitting \u2207(5x^2 - 3x + 2y^2 - y) into the gradient with respect to x and the gradient with respect to y, assuming differentiability: Show that \u2207(5x^2 - 3x + 2y^2 - y) = \u2207(5x^2 - 3x) + \u2207(2y^2 - y). Apply the additive and linearity rules for the gradient and continuous linear maps, so that the total differential splits as a sum/difference of the terms found above. Show that evaluating the gradient of 5x^2 - 3x at (3, -5) against (x-3, y-(-5)) gives (x-3) * 27: Express 5x^2 - 3x as a function in one variable composed with the projection, to use the chain rule for gradients of composition. Use rules of differentiation (product, sum, power, constant rules) to compute the partial derivative with respect to x. Argue, using linear map algebra and simplification, that the interaction with (x-3, y-(-5)) zeros out the y-component, leaving (x-3) multiplied by the computed partial. Justify differentiability at the required places. Show that evaluating the gradient of 2y^2 - y at (3, -5) against (x-3, y-(-5)) gives (y-(-5)) * (-21): Express 2y^2 - y as a function in one variable composed with the appropriate projection, to reduce the computation to an ordinary derivative. Use rules of differentiation to compute the partial derivative with respect to y. Argue, using linear map algebra and simplification, that the result is as claimed. Justify differentiability at the required places. Show that evaluating the gradient of the constant term c is zero when applied to the shifted vector. Substitute these evaluations back into the original equation, simplify, and check that this matches the required equation of the tangent. Justify all differentiability assertions for the involved functions where needed."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 - p.1 + p.2 ^ 2 + p.2 - c) ((5:\u211d), (4:\u211d)) (x-5, y-4) = 0) \u2192 ((x-5) * (19) + (y-4) * (9) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2 - p.1) ((5:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => p.2 ^ 2 + p.2) ((5:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 - p.1 + p.2 ^ 2 + p.2) ((5:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2 - p.1) ((5:\u211d), (4:\u211d)) +\n      fderiv \u211d (fun p => p.2 ^ 2 + p.2) ((5:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2 - p.1) ((5:\u211d), (4:\u211d))) (x - 5, y - 4) = (x-5) * (19)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2 - p.1) = (fun x => 2 * x ^ 2 - x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => p.2 ^ 2 + p.2) ((5:\u211d), (4:\u211d))) (x - 5, y - 4) = (y-4) * (9)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => p.2 ^ 2 + p.2) = (fun x => x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact DifferentiableAt.add (differentiableAt_pow _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((5:\u211d), (4:\u211d)) (x - 5, y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)\n  exact DifferentiableAt.add (differentiableAt_snd.pow _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (differentiableAt_fst)) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2 * x^2 - x + y^2 + y - c = 0 at the point (5,4) is (x-5) * 19 + (y-4) * 9 = 0. The idea is to calculate the gradient (denoted by \u2207) of the function f(x, y) = 2 * x^2 - x + y^2 + y - c at the point (5, 4), then take the dot product of that with the shifted positional vector (x-5, y-4). Setting this equal to 0 yields the equation of the tangent, which we have to show matches (x-5) * 19 + (y-4) * 9 = 0. Introduce the hypothesis, which asserts that the dot product of the gradient with the shifted positional vector equals 0. Use the derivative rule for subtraction to split \u2207(2*x^2 - x + y^2 + y - c) as \u2207(2*x^2 - x + y^2 + y) - \u2207(c). State and use a hypothesis splitting the gradient of 2*x^2 - x + y^2 + y into gradients of two parts: \u2207(2*x^2 - x) + \u2207(y^2 + y), assuming differentiability at the relevant points. Substitute these pieces into the main equation and apply rules for linear maps (subtraction, addition). Show that \u2207(2*x^2 - x) at (5,4) dot (x-5, y-4) evaluates to (x-5) * 19: Use the chain rule to write this as a composition with a function of x only. Differentiate 2*x^2 - x with respect to x at x = 5. Apply the relevant properties of linear maps and simplify algebraically. Justify differentiability of 2*x^2 - x. Show that \u2207(y^2 + y) at (5,4) dot (x-5, y-4) is (y-4) * 9: Use the chain rule for a function of y only. Differentiate y^2 + y with respect to y at y = 4. Use properties of linear maps and algebraic simplification. Justify differentiability of y^2 + y. Show that the derivative of the constant c at (5,4) is zero in this context. Substitute all the above results back into the main equation and simplify using algebra to obtain the required tangent equation. Conclude by verifying the differentiability of all the involved component functions for completeness."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 ^ 2 - 2 * p.2 ^ 3 - c) ((0:\u211d), (2:\u211d)) (x-0, y-2) = 0) \u2192 ((x-0) * (0) - (y-2) * (24) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1 ^ 2) ((0:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2 ^ 3) ((0:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 ^ 2 - 2 * p.2 ^ 3) ((0:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1 ^ 2) ((0:\u211d), (2:\u211d)) -\n      fderiv \u211d (fun p => 2 * p.2 ^ 3) ((0:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1 ^ 2) ((0:\u211d), (2:\u211d))) (x - 0, y - 2) = (x-0) * (0)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1 ^ 2) = (fun x => 2 * x ^ 2) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2 ^ 3) ((0:\u211d), (2:\u211d))) (x - 0, y - 2) = (y-2) * (24)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2 ^ 3) = (fun x => 2 * x ^ 3) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((0:\u211d), (2:\u211d)) (x - 0, y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x\u00b2\u00a0\u2013\u00a02y\u00b3\u00a0\u2013\u00a0c\u00a0=\u00a00 at the point (0,2) is (x-0)\\*(0)\u00a0\u2013\u00a0(y-2)\\*(24)=0. The main idea is to compute the gradient (\u2207) of f(x,y)=2x\u00b2\u20132y\u00b3\u2013c at the point (0,2), then form the dot product of this gradient with the shifted positional vector (x-0,\u00a0y-2). Setting this quantity to zero gives the equation of the tangent we want to relate to (x-0)\\*(0)\u00a0\u2013\u00a0(y-2)\\*(24)=0. Introduce the hypothesis that the dot product of the gradient with (x-0,\u00a0y-2) equals 0. Use the linearity of the derivative to split \u2207(2x\u00b2\u00a0\u2013\u00a02y\u00b3\u00a0\u2013\u00a0c) = \u2207(2x\u00b2\u00a0\u2013\u00a02y\u00b3)\u00a0\u2013\u00a0\u2207(c). Define a hypothesis that further splits \u2207(2x\u00b2\u00a0\u2013\u00a02y\u00b3) = \u2207(2x\u00b2)\u00a0\u2013\u00a0\u2207(2y\u00b3). Assume differentiability of each part at (0,2). Using this, rewrite the original gradient as: \u2207(2x\u00b2)\u00a0\u2013\u00a0\u2207(2y\u00b3)\u00a0\u2013\u00a0\u2207(c). Compute \u2207(2x\u00b2) at (0,2) acting on (x-0,\u00a0y-2) gives (x-0)\\*(0). Use the chain rule to identify that the gradient reduces to a simple derivative in x. Find the value of the derivative with respect to x at x=0. Apply the linear maps, simplifications, and confirm this yields (x-0)\\*(0). Verify differentiability of 2x\u00b2 at (0,2). Compute \u2207(2y\u00b3) at (0,2) acting on (x-0,\u00a0y-2) gives (y-2)\\*(24). Use the chain rule to reduce the gradient to the y-variable. Calculate the value of the derivative with respect to y at y=2. Apply the linear maps, simplifications, and confirm this gives (y-2)\\*(24). Verify differentiability of 2y\u00b3 at (0,2). Show that the derivative of the constant c at (0,2) acting on any vector is zero. Substitute the results from steps 5, 6, 7 back into the original hypothesis for the full simplification. Confirm differentiability of all the required functions at the given point."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 4 * p.1 ^ 3 - 5 * p.1 ^ 2 + 2 * p.1 + 5 * p.2 ^ 2 + p.2 - c) ((-5:\u211d), (2:\u211d)) (x-(-5), y-2) = 0) \u2192 ((x-(-5)) * (352) + (y-2) * (21) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 4 * p.1 ^ 3 - 5 * p.1 ^ 2 + 2 * p.1) ((-5:\u211d), (2:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 5 * p.2 ^ 2 + p.2) ((-5:\u211d), (2:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      4 * p.1 ^ 3 - 5 * p.1 ^ 2 + 2 * p.1 + 5 * p.2 ^ 2 + p.2) ((-5:\u211d), (2:\u211d))\n      = \n      fderiv \u211d (fun p => 4 * p.1 ^ 3 - 5 * p.1 ^ 2 + 2 * p.1) ((-5:\u211d), (2:\u211d)) +\n      fderiv \u211d (fun p => 5 * p.2 ^ 2 + p.2) ((-5:\u211d), (2:\u211d)) := by\n    rw [\u2190fderiv_add]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 4 * p.1 ^ 3 - 5 * p.1 ^ 2 + 2 * p.1) ((-5:\u211d), (2:\u211d))) (x - (-5), y - 2) = (x-(-5)) * (352)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 4 * p.1 ^ 3 - 5 * p.1 ^ 2 + 2 * p.1) = (fun x => 4 * x ^ 3 - 5 * x ^ 2 + 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 5 * p.2 ^ 2 + p.2) ((-5:\u211d), (2:\u211d))) (x - (-5), y - 2) = (y-2) * (21)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 5 * p.2 ^ 2 + p.2) = (fun x => 5 * x ^ 2 + x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_id\n    exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-5:\u211d), (2:\u211d)) (x - (-5), y - 2) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst.pow _))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 4 * x^3 - 5 * x^2 + 2 * x + 5 * y^2 + y - c = 0 at the point (-5,2) is (x-(-5)) * (352) + (y-2) * (21) = 0. The strategy is to compute the gradient of the function f(x, y) = 4 * x^3 - 5 * x^2 + 2 * x + 5 * y^2 + y - c at (-5, 2), then take its dot product with (x-(-5), y-2), set this to 0, and simplify to reach the target equation. Introduce the hypothesis: the dot product of the gradient with (x-(-5), y-2) equals 0. Apply the derivative rule for subtraction to separate the gradient of the full function into the sum of the gradients of 4 * x^3 - 5 * x^2 + 2 * x + 5 * y^2 + y and the negative of the gradient of c. Define a hypothesis that splits the gradient further as the sum of the gradient of 4 * x^3 - 5 * x^2 + 2 * x in x and the gradient of 5 * y^2 + y in y, provided the corresponding parts are differentiable. Use this splitting and properties of linear maps to write the tangent equation as the sum of the results for the x-part and y-part minus the constant part. Compute the contribution from the x-part: Rewrite the function restricted to x as a composition and use chain and product rules of calculus. Compute the derivative with respect to x at x = -5. Use linear map actions and algebraic simplification to show that this is (x-(-5)) * (352). Justify the necessary differentiability. Compute the contribution from the y-part: Similarly, express the y-function as a composition and apply calculus rules. Compute its derivative at y = 2. Use linear map operations and simplification to get that this is (y-2) * (21). Prove differentiability of the y-part. Show that the gradient of the constant function c yields 0 in the dot product with (x-(-5), y-2). Substitute all computed results back, simplify the sum of terms, and conclude that the equation reduces to the desired tangent equation. Verify all differentiability assumptions for each step: the x-part, y-part, the sum expression, and the constant."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 3 - 4 * p.2 ^ 2 - c) ((-1:\u211d), (-6:\u211d)) (x-(-1), y-(-6)) = 0) \u2192 ((x-(-1)) * (3) - (y-(-6)) * (-48) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 3) ((-1:\u211d), (-6:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 4 * p.2 ^ 2) ((-1:\u211d), (-6:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 3 - 4 * p.2 ^ 2) ((-1:\u211d), (-6:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 3) ((-1:\u211d), (-6:\u211d)) -\n      fderiv \u211d (fun p => 4 * p.2 ^ 2) ((-1:\u211d), (-6:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 3) ((-1:\u211d), (-6:\u211d))) (x - (-1), y - (-6)) = (x-(-1)) * (3)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 3) = (fun x => x ^ 3) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 4 * p.2 ^ 2) ((-1:\u211d), (-6:\u211d))) (x - (-1), y - (-6)) = (y-(-6)) * (-48)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 4 * p.2 ^ 2) = (fun x => 4 * x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-1:\u211d), (-6:\u211d)) (x - (-1), y - (-6)) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact differentiableAt_fst.pow _\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^3 - 4y^2 - c = 0 at the point (-1,-6) is (x-(-1)) * 3 - (y-(-6)) * (-48) = 0. The general strategy is to compute the gradient (\u2207) of the function f(x, y) = x^3 - 4y^2 - c at the point (-1, -6), then take the dot product with the vector (x-(-1), y-(-6)). Setting this product equal to 0 gives the tangent equation, which we verify is the same as the one claimed. Introduce the hypothesis: the dot product of the gradient at the point (-1, -6) with the direction (x-(-1), y-(-6)) is zero. Apply the rule for the derivative of a difference to write the gradient of (x^3 - 4y^2 - c) as \u2207(x^3 - 4y^2) - \u2207(c). Define an intermediate step: the gradient of (x^3 - 4y^2) can be written as \u2207(x^3) - \u2207(4y^2), assuming differentiability at those components. Use this result and rules of linear maps to expand the gradient application further. Show that \u2207(x^3) at (-1, -6), applied to (x-(-1), y-(-6)), equals (x-(-1)) * 3. Write x^3 as a composition with the projection onto the first variable. Use the chain rule and rules for single-variable polynomials. Transform into a scalar multiplication via the linear map. Prove differentiability of x \u21a6 x^3. Show that \u2207(4y^2) at (-1, -6), applied to (x-(-1), y-(-6)), equals (y-(-6)) * (-48). Write 4y^2 as a composition with the projection onto the second variable. Differentiate using the product and power rule. Show the linear map becomes scalar multiplication. Prove differentiability of y \u21a6 4y^2. Show that \u2207(c) at any point applied to any vector is zero. Substitute these computations into the expanded tangent equation and simplify the result algebraically. Justify differentiability of all relevant functions at the required points."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 p.1 ^ 4 + 3 * p.1 - 3 * p.2 ^ 4 + p.2 ^ 3 - p.2 ^ 2 - c) ((-2:\u211d), (4:\u211d)) (x-(-2), y-4) = 0) \u2192 ((x-(-2)) * (-29) - (y-4) * (728) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => p.1 ^ 4 + 3 * p.1) ((-2:\u211d), (4:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 3 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2) ((-2:\u211d), (4:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      p.1 ^ 4 + 3 * p.1 - 3 * p.2 ^ 4 + p.2 ^ 3 - p.2 ^ 2) ((-2:\u211d), (4:\u211d))\n      = \n      fderiv \u211d (fun p => p.1 ^ 4 + 3 * p.1) ((-2:\u211d), (4:\u211d)) -\n      fderiv \u211d (fun p => 3 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2) ((-2:\u211d), (4:\u211d)) := by\n    rw [\u2190fderiv_sub]\n    congr 1\n    ext p\n    ring\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => p.1 ^ 4 + 3 * p.1) ((-2:\u211d), (4:\u211d))) (x - (-2), y - 4) = (x-(-2)) * (-29)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => p.1 ^ 4 + 3 * p.1) = (fun x => x ^ 4 + 3 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    norm_num\n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    exact DifferentiableAt.add (differentiableAt_pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id))\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 3 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2) ((-2:\u211d), (4:\u211d))) (x - (-2), y - 4) = (y-4) * (728)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 3 * p.2 ^ 4 - p.2 ^ 3 + p.2 ^ 2) = (fun x => 3 * x ^ 4 - x ^ 3 + x ^ 2) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_add]\n    nth_rewrite 1 [deriv_sub]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    nth_rewrite 1 [deriv_pow'']\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    norm_num\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_id\n    exact differentiableAt_const _\n    exact differentiableAt_pow _\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)\n    exact differentiableAt_pow _\n    exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_pow _)) (differentiableAt_pow _)) (differentiableAt_pow _)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-2:\u211d), (4:\u211d)) (x - (-2), y - 4) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))\n  exact DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)\n  \n  exact DifferentiableAt.sub (DifferentiableAt.add (DifferentiableAt.sub (DifferentiableAt.add (differentiableAt_fst.pow _) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst))) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd.pow _))) (differentiableAt_snd.pow _)) (differentiableAt_snd.pow _)\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve x^4 + 3x - 3y^4 + y^3 - y^2 - c = 0 at the point (-2,4) is (x-(-2)) * (-29) - (y-4) * (728) = 0. The main idea is to compute the gradient (\u2207) of the function f(x,y) = x^4 + 3x - 3y^4 + y^3 - y^2 - c at the point (-2,4), take the dot product of the gradient with the vector (x-(-2), y-4), and set that to zero. This gives the equation of the tangent, which we need to show matches the expression in the conclusion. Introduce the hypothesis, which states this dot product is zero. Apply the rule for the derivative of a subtraction to split \u2207(x^4 + 3x - 3y^4 + y^3 - y^2 - c) into \u2207(x^4 + 3x - 3y^4 + y^3 - y^2) - \u2207(c). Introduce a hypothesis that splits the first term further: \u2207(x^4 + 3x - 3y^4 + y^3 - y^2) = \u2207(x^4 + 3x) - \u2207(3y^4 - y^3 + y^2). Here, assume differentiability where needed. Use that split and the rules of linear maps to rewrite the overall gradient as \u2207(x^4 + 3x) - \u2207(3y^4 - y^3 + y^2) - \u2207(c). Show that the directional derivative of \u2207(x^4 + 3x) at (-2, 4) in the given direction is (x-(-2)) * (-29). Use chain/composition rules to express the gradient with respect to x only. Compute the derivative with respect to x. Use properties of linear maps and simplification to show the result. Prove differentiability of x^4 + 3x. Show that the directional derivative of \u2207(3y^4 - y^3 + y^2) at (-2,4) in the same direction is (y-4) * (728). Use chain/composition rules to express the gradient with respect to y only. Compute the derivative with respect to y. Use properties of linear maps and simplification. Prove differentiability of 3y^4 - y^3 + y^2. Show that the directional derivative of \u2207(c) at (-2,4) in any direction is zero because c is a constant. Use these re-writings to simplify the original hypothesis to the desired tangent equation. Prove the required differentiability for all necessary component functions."
    },
    {
        "theorem": "example (x y c: \u211d) : (fderiv \u211d (fun p \u21a6 2 * p.1 + 2 * p.2 - c) ((-4:\u211d), (1:\u211d)) (x-(-4), y-1) = 0) \u2192 ((x-(-4)) * (2) + (y-1) * (2) = 0) := by",
        "proof": "\n  intro h\n  rw [fderiv_sub] at h\n\n  have h_split \n  (hp1: DifferentiableAt \u211d (fun p => 2 * p.1) ((-4:\u211d), (1:\u211d)))\n  (hp2: DifferentiableAt \u211d (fun p => 2 * p.2) ((-4:\u211d), (1:\u211d))): \n    fderiv \u211d (fun p : \u211d \u00d7 \u211d => \n      2 * p.1 + 2 * p.2) ((-4:\u211d), (1:\u211d))\n      = \n      fderiv \u211d (fun p => 2 * p.1) ((-4:\u211d), (1:\u211d)) +\n      fderiv \u211d (fun p => 2 * p.2) ((-4:\u211d), (1:\u211d)) := by\n    rw [\u2190fderiv_add]\n    \n    exact hp1\n    exact hp2\n\n  rw [h_split] at h\n  rw [ContinuousLinearMap.sub_apply] at h\n  rw [ContinuousLinearMap.add_apply] at h\n\n  have h1 : (fderiv \u211d (fun p => 2 * p.1) ((-4:\u211d), (1:\u211d))) (x - (-4), y - 1) = (x-(-4)) * (2)  := by\n    have hp1comp : (fun p : \u211d \u00d7 \u211d => 2 * p.1) = (fun x => 2 * x) \u2218 (fun p => p.1) := rfl\n    rw [hp1comp]\n    rw [fderiv_comp]\n    rw [fderiv_fst]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_fst']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_fst\n\n  have h2 : (fderiv \u211d (fun p => 2 * p.2) ((-4:\u211d), (1:\u211d))) (x - (-4), y - 1) = (y-1) * (2)  := by\n    have hp2comp : (fun p : \u211d \u00d7 \u211d => 2 * p.2) = (fun x => 2 * x) \u2218 (fun p => p.2) := rfl\n    rw [hp2comp]\n    rw [fderiv_comp]\n    rw [fderiv_snd]\n    rw [\u2190deriv_fderiv]\n    nth_rewrite 1 [deriv_mul]\n    nth_rewrite 1 [deriv_const]\n    nth_rewrite 1 [deriv_id'']\n    \n    rw [ContinuousLinearMap.comp_apply]\n    rw [ContinuousLinearMap.smulRight_apply]\n    rw [ContinuousLinearMap.coe_snd']\n    field_simp\n    \n    exact differentiableAt_const _\n    exact differentiableAt_id\n    exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_id)\n    \n    exact differentiableAt_snd\n\n  have h3 : fderiv \u211d (fun p : \u211d \u00d7 \u211d => (c:\u211d)) ((-4:\u211d), (1:\u211d)) (x - (-4), y - 1) = 0 := by\n    rw [fderiv_const]\n    field_simp\n\n  rw [h1] at h\n  rw [h2] at h\n  rw [h3] at h\n  ring_nf at h\n  linarith\n\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)\n  exact DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd)\n  \n  exact DifferentiableAt.add (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_fst)) (DifferentiableAt.mul (differentiableAt_const _) (differentiableAt_snd))\n\n  exact differentiableAt_const _\n",
        "annotation": "We want to prove that the equation of the tangent to the curve 2x + 2y - c = 0 at the point (-4,1) is (x-(-4)) * (2) + (y-1) * (2) = 0. The method is to compute the gradient (\u2207) of the function f(x,y) = 2x + 2y - c at the point (-4,1), take the dot product of this gradient with the shifted positional vector (x-(-4), y-1), set it equal to 0, and simplify to the desired tangent equation. Introduce the hypothesis: the dot product of the gradient and the shifted positional vector equals zero. Split the derivative: apply differentiation rules to express the gradient of 2x + 2y - c as the gradient of (2x + 2y) minus the gradient of the constant c. Introduce a hypothesis giving a further split: show that the gradient of (2x + 2y) at (-4,1) is the sum of the gradients of (2x) and (2y), assuming differentiability for each term. By the above splitting, and using linearity properties of the differential, write the gradient of the whole function at the required point as the sum of the gradients for 2x and 2y, minus the gradient of c. Show that the gradient of (2x) at (-4,1) dot (x-(-4), y-1) equals (x-(-4)) * (2): Recognize (2x) as a composition; apply rules for the derivatives of such functions. Calculate the simple derivative with respect to x. Use linearity of the differential to write the result as a scalar multiple. Implicitly justify differentiability at this point. Show that the gradient of (2y) at (-4,1) dot (x-(-4), y-1) equals (y-1) * (2): Recognize (2y) as a composition; apply rules as above for the second component. Calculate the simple derivative with respect to y. Use linearity to write the result as a scalar multiple. Implicitly justify differentiability at this point. Show that the gradient of the constant c at any point, dot any vector, is zero. Substitute the just-computed values into the original equation, deduce (x-(-4)) * (2) + (y-1) * (2) = 0. Justify differentiability for each of the constituent functions at the point of interest."
    }
]